<!DOCTYPE html>
<html lang="vi">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Order Helper Pro - Advanced Edition</title>
  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <!-- CSS Files -->
  <link rel="stylesheet" href="css/variables.css">
  <link rel="stylesheet" href="css/base.css">
  <link rel="stylesheet" href="css/components.css">
  <link rel="stylesheet" href="css/layout.css">
  <link rel="stylesheet" href="css/utilities.css">

</head>

<body>

  <div class="container">
    <!-- Header -->
    <div class="header">
      <h1>Order Helper Pro</h1>
      <div class="badge">Advanced Edition - Quick Parse + History + Debt Tracking</div>
    </div>

    <!-- Global Search Bar -->
    <div class="global-search-container">
      <div class="global-search-wrapper">
        <span class="search-icon">ğŸ”</span>
        <input type="text" id="globalSearch" class="global-search-input"
          placeholder="TÃ¬m kiáº¿m order, VIP, mÃ³n Äƒn... (Ctrl+K)" oninput="handleGlobalSearch(this.value)"
          onfocus="this.select()">
        <button class="search-clear" onclick="clearGlobalSearch()" style="display: none;">âœ•</button>
      </div>
      <div id="searchResults" class="search-results-dropdown"></div>
    </div>

    <!-- Tabs -->
    <div class="tabs">
      <div class="tab active" onclick="switchTab(event, 'newOrder')">
        ğŸ†• Táº¡o Ä‘Æ¡n má»›i
      </div>
      <div class="tab" onclick="switchTab(event, 'history')" style="display: none;">
        ğŸ“œ Lá»‹ch sá»­ Ä‘Æ¡n hÃ ng
      </div>
      <div class="tab" onclick="switchTab(event, 'debt')">
        ğŸ’° Quáº£n lÃ½ cÃ´ng ná»£
      </div>
      <div class="tab" onclick="switchTab(event, 'stats')">
        ğŸ“Š Thá»‘ng kÃª
      </div>
      <div class="tab" onclick="switchTab(event, 'reports')">
        ğŸ“‹ BÃ¡o cÃ¡o
      </div>
      <div class="tab" onclick="switchTab(event, 'backup')">
        â˜ï¸ Backup
      </div>
    </div>

    <!-- Tab: New Order -->
    <div id="newOrder" class="tab-content active">
      <div class="grid">
        <!-- Quick Parse Input -->
        <div class="glass-card">
          <div class="section-title">âš¡ Nháº­p nhanh</div>

          <div class="form-group">
            <label class="form-label">Paste danh sÃ¡ch order</label>
            <textarea id="quickInput" class="form-textarea" rows="4"
              placeholder="VD: aDuck, aDave 8, Lucas, Alvis, Hunter, Harrison, Ryan 2, Daniel 2, Ben 2"></textarea>
            <div class="helper-text">
              <strong>Format:</strong> TÃªn (sá»‘ pháº§n máº·c Ä‘á»‹nh = 1), TÃªn 2 (2 pháº§n), TÃªn 3, ...
            </div>
          </div>

          <button class="btn btn-secondary btn-full" onclick="parseQuickInput()">
            ğŸš€ Parse & Fill vÃ o báº£ng
          </button>
        </div>

        <!-- Item & Pricing -->
        <div class="glass-card">
          <div class="section-title">ThÃ´ng tin mÃ³n Äƒn</div>

          <div class="form-group">
            <label class="form-label">TÃªn mÃ³n</label>
            <input id="itemName" class="form-input" list="dishNameHistory" value="Phá»Ÿ bÃ²"
              placeholder="Nháº­p hoáº·c chá»n tÃªn mÃ³n..." autocomplete="off">
            <datalist id="dishNameHistory"></datalist>
            <div class="helper-text">CÃ³ thá»ƒ chá»n mÃ³n tá»« lá»‹ch sá»­ hoáº·c nháº­p tÃªn má»›i</div>
          </div>

          <div class="form-row">
            <div class="form-group">
              <label class="form-label">Tá»•ng pháº§n (n)</label>
              <input id="n" class="form-input" type="number" min="2" step="1" value="12">
              <div class="helper-text">ÄÃ£ tÃ­nh cáº£ pháº§n cá»§a LÃ£o nhÃ¢n gia</div>
            </div>
          </div>

          <div class="checkbox-wrapper">
            <input id="alvinFree" type="checkbox" checked>
            <label class="checkbox-label">
              <strong>LÃ£o nhÃ¢n gia Äƒn 1 pháº§n</strong><br>

            </label>
          </div>

          <div class="form-row">
            <div class="form-group">
              <label class="form-label">Tá»•ng tiá»n mÃ³n (T)</label>
              <input id="totalCost" class="form-input" type="number" min="0" step="1" value="0">
            </div>
            <div class="form-group">
              <label class="form-label">Chi phÃ­/pháº§n (c)</label>
              <input id="costPerUnit" class="form-input" type="number" min="0" step="0.01" value="0">
              <div class="helper-text">Äá»ƒ 0 náº¿u dÃ¹ng T</div>
            </div>
          </div>

          <div class="form-row">
            <div class="form-group">
              <label class="form-label">PhÃ­ ship (S)</label>
              <input id="shipFee" class="form-input" type="number" min="0" step="1" value="0">
            </div>
            <div class="form-group">
              <label class="form-label">Lá»£i nhuáº­n má»¥c tiÃªu</label>
              <input id="targetProfit" class="form-input" type="number" min="0" step="1" value="6">
            </div>
          </div>

          <div class="form-group">
            <label class="form-label">GiÃ¡ bÃ¡n mong muá»‘n</label>
            <input id="desiredPrice" class="form-input" type="number" min="0" step="1"
              placeholder="Nháº­p giÃ¡ muá»‘n bÃ¡n...">
            <div class="helper-text">Tá»± nháº­p giÃ¡ náº¿u khÃ´ng dÃ¹ng má»©c gá»£i Ã½</div>
          </div>

          <button class="btn btn-secondary btn-full" onclick="suggestPrices()">
            ğŸ’¡ Äá» xuáº¥t 2 má»©c giÃ¡
          </button>

          <div id="priceSuggestion"></div>
        </div>

        <!-- VIP Management -->
        <div class="glass-card">
          <div class="section-title">Quáº£n lÃ½ VIP</div>

          <div class="form-group">
            <label class="form-label">Danh sÃ¡ch VIP (name=balance) - Click Ä‘á»ƒ xem bÃ¡o cÃ¡o</label>
            <div id="vipListContainer" style="
              background: rgba(30, 41, 59, 0.6);
              border: 1px solid rgba(99, 102, 241, 0.3);
              border-radius: 8px;
              padding: 12px;
              font-family: 'Courier New', monospace;
              font-size: 14px;
            ">
              <!-- VIP list will be rendered here -->
            </div>
            <textarea id="vipArea" style="display: none;">a Duck=145</textarea>
          </div>

          <div class="btn-group">
            <button type="button" class="btn btn-secondary" onclick="addNewVIP()">
              â• Náº¡p VIP
            </button>
            <button type="button" class="btn btn-warning" onclick="cashOutVIP()">
              ğŸ’¸ Cash Out
            </button>
          </div>

          <div class="alert alert-info" style="margin-top: 12px;">
            â„¹ï¸ Khi chá»‘t Ä‘Æ¡n, VIP sáº½ tá»± Ä‘á»™ng trá»« tiá»n. Sá»‘ dÆ° hiá»ƒn thá»‹ trong tin chá»‘t lÃ  sá»‘ dÆ° SAU KHI ÄÃƒ TRá»ª.
          </div>

          <div class="glass-card" style="margin-top: 16px; padding: 16px; background: rgba(255,255,255,0.03);">
            <div class="section-title" style="margin-bottom: 10px;">ğŸª™ Lá»‹ch sá»­ náº¡p/rÃºt VIP</div>
            <div id="vipHistory"></div>
          </div>
        </div>
      </div>

      <div class="glass-card draft-save-card">
        <div class="draft-status">
          <span id="draftStatusDot" class="draft-dot unsaved" aria-label="Tráº¡ng thÃ¡i lÆ°u nhÃ¡p"></span>
          <div>
            <div id="draftStatusText" class="draft-status-text">NhÃ¡p chÆ°a lÆ°u</div>
            <div id="draftMetaText" class="draft-meta">Tá»± Ä‘á»™ng lÆ°u 30 phÃºt/láº§n | LÆ°u cuá»‘i: â€”</div>
            <div id="draftBannerMessage" class="draft-banner"></div>
          </div>
        </div>
        <div class="draft-actions">
          <button class="btn btn-primary" onclick="saveTempDraft()" title="LÆ°u Ä‘Æ¡n hiá»‡n táº¡i vÃ o bá»™ nhá»› táº¡m">ğŸ’¾ LÆ°u
            táº¡m</button>
          <button class="btn btn-secondary" onclick="showDraftManager()" title="Xem danh sÃ¡ch cÃ¡c Ä‘Æ¡n Ä‘Ã£ lÆ°u táº¡m">ğŸ“‚
            Quáº£n lÃ½ nhÃ¡p</button>
          <button class="btn btn-ghost" onclick="startNewOrder()" title="Dá»n dáº¹p form Ä‘á»ƒ báº¯t Ä‘áº§u Ä‘Æ¡n má»›i">â• ÄÆ¡n
            má»›i</button>
          <button class="btn btn-danger" onclick="clearDraft()" title="XoÃ¡ Ä‘Æ¡n nhÃ¡p hiá»‡n táº¡i">ğŸ—‘ï¸ XoÃ¡ nhÃ¡p</button>
        </div>
      </div>

      <!-- Order Table -->
      <div class="glass-card" style="margin-top: 24px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
          <div class="section-title" style="margin: 0;">Danh sÃ¡ch order</div>
          <button class="btn btn-ghost" onclick="addRow()">+ ThÃªm ngÆ°á»i</button>
        </div>

        <div class="table-wrapper">
          <table class="table" id="orderTable">
            <thead>
              <tr>
                <th style="width: 36%">TÃªn</th>
                <th style="width: 16%; text-align: right;">Sá»‘ pháº§n</th>
                <th style="width: 16%; text-align: right;">Pháº§n ship</th>
                <th style="width: 16%; text-align: center;">ÄÃ£ tráº£?</th>
                <th style="width: 16%; text-align: center;">XoÃ¡</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><input class="name-input" value="Ben" placeholder="Nháº­p tÃªn..."></td>
                <td><input type="number" min="1" step="1" value="1"></td>
                <td><input type="number" min="0" step="1" value="0" class="ship-count-input" placeholder="0"></td>
                <td style="text-align: center;"><input type="checkbox" class="payment-check"></td>
                <td style="text-align: center;"><button class="btn btn-danger" onclick="delRow(this)">âœ•</button></td>
              </tr>
            </tbody>
          </table>
        </div>

        <div class="helper-text">
          <strong>LÆ°u Ã½:</strong> Tick "ÄÃ£ tráº£" cho ngÆ°á»i Ä‘Ã£ thanh toÃ¡n ngay
        </div>
      </div>

      <!-- Compute Section -->
      <div class="glass-card" style="margin-top: 24px;">
        <div class="btn-group">
          <button class="btn btn-secondary" onclick="compute({ save: false })" style="flex: 1;">
            ğŸ§® TÃ­nh tiá»n
          </button>
          <button class="btn btn-primary" onclick="compute({ save: true })" style="flex: 1;">
            ğŸ’¾ LÆ°u Ä‘Æ¡n
          </button>
          <button class="btn btn-warning" onclick="resetOutput()" style="flex: 1;">
            ğŸ—‘ï¸ XoÃ¡ káº¿t quáº£
          </button>
        </div>

        <div id="summarySection"></div>
      </div>

      <!-- Message Output -->
      <div class="grid grid-2" style="margin-top: 24px;">
        <div class="glass-card">
          <div class="section-title">Tin nháº¯n chá»‘t Ä‘Æ¡n</div>

          <div class="form-group">
            <textarea id="finalMsg" class="form-textarea" rows="6" readonly></textarea>
          </div>

          <button class="btn btn-primary btn-full" onclick="copyAndSaveFinalMsg(event)">
            ğŸ“‹ Copy tin chá»‘t
          </button>
        </div>

        <div class="glass-card">
          <div class="section-title">Tin má»Ÿ order</div>

          <div class="form-group">
            <label class="form-label">Chá»n mÃ³n nhanh (tá»« lá»‹ch sá»­)</label>
            <select id="quickOrderSelect" class="form-input"></select>
            <div class="helper-text">Danh sÃ¡ch tá»± cáº­p nháº­t má»—i khi lÆ°u Ä‘Æ¡n</div>
          </div>

          <div class="form-row">
            <div class="form-group">
              <label class="form-label">Sá»‘ lÆ°á»£ng order</label>
              <input id="quickOrderQty" class="form-input" type="number" min="1" step="1" value="1">
            </div>
            <div class="form-group" style="display: flex; align-items: flex-end;">
              <button class="btn btn-secondary btn-full" onclick="generateOpenMsg()">Táº¡o tin</button>
            </div>
          </div>

          <div class="form-group">
            <textarea id="openMsg" class="form-textarea" rows="6" readonly></textarea>
          </div>

          <button class="btn btn-primary btn-full" onclick="copyMsg('openMsg', event)">
            ğŸ“‹ Copy tin má»Ÿ
          </button>
        </div>
      </div>
    </div>

    <!-- Tab: History -->
    <div id="history" class="tab-content">
      <div class="glass-card">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
          <div class="section-title" style="margin: 0;">Lá»‹ch sá»­ Ä‘Æ¡n hÃ ng</div>
          <div class="btn-group">
            <button class="btn btn-info" onclick="importHistory()">ğŸ“¤ Import</button>
            <button class="btn btn-secondary" onclick="exportHistory()">ğŸ“¥ Export JSON</button>
            <button class="btn btn-warning" onclick="clearHistory()">ğŸ—‘ï¸ XoÃ¡ táº¥t cáº£</button>
          </div>
        </div>

        <!-- Filter Controls -->
        <div class="history-filters" style="margin-bottom: 20px;">
          <div
            style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; margin-bottom: 12px;">
            <div>
              <label style="display: block; font-size: 0.75rem; color: var(--text-muted); margin-bottom: 4px;">ğŸ“… Tá»«
                ngÃ y</label>
              <input type="date" id="filterFromDate" class="form-input" style="padding: 8px 12px;"
                onchange="applyHistoryFilters()">
            </div>
            <div>
              <label style="display: block; font-size: 0.75rem; color: var(--text-muted); margin-bottom: 4px;">ğŸ“… Äáº¿n
                ngÃ y</label>
              <input type="date" id="filterToDate" class="form-input" style="padding: 8px 12px;"
                onchange="applyHistoryFilters()">
            </div>
            <div>
              <label style="display: block; font-size: 0.75rem; color: var(--text-muted); margin-bottom: 4px;">ğŸ‘¤
                VIP</label>
              <select id="filterVIP" class="form-select" style="padding: 8px 12px;" onchange="applyHistoryFilters()">
                <option value="">Táº¥t cáº£</option>
              </select>
            </div>
            <div>
              <label style="display: block; font-size: 0.75rem; color: var(--text-muted); margin-bottom: 4px;">ğŸœ MÃ³n
                Äƒn</label>
              <input type="text" id="filterItem" class="form-input" style="padding: 8px 12px;" placeholder="TÃ¬m mÃ³n..."
                oninput="applyHistoryFilters()">
            </div>
          </div>
          <div style="display: flex; gap: 8px; align-items: center;">
            <button class="btn btn-primary" onclick="applyHistoryFilters()" style="padding: 8px 16px;">
              ğŸ” Lá»c
            </button>
            <button class="btn btn-secondary" onclick="clearHistoryFilters()" style="padding: 8px 16px;">
              âœ• XÃ³a bá»™ lá»c
            </button>
            <div id="filterSummary" style="flex: 1; font-size: 0.85rem; color: var(--text-muted);"></div>
          </div>
        </div>

        <div id="historyList"></div>
      </div>
    </div>

    <!-- Tab: Debt Management -->
    <div id="debt" class="tab-content">
      <div class="glass-card">
        <div class="section-title">ğŸ’° Tá»•ng quan cÃ´ng ná»£</div>
        <div id="debtSummary"></div>
      </div>

      <div class="glass-card" style="margin-top: 24px;">
        <div class="section-title">ğŸ“‹ Chi tiáº¿t tá»«ng ngÆ°á»i</div>
        <div id="debtDetails"></div>
      </div>

      <!-- VIP Transaction History -->
      <div class="glass-card" style="margin-top: 24px;">
        <div class="section-title">ğŸ“Š Lá»‹ch sá»­ giao dá»‹ch VIP</div>

        <div class="form-group">
          <label class="form-label">Chá»n VIP member</label>
          <select id="vipMemberSelect" class="form-input" onchange="showVipMemberHistory()">
            <option value="">-- Chá»n VIP --</option>
          </select>
        </div>

        <div class="form-group">
          <label class="form-label">Sá»‘ dÆ° ban Ä‘áº§u (Ä‘)</label>
          <input type="number" id="vipInitialBalance" class="form-input" placeholder="0" oninput="saveInitialBalance()"
            onblur="saveInitialBalance()">
          <div class="helper-text">Nháº­p sá»‘ dÆ° táº¡i thá»i Ä‘iá»ƒm báº¯t Ä‘áº§u tÃ­nh (Ä‘á»ƒ trá»‘ng = 0Ä‘)</div>
        </div>

        <!-- Transaction Filters -->
        <div id="vipHistoryFilters"
          style="display: none; margin-top: 16px; padding: 16px; background: rgba(255,255,255,0.03); border-radius: 12px; border: 1px solid rgba(255,255,255,0.08);">
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px;">
            <div class="form-group" style="margin: 0;">
              <label class="form-label" style="font-size: 12px;">Tá»« ngÃ y</label>
              <input type="date" id="filterDateFrom" class="form-input" style="font-size: 13px; padding: 8px;"
                onchange="applyVipHistoryFilters()">
            </div>
            <div class="form-group" style="margin: 0;">
              <label class="form-label" style="font-size: 12px;">Äáº¿n ngÃ y</label>
              <input type="date" id="filterDateTo" class="form-input" style="font-size: 13px; padding: 8px;"
                onchange="applyVipHistoryFilters()">
            </div>
            <div class="form-group" style="margin: 0;">
              <label class="form-label" style="font-size: 12px;">Loáº¡i giao dá»‹ch</label>
              <select id="filterTxType" class="form-input" style="font-size: 13px; padding: 8px;"
                onchange="applyVipHistoryFilters()">
                <option value="all">Táº¥t cáº£</option>
                <option value="topup">ğŸ’° Náº¡p tiá»n</option>
                <option value="cashout">ğŸ’¸ RÃºt tiá»n</option>
                <option value="order">ğŸœ Order</option>
              </select>
            </div>
            <div class="form-group" style="margin: 0;">
              <label class="form-label" style="font-size: 12px;">Tráº¡ng thÃ¡i thanh toÃ¡n</label>
              <select id="filterPaymentStatus" class="form-input" style="font-size: 13px; padding: 8px;"
                onchange="applyVipHistoryFilters()">
                <option value="all">Táº¥t cáº£</option>
                <option value="paid">âœ… ÄÃ£ tráº£</option>
                <option value="unpaid">â³ ChÆ°a tráº£</option>
              </select>
            </div>
          </div>
          <div style="display: flex; gap: 8px; margin-top: 12px; flex-wrap: wrap;">
            <button onclick="clearVipHistoryFilters()" class="btn-secondary"
              style="padding: 8px 16px; font-size: 13px;">ğŸ”„ Äáº·t láº¡i</button>
            <button onclick="exportVipHistoryToCSV()" class="btn-primary"
              style="padding: 8px 16px; font-size: 13px; background: linear-gradient(135deg, var(--accent-green), var(--accent-blue));">ğŸ“¥
              Xuáº¥t CSV</button>
            <div style="flex: 1;"></div>
            <span id="filterResultCount" style="font-size: 13px; color: var(--text-muted); line-height: 32px;"></span>
          </div>
        </div>

        <div id="vipMemberHistoryContainer"></div>
      </div>
    </div>

    <!-- Tab: Stats -->
    <div id="stats" class="tab-content">
      <div class="glass-card">
        <div class="section-title">ğŸ“Š Thá»‘ng kÃª tá»•ng quan</div>
        <div id="statsContent"></div>
      </div>
    </div>

    <!-- Tab: Backup -->

    <!-- Tab: Reports Menu -->
    <div id="reports" class="tab-content">
      <div class="glass-card">
        <div class="section-title">ğŸ“‹ Chá»n loáº¡i bÃ¡o cÃ¡o</div>

        <div
          style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 24px; margin-top: 24px;">

          <!-- Option 1: VIP Report -->
          <div class="report-option-card" onclick="switchTab(event, 'vipReport')"
            style="cursor: pointer; padding: 32px; background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%); border-radius: 16px; border: 2px solid rgba(102, 126, 234, 0.3); transition: all 0.3s ease;">
            <div style="font-size: 48px; margin-bottom: 16px; text-align: center;">ğŸ“Š</div>
            <h3
              style="font-size: 20px; font-weight: 700; margin-bottom: 12px; text-align: center; color: var(--text-primary);">
              BÃ¡o cÃ¡o VIP - Sá»• phá»¥</h3>
            <p style="color: var(--text-secondary); text-align: center; font-size: 14px; line-height: 1.6;">
              Xem chi tiáº¿t giao dá»‹ch VIP: náº¡p tiá»n, rÃºt tiá»n, thanh toÃ¡n Ä‘Æ¡n hÃ ng vÃ  sá»‘ dÆ° hiá»‡n táº¡i
            </p>
            <div style="margin-top: 20px; text-align: center;">
              <span
                style="display: inline-block; padding: 8px 20px; background: rgba(102, 126, 234, 0.2); color: #667eea; border-radius: 20px; font-size: 13px; font-weight: 600;">
                Xem chi tiáº¿t â†’
              </span>
            </div>
          </div>

          <!-- Option 2: Order History -->
          <div class="report-option-card" onclick="switchTab(event, 'history')"
            style="cursor: pointer; padding: 32px; background: linear-gradient(135deg, rgba(251, 191, 36, 0.1) 0%, rgba(245, 158, 11, 0.1) 100%); border-radius: 16px; border: 2px solid rgba(251, 191, 36, 0.3); transition: all 0.3s ease;">
            <div style="font-size: 48px; margin-bottom: 16px; text-align: center;">ğŸ“œ</div>
            <h3
              style="font-size: 20px; font-weight: 700; margin-bottom: 12px; text-align: center; color: var(--text-primary);">
              Lá»‹ch sá»­ Ä‘Æ¡n hÃ ng</h3>
            <p style="color: var(--text-secondary); text-align: center; font-size: 14px; line-height: 1.6;">
              Xem toÃ n bá»™ lá»‹ch sá»­ Ä‘Æ¡n hÃ ng, lá»c theo ngÃ y, tÃ¬m kiáº¿m vÃ  xuáº¥t bÃ¡o cÃ¡o
            </p>
            <div style="margin-top: 20px; text-align: center;">
              <span
                style="display: inline-block; padding: 8px 20px; background: rgba(251, 191, 36, 0.2); color: #fbbf24; border-radius: 20px; font-size: 13px; font-weight: 600;">
                Xem chi tiáº¿t â†’
              </span>
            </div>
          </div>

        </div>
      </div>
    </div>

    <!-- Tab: VIP Report -->
    <div id="vipReport" class="tab-content">
      <div class="glass-card">
        <div class="section-title">ğŸ“‹ BÃ¡o cÃ¡o VIP - Sá»• phá»¥</div>

        <!-- Controls -->
        <div style="display: flex; gap: 12px; margin-bottom: 20px; flex-wrap: wrap;">
          <div style="flex: 1; min-width: 200px;">
            <label style="display: block; margin-bottom: 4px; font-weight: 500;">Chá»n VIP Member</label>
            <select id="vipReportMember" class="form-input" onchange="renderVipReport()">
              <option value="">-- Chá»n ngÆ°á»i --</option>
            </select>
          </div>

          <div style="flex: 0 0 auto; display: flex; align-items: flex-end; gap: 8px;">
            <button class="btn btn-success" onclick="exportVipReportCSV()">
              ğŸ“¤ Xuáº¥t CSV
            </button>
            <button class="btn btn-primary" onclick="exportVipReportHTML()">
              ğŸ¨ Xuáº¥t HTML
            </button>
            <button id="btnReconcile" class="btn btn-secondary" onclick="toggleReconcile()"
              style="background: rgba(245, 158, 11, 0.2); color: #fbbf24; border: 1px solid rgba(245, 158, 11, 0.5);">
              ğŸ” Äá»‘i soÃ¡t
            </button>
          </div>
        </div>

        <!-- Date Filters (Optional) -->
        <div style="display: flex; gap: 12px; margin-bottom: 20px;">
          <div>
            <label style="display: block; margin-bottom: 4px;">Tá»« ngÃ y (tuá»³ chá»n)</label>
            <input type="date" id="vipReportFromDate" class="form-input" onchange="renderVipReport()" />
          </div>
          <div>
            <label style="display: block; margin-bottom: 4px;">Äáº¿n ngÃ y (tuá»³ chá»n)</label>
            <input type="date" id="vipReportToDate" class="form-input" onchange="renderVipReport()" />
          </div>
        </div>

        <!-- Summary Box -->
        <div id="vipReportSummary"
          style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 20px; border-radius: 12px; color: white; margin-bottom: 20px; display: none;">
          <!-- Will be populated by JS -->
        </div>

        <!-- Transaction Table -->
        <div style="overflow-x: auto;">
          <table id="vipReportTable" style="width: 100%; border-collapse: collapse; display: none;">
            <thead>
              <tr style="background: rgba(102, 126, 234, 0.1); border-bottom: 2px solid rgba(102, 126, 234, 0.3);">
                <th style="padding: 12px 8px; text-align: left; font-weight: 600; cursor: pointer; user-select: none;"
                  onclick="toggleVipReportSort()">
                  NgÃ y giá» <span id="sortIcon">ğŸ”½</span>
                </th>
                <th style="padding: 12px 8px; text-align: left; font-weight: 600;">Loáº¡i</th>
                <th style="padding: 12px 8px; text-align: left; font-weight: 600;">Ná»™i dung</th>
                <th style="padding: 12px 8px; text-align: right; font-weight: 600;">+/-</th>
                <th style="padding: 12px 8px; text-align: right; font-weight: 600;">Sá»‘ dÆ°</th>
              </tr>
            </thead>
            <tbody id="vipReportTableBody">
              <!-- Will be populated by JS -->
            </tbody>
          </table>
        </div>

        <div id="vipReportEmpty" style="text-align: center; padding: 40px; color: #999;">
          Chá»n VIP member Ä‘á»ƒ xem bÃ¡o cÃ¡o
        </div>
      </div>
    </div>
    <div id="backup" class="tab-content">
      <!-- GitHub Settings -->
      <div class="glass-card">
        <div class="section-title">âš™ï¸ CÃ i Ä‘áº·t GitHub</div>

        <div class="alert alert-info">
          <span>â„¹ï¸</span>
          <div>
            <strong>HÆ°á»›ng dáº«n setup:</strong><br>
            1. Táº¡o GitHub Personal Access Token táº¡i <a href="https://github.com/settings/tokens" target="_blank"
              style="color: #60a5fa;">github.com/settings/tokens</a><br>
            2. Chá»n scope: <code>repo</code> (Full control of private repositories)<br>
            3. Copy token vÃ  paste vÃ o Ã´ bÃªn dÆ°á»›i<br>
            4. Nháº­p tÃªn repository (vÃ­ dá»¥: vuhoanganh/OrderHelper)
          </div>
        </div>

        <div class="form-group">
          <label class="form-label">GitHub Personal Access Token</label>
          <input id="githubToken" class="form-input" type="password" placeholder="ghp_xxxxxxxxxxxx"
            onblur="loadGithubRepos()">
          <div class="helper-text">Token sáº½ Ä‘Æ°á»£c lÆ°u trong localStorage cá»§a trÃ¬nh duyá»‡t</div>
        </div>

        <div class="form-row">
          <div class="form-group">
            <label class="form-label">Repository (owner/repo)</label>
            <select id="githubRepo" class="form-input" onchange="loadGithubBranches()">
              <option value="">-- Select repository --</option>
            </select>
            <div class="helper-text" id="repoLoadingStatus" style="display:none; color: var(--accent-blue);">â³ Loading
              repositories...</div>
          </div>
          <div class="form-group">
            <label class="form-label">Branch</label>
            <select id="githubBranch" class="form-input">
              <option value="master">master</option>
            </select>
            <div class="helper-text" id="branchLoadingStatus" style="display:none; color: var(--accent-blue);">â³ Loading
              branches...</div>
          </div>
        </div>

        <div class="checkbox-wrapper">
          <input id="githubAutoBackupEnabled" type="checkbox">
          <label class="checkbox-label">
            <strong>Báº­t auto-backup</strong><br>
            Tá»± Ä‘á»™ng backup data lÃªn GitHub theo interval Ä‘Ã£ cÃ i Ä‘áº·t
          </label>
        </div>

        <div class="form-group">
          <label class="form-label">Auto-backup Interval (phÃºt)</label>
          <input id="githubBackupInterval" class="form-input" type="number" min="5" step="5" value="30"
            placeholder="30">
          <div class="helper-text">Thá»i gian giá»¯a cÃ¡c láº§n auto-backup (tá»‘i thiá»ƒu 5 phÃºt)</div>
        </div>

        <button class="btn btn-primary btn-full" onclick="saveGithubSettings()">
          ğŸ’¾ LÆ°u cÃ i Ä‘áº·t
        </button>
      </div>

      <!-- Backup Controls -->
      <div class="glass-card">
        <div class="section-title">ğŸ”„ Backup & Restore</div>

        <div id="githubBackupStatus" class="alert alert-info" style="display: none;">
          <span>â„¹ï¸</span>
          <div id="githubBackupStatusText">ChÆ°a cÃ³ backup nÃ o</div>
        </div>

        <div class="summary-grid">
          <div class="summary-item">
            <h3>Láº§n backup cuá»‘i</h3>
            <div class="summary-value" id="lastBackupTime">--</div>
            <div class="summary-detail" id="lastBackupCommit">--</div>
          </div>
          <div class="summary-item">
            <h3>Tráº¡ng thÃ¡i</h3>
            <div class="summary-value" id="backupStatusIndicator">--</div>
            <div class="summary-detail" id="backupStatusDetail">--</div>
          </div>
        </div>

        <div class="btn-group" style="margin-bottom: 20px;">
          <button class="btn btn-primary" onclick="backupToGithub()" style="flex: 1;">
            ğŸ“¤ Backup to GitHub
          </button>
          <button class="btn btn-success" onclick="syncNow()" style="flex: 1;">
            ğŸ”„ Sync Now
          </button>
          <button class="btn btn-success" onclick="downloadBackup()" style="flex: 1;">
            ğŸ’¾ Download Backup
          </button>
          <button class="btn btn-info" onclick="restoreFromFile()" style="flex: 1;">
            ğŸ“¥ Restore from File
          </button>
          <button class="btn btn-secondary" onclick="restoreFromGithub()" style="flex: 1;">
            ğŸ“¥ Restore
          </button>
        </div>

        <div class="helper-text" style="margin-top: 16px;">
          <strong>Data sáº½ backup:</strong> Order History, VIP List, VIP Transactions
        </div>
      </div>



      <!-- Backup Log -->
      <div class="glass-card">
        <div class="section-title">ğŸ“ Backup Log</div>
        <div id="backupLog"
          style="max-height: 300px; overflow-y: auto; font-family: monospace; font-size: 12px; color: var(--text-secondary);">
          ChÆ°a cÃ³ log...
        </div>
      </div>
    </div>

  </div>

  <!-- Reconcile Modal (Moved outside tab content) -->
  <div id="reconcileModal"
    style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); z-index: 9999; align-items: center; justify-content: center;">
    <div class="modal-content"
      style="max-width: 800px; max-height: 90vh; overflow-y: auto; background: var(--bg-card, #1a1a2e); border-radius: 12px; padding: 24px;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="margin: 0; font-size: 24px; color: var(--text-primary, #fff);">ğŸ” Äá»‘i soÃ¡t VIP Balance</h2>
        <button onclick="closeReconcileModal()" class="btn btn-secondary">ÄÃ³ng</button>
      </div>

      <div id="reconcileLoading" style="text-align: center; padding: 20px;">â³ Äang tÃ­nh toÃ¡n...</div>

      <div id="reconcileContent" style="display: none;">
        <div style="margin-bottom: 12px; font-size: 14px; opacity: 0.8;">
          Danh sÃ¡ch cÃ¡c thÃ nh viÃªn cÃ³ sá»± chÃªnh lá»‡ch giá»¯a <b>Sá»‘ dÆ° lÆ°u (VIP List)</b> vÃ  <b>Sá»‘ dÆ° tÃ­nh toÃ¡n
            (Report)</b>.
        </div>
        <table style="width: 100%; border-collapse: collapse;">
          <thead>
            <tr style="background: rgba(255,255,255,0.1); text-align: left;">
              <th style="padding: 10px;">ThÃ nh viÃªn</th>
              <th style="padding: 10px; text-align: right;">VIP List</th>
              <th style="padding: 10px; text-align: right;">Computed</th>
              <th style="padding: 10px; text-align: right;">Lá»‡ch (Diff)</th>
              <th style="padding: 10px; text-align: center;">Orphans</th>
              <th style="padding: 10px;">HÃ nh Ä‘á»™ng</th>
            </tr>
          </thead>
          <tbody id="reconcileTableBody"></tbody>
        </table>
        <div id="reconcileEmpty"
          style="display:none; padding: 20px; text-align: center; color: #4ade80; font-weight: bold;">
          âœ… KhÃ´ng tÃ¬m tháº¥y sá»± chÃªnh lá»‡ch nÃ o! Dá»¯ liá»‡u khá»›p hoÃ n toÃ n.
        </div>
      </div>
    </div>
  </div>

  <!-- Modal for Order Details -->
  <div id="orderModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">Chi tiáº¿t Ä‘Æ¡n hÃ ng</div>
        <button class="modal-close" onclick="closeModal()">Ã—</button>
      </div>
      <div id="modalBody"></div>
    </div>
  </div>

  <!-- Global Modals (Accessible from any tab) -->
  <div id="vipTopupModal" class="modal">
    <div class="modal-content" style="max-width: 400px;">
      <div class="modal-header">
        <h2>â• Náº¡p VIP</h2>
        <button class="modal-close" onclick="closeModal('vipTopupModal')">Ã—</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>TÃªn VIP</label>
          <input type="text" id="vipTopupName" class="form-input" placeholder="Nháº­p tÃªn VIP..." autofocus>
        </div>
        <div class="form-group">
          <label>Sá»‘ tiá»n náº¡p (Ä‘)</label>
          <input type="number" id="vipTopupAmount" class="form-input" placeholder="Nháº­p sá»‘ tiá»n..." min="1">
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" onclick="closeModal('vipTopupModal')">Há»§y</button>
        <button type="button" class="btn btn-primary" onclick="submitVipTopup()">Náº¡p tiá»n</button>
      </div>
    </div>
  </div>

  <div id="vipCashOutModal" class="modal">
    <div class="modal-content" style="max-width: 400px;">
      <div class="modal-header">
        <h2>ğŸ’¸ Cash Out VIP</h2>
        <button class="modal-close" onclick="closeModal('vipCashOutModal')">Ã—</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>Chá»n VIP</label>
          <select id="vipCashOutName" class="form-input" onchange="updateCashOutBalance()">
            <option value="">-- Chá»n VIP --</option>
          </select>
        </div>
        <div class="form-group">
          <label>Sá»‘ dÆ° hiá»‡n táº¡i</label>
          <input type="text" id="vipCashOutCurrentBalance" class="form-input" readonly disabled>
        </div>
        <div class="form-group">
          <label>Sá»‘ tiá»n rÃºt (Ä‘á»ƒ trá»‘ng Ä‘á»ƒ rÃºt háº¿t)</label>
          <input type="number" id="vipCashOutAmount" class="form-input" placeholder="Nháº­p sá»‘ tiá»n..." min="1">
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" onclick="closeModal('vipCashOutModal')">Há»§y</button>
        <button type="button" class="btn btn-warning" onclick="submitVipCashOut()">RÃºt tiá»n</button>
      </div>
    </div>
  </div>

  <div id="draftManagerModal" class="modal">
    <div class="modal-content" style="max-width: 500px;">
      <div class="modal-header">
        <h2 class="modal-title">ğŸ“‚ Quáº£n lÃ½ Ä‘Æ¡n nhÃ¡p</h2>
        <button class="modal-close" onclick="closeModal('draftManagerModal')">Ã—</button>
      </div>
      <div class="modal-body">
        <div id="draftListContainer" class="draft-list-container">
          <!-- Draft items will be injected here -->
        </div>
      </div>
      <div class="modal-footer" style="justify-content: space-between;">
        <button type="button" class="btn btn-ghost" onclick="refreshDraftListFromDisk()">ğŸ”„ QuÃ©t file trÃªn
          mÃ¡y</button>
        <button type="button" class="btn btn-secondary" onclick="closeModal('draftManagerModal')">ÄÃ³ng</button>
      </div>
    </div>
  </div>

  <div id="paymentMethodModal" class="modal">
    <div class="modal-content" style="max-width: 400px;">
      <div class="modal-header">
        <h2 id="paymentModalTitle">Chá»n phÆ°Æ¡ng thá»©c thanh toÃ¡n</h2>
        <button class="modal-close" onclick="closeModal('paymentMethodModal')">Ã—</button>
      </div>
      <div class="modal-body">
        <div id="paymentModalInfo" style="margin-bottom: 16px; font-size: 14px; color: var(--text-secondary);"></div>
        <div class="form-group">
          <label class="form-label">PhÆ°Æ¡ng thá»©c thanh toÃ¡n</label>
          <select id="paymentMethodSelect" class="form-input">
            <option value="cash" selected>Tiá»n máº·t (Cash)</option>
            <option value="vip">VÃ­ VIP</option>
          </select>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" onclick="closeModal('paymentMethodModal')">Há»§y</button>
        <button type="button" class="btn btn-primary" id="paymentModalConfirmBtn">XÃ¡c nháº­n</button>
      </div>
    </div>
  </div>

  <script>
    const VIP_PATCH_ENABLED = false;
    const BUILD_TAG = "vip-fix-v1.1";
    // Global State
    let orderHistory = JSON.parse(localStorage.getItem('orderHistory') || '[]');
    // Keep deterministic history ordering (recommended): oldest â†’ newest by `date`
    if (Array.isArray(orderHistory)) {
      orderHistory.sort((a, b) => (Date.parse(a?.date) || 0) - (Date.parse(b?.date) || 0));
    }
    let selectedPrice = null;
    let activeOrderModalId = null;
    const autoBackupMode = new URLSearchParams(window.location.search).get('autobackup') === 'true';
    const DRAFT_STORAGE_KEY = 'draftOrder';
    const DRAFT_META_KEY = 'draftBackupMeta';
    const DRAFT_DIR = '/Users/alvin/Library/Mobile Documents/com~apple~CloudDocs/Kitchen/drafts';
    const DRAFT_BACKUP_INTERVAL_MS = 30 * 60 * 1000;
    const DRAFT_RETRY_INTERVAL_MS = 5 * 60 * 1000;
    let draftDirty = false;
    let draftBackupIntervalId = null;
    let draftBackupRetryTimeout = null;
    let lastDraftBackupPath = null;
    let debouncedLocalDraftSave;
    let draftBackupInFlight = false;
    let suppressDraftChange = false;
    let lastDebtorPaidSnapshot = null;
    let lastComputedSignature = null;
    let lastSavedSignature = null;
    let lastComputedOrder = null;
    let editingOrderId = null;
    let editingOrderDate = null;
    const VIP_TX_KEY = 'vipTransactions';

    // Transaction IDs confirmed for deletion (duplicates)
    // These transactions will be filtered out during migration/reconciliation
    const CONFIRMED_DELETE_TXN_IDS = [
      "9310deae-d8f0-48c4-8dd0-b8031e44886d" // a Duck topup 1000Ä‘ duplicate on 2025-12-15
    ];

    let vipTransactions = [];
    let vipReportSortDesc = true; // true = newest first (descending), false = oldest first (ascending)


    // GitHub Backup Variables
    let githubAutoBackupInterval = null;
    const GITHUB_TOKEN_KEY = 'github_token';
    const GITHUB_REPO_KEY = 'github_repo';
    const GITHUB_BRANCH_KEY = 'github_branch';
    const GITHUB_BACKUP_FOLDER_KEY = 'github_backup_folder';
    const GITHUB_AUTO_BACKUP_ENABLED_KEY = 'github_auto_backup_enabled';
    const GITHUB_BACKUP_INTERVAL_KEY = 'github_backup_interval';
    const GITHUB_LAST_BACKUP_KEY = 'github_last_backup';
    const GITHUB_LAST_COMMIT_SHA_KEY = 'github_last_commit_sha';

    // Smart Name Matcher Class
    class SmartNameMatcher {
      constructor() {
        this.nameMap = new Map(); // normalized â†’ {original, data}
      }

      normalize(name) {
        if (!name) return '';
        return name
          .trim()
          .toLowerCase()
          .replace(/\s+/g, '')
          .normalize('NFD')
          .replace(/[\u0300-\u036f]/g, '');
      }

      add(name, data) {
        if (!name || !name.trim()) return;

        const normalized = this.normalize(name);
        const trimmedName = name.trim();

        // Check if already exists
        if (this.nameMap.has(normalized)) {
          const existing = this.nameMap.get(normalized);
          // Update data but keep original name if it's more "complete"
          if (trimmedName.length >= existing.original.length) {
            existing.original = trimmedName;
          }
          existing.data = data;
        } else {
          this.nameMap.set(normalized, {
            original: trimmedName,
            data: data
          });
        }
      }

      find(name) {
        const normalized = this.normalize(name);
        return this.nameMap.get(normalized);
      }

      getOriginalName(name) {
        const found = this.find(name);
        return found ? found.original : name.trim();
      }

      getData(name) {
        const found = this.find(name);
        return found ? found.data : null;
      }

      has(name) {
        const normalized = this.normalize(name);
        return this.nameMap.has(normalized);
      }

      getAllEntries() {
        return Array.from(this.nameMap.values()).map(v => ({
          name: v.original,
          data: v.data
        }));
      }

      clear() {
        this.nameMap.clear();
      }

      // Calculate similarity for fuzzy matching
      calculateSimilarity(str1, str2) {
        const longer = str1.length > str2.length ? str1 : str2;
        const shorter = str1.length > str2.length ? str2 : str1;

        if (longer.includes(shorter)) return 1.0;

        let matches = 0;
        for (let char of shorter) {
          if (longer.includes(char)) matches++;
        }
        return matches / longer.length;
      }

      // Find similar names (for suggestions)
      findSimilar(name, threshold = 0.7) {
        const normalized = this.normalize(name);
        const results = [];

        for (let [key, value] of this.nameMap) {
          const similarity = this.calculateSimilarity(normalized, key);
          if (similarity >= threshold && similarity < 1.0) {
            results.push({
              name: value.original,
              similarity: similarity
            });
          }
        }

        return results.sort((a, b) => b.similarity - a.similarity);
      }
    }

    // Utility Functions
    function formatMoney(x) {
      const neg = x < 0;
      const v = Math.round(Math.abs(x) * 100) / 100;
      return (neg ? '-' : '') + (Number.isInteger(v) ? v.toString() : v.toFixed(2)) + 'Ä‘';
    }

    function ceilInt(x) {
      return Math.ceil(x);
    }

    function parseVip(text) {
      const matcher = new SmartNameMatcher();

      text.split(/\n+/).forEach(line => {
        line = line.trim();
        if (!line) return;

        const [name, bal] = line.split('=');
        if (!name) return;

        const v = parseFloat((bal || '0').replace(/[^0-9.\-]/g, ''));
        const balance = isNaN(v) ? 0 : v;

        matcher.add(name, balance);
      });

      // Convert to Map for backward compatibility
      const map = new Map();
      matcher.getAllEntries().forEach(entry => {
        map.set(entry.name, entry.data);
      });

      // Attach matcher for later use
      map._matcher = matcher;

      return map;
    }

    function vipToText(map) {
      return Array.from(map.entries())
        .map(([k, v]) => `${k}=${formatMoney(v)}`)
        .join('\n');
    }

    function persistVipList(text, timestamp = Date.now()) {
      localStorage.setItem('vipList', text);
      localStorage.setItem('vipUpdatedAt', String(timestamp));
    }

    /**
     * Recompute VIP balances from current data to keep VIP management in sync with reports
     * Uses the SAME LOGIC as buildVipStatementFromDB to ensure consistency
     */
    function recomputeVipBalances() {
      console.log(`[${BUILD_TAG}] recomputeVipBalances - Using accurate calculation from buildVipStatementFromDB logic`);

      // Get all unique VIP member names from all sources
      const vipAreaText = document.getElementById('vipArea')?.value || '';
      const vipMapCurrent = parseVip(vipAreaText);
      const allNames = new Set();

      // Names from current VIP list
      for (const name of vipMapCurrent.keys()) {
        allNames.add(name);
      }

      // Names from vipTransactions
      (vipTransactions || []).forEach(tx => {
        const name = (tx.member || tx.name || '').trim();
        if (name) allNames.add(name);
      });

      // Names from orderHistory
      (orderHistory || []).forEach(order => {
        if (!order.details || !Array.isArray(order.details)) return;
        order.details.forEach(detail => {
          const name = (detail.name || '').trim();
          if (name) allNames.add(name);
        });
      });

      if (allNames.size === 0) return;

      const newBalances = new Map();

      // Calculate accurate balance for each member using buildVipStatementFromDB logic
      allNames.forEach(memberName => {
        // Use the same calculation logic as buildVipStatementFromDB
        const statement = buildVipStatementFromDB(memberName, {});
        const balance = statement.summary.ending;

        // Only include members with non-zero balance or who are in the current list
        if (balance !== 0 || vipMapCurrent.has(memberName)) {
          newBalances.set(memberName, balance);
        }
      });

      // Update VIP area and persist
      const vipText = vipToText(newBalances);
      const vipArea = document.getElementById('vipArea');
      if (vipArea) vipArea.value = vipText;
      persistVipList(vipText);

      // Render clickable VIP list
      renderClickableVipList(newBalances);

      console.log(`[${BUILD_TAG}] recomputeVipBalances - Updated ${newBalances.size} VIP members`);
    }

    /**
     * Render clickable VIP list with links to VIP Report
     */
    function renderClickableVipList(vipBalances) {
      const container = document.getElementById('vipListContainer');
      if (!container) return;

      if (vipBalances.size === 0) {
        container.innerHTML = '<div style="color: #94a3b8; font-style: italic;">ChÆ°a cÃ³ VIP member nÃ o</div>';
        return;
      }

      // Sort by name
      const sorted = Array.from(vipBalances.entries()).sort((a, b) => a[0].localeCompare(b[0]));

      const html = sorted.map(([name, balance]) => {
        const balanceColor = balance >= 0 ? '#34d399' : '#f87171';
        const balanceText = balance >= 0 ? `${balance}Ä‘` : `${balance}Ä‘`;

        return `
          <div style="
            padding: 6px 8px;
            margin-bottom: 4px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
          "
          onmouseover="this.style.background='rgba(99, 102, 241, 0.2)'"
          onmouseout="this.style.background='transparent'"
          onclick="selectVipMemberForReport('${name.replace(/'/g, "\\'").replace(/"/g, '&quot;')}')"
          >
            <span style="color: #cbd5e1;">${name}</span>
            <span style="color: ${balanceColor}; font-weight: 600;">${balanceText}</span>
          </div>
        `;
      }).join('');

      container.innerHTML = html;
    }

    /**
     * Select VIP member in report and switch to report tab
     */
    function selectVipMemberForReport(memberName) {
      // Switch to VIP Report tab
      switchTab('vipReportTab');

      // Select member in dropdown
      const select = document.getElementById('vipReportMember');
      if (select) {
        select.value = memberName;
        // Trigger change event to render report
        select.dispatchEvent(new Event('change'));
      }
    }

    /**
     * Update VIP display - helper function
     */
    function updateVipDisplay(vipText) {
      const vipArea = document.getElementById('vipArea');
      if (vipArea) vipArea.value = vipText;
      persistVipList(vipText);

      // Re-render clickable list
      const vipMap = parseVip(vipText);
      renderClickableVipList(vipMap);
    }

    // Update dish name suggestions from order history
    function updateDishNameSuggestions() {
      const datalist = document.getElementById('dishNameHistory');
      if (!datalist) return;

      const seen = new Set();
      const items = [];

      orderHistory.forEach(order => {
        const name = (order?.itemName || '').trim();
        if (!name || seen.has(name)) return;
        seen.add(name);
        const ts = new Date(order?.date || order?.id || 0).getTime() || 0;
        items.push({ name, ts });
      });

      if (items.length === 0) {
        datalist.innerHTML = '';
        return;
      }

      items.sort((a, b) => b.ts - a.ts);
      datalist.innerHTML = items.map(i => `<option value="${i.name.replace(/"/g, '&quot;')}">`).join('');
    }

    // Ensure dish suggestion dropdown can be opened even khi giÃ¡ trá»‹ hiá»‡n táº¡i khÃ´ng khá»›p
    function openDishSuggestions() {
      const input = document.getElementById('itemName');
      const datalist = document.getElementById('dishNameHistory');
      if (!input || !datalist || !datalist.options?.length) return;
      const prev = input.value;
      input.value = ''; // clear Ä‘á»ƒ browser hiá»ƒn thá»‹ toÃ n bá»™ options
      if (typeof input.showPicker === 'function') {
        input.showPicker();
      }
      setTimeout(() => {
        if (document.activeElement === input) {
          input.value = prev;
        }
      }, 100);
    }

    function getLatestVipFromHistory() {
      if (!Array.isArray(orderHistory) || orderHistory.length === 0) return null;

      const latest = orderHistory
        .filter(o => o && Array.isArray(o.vipSnapshot) && o.vipSnapshot.length > 0 && o.date)
        .reduce((best, o) => {
          const t = Date.parse(o.date) || 0;
          const tb = best ? (Date.parse(best.date) || 0) : -1;
          return t > tb ? o : best;
        }, null);

      if (!latest) return null;
      const time = Date.parse(latest.date) || 0;
      return { time, snapshot: latest.vipSnapshot };
    }

    function syncVipListFromLatestSnapshot() {
      const latest = orderHistory
        .filter(o => o && o.vipSnapshot && o.date)
        .reduce((best, o) => (Date.parse(o.date) || 0) > (best ? (Date.parse(best.date) || 0) : -1) ? o : best, null);

      if (!latest) return;

      const vipText = latest.vipSnapshot.map(([n, b]) => `${n}=${b}Ä‘`).join('\n');
      updateVipDisplay(vipText);
    }

    function hydrateVipAreaFromData(options = {}) {
      const vipArea = document.getElementById('vipArea');
      if (!vipArea) return;

      const savedVipText = (localStorage.getItem('vipList') || '').trim();
      const savedUpdatedAt = Number(localStorage.getItem('vipUpdatedAt') || 0);
      const hasSavedTimestamp = Number.isFinite(savedUpdatedAt) && savedUpdatedAt > 0;

      let chosenText = savedVipText;
      let chosenUpdatedAt = hasSavedTimestamp ? savedUpdatedAt : null;

      const latestHistoryVip = getLatestVipFromHistory();
      const shouldUseHistory = latestHistoryVip && (
        options.forceHistory ||
        !chosenText ||
        !hasSavedTimestamp || // náº¿u chÆ°a tá»«ng ghi timestamp thÃ¬ láº¥y dá»¯ liá»‡u má»›i nháº¥t tá»« history
        latestHistoryVip.time > savedUpdatedAt
      );

      if (shouldUseHistory) {
        const map = new Map(latestHistoryVip.snapshot);
        chosenText = vipToText(map);
        chosenUpdatedAt = latestHistoryVip.time;
      }

      if (chosenText) {
        vipArea.value = chosenText;
        persistVipList(chosenText, chosenUpdatedAt || Date.now());
      }
    }

    function formatDate(date) {
      const d = new Date(date);
      return d.toLocaleDateString('vi-VN', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      });
    }

    function debounce(fn, wait) {
      let t;
      return (...args) => {
        clearTimeout(t);
        t = setTimeout(() => fn.apply(null, args), wait);
      };
    }

    // ========== GitHub Backup Functions ==========

    function addBackupLog(message) {
      const logDiv = document.getElementById('backupLog');
      if (!logDiv) return;
      const timestamp = new Date().toLocaleTimeString('vi-VN');
      const line = `[${timestamp}] ${message}`;
      if (logDiv.textContent === 'ChÆ°a cÃ³ log...') {
        logDiv.textContent = line;
      } else {
        logDiv.textContent = line + '\n' + logDiv.textContent;
      }
      // Keep only last 50 lines
      const lines = logDiv.textContent.split('\n');
      if (lines.length > 50) {
        logDiv.textContent = lines.slice(0, 50).join('\n');
      }
    }

    function showBackupStatus(message, type = 'info') {
      const statusDiv = document.getElementById('githubBackupStatus');
      const textDiv = document.getElementById('githubBackupStatusText');
      if (!statusDiv || !textDiv) return;

      textDiv.textContent = message;
      statusDiv.style.display = 'flex';
      statusDiv.className = `alert alert-${type}`;

      // Auto-hide after 5 seconds for success/info messages
      if (type === 'success' || type === 'info') {
        setTimeout(() => {
          statusDiv.style.display = 'none';
        }, 5000);
      }
    }

    async function githubApiRequest(endpoint, method = 'GET', body = null) {
      const token = localStorage.getItem(GITHUB_TOKEN_KEY);
      if (!token) {
        throw new Error('GitHub token khÃ´ng tÃ¬m tháº¥y. Vui lÃ²ng cÃ i Ä‘áº·t token trong tab Backup.');
      }

      const url = `https://api.github.com${endpoint}`;
      const headers = {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/vnd.github.v3+json',
        'Content-Type': 'application/json'
      };

      const options = {
        method,
        headers
      };

      if (body) {
        options.body = JSON.stringify(body);
      }

      const response = await fetch(url, options);

      if (!response.ok) {
        const error = await response.json().catch(() => ({ message: response.statusText }));
        throw new Error(`GitHub API Error: ${error.message || response.statusText}`);
      }

      // Handle 204 No Content
      if (response.status === 204) {
        return null;
      }

      return await response.json();
    }

    async function getGithubFile(owner, repo, path, branch = 'main') {
      try {
        const data = await githubApiRequest(`/repos/${owner}/${repo}/contents/${path}?ref=${branch}`);
        if (data && data.content) {
          // Decode base64 content with UTF-8 support
          const content = decodeURIComponent(escape(atob(data.content.replace(/\n/g, ''))));
          return {
            content,
            sha: data.sha
          };
        }
        return null;
      } catch (err) {
        // File not found is not an error in this case
        if (err.message.includes('Not Found') || err.message.includes('404')) {
          return null;
        }
        throw err;
      }
    }

    async function createOrUpdateGithubFile(owner, repo, path, content, message, sha = null) {
      // Proper UTF-8 to base64 encoding for Vietnamese characters
      const utf8Bytes = new TextEncoder().encode(content);
      const base64 = btoa(String.fromCharCode(...utf8Bytes));

      const body = {
        message,
        content: base64,
        branch: localStorage.getItem(GITHUB_BRANCH_KEY) || 'master'
      };

      if (sha) {
        body.sha = sha; // Required when updating existing file
      }

      return await githubApiRequest(`/repos/${owner}/${repo}/contents/${path}`, 'PUT', body);
    }

    function formatDraftTime(ts) {
      if (!ts) return 'â€”';
      return new Date(ts).toLocaleString('vi-VN', { hour12: false });
    }

    function normalizeVipTransactions(data = []) {
      console.log(`[${BUILD_TAG}] normalizeVipTransactions`);
      if (!VIP_PATCH_ENABLED) {
        return Array.isArray(data) ? data : [];
      }
      if (!Array.isArray(data)) return [];
      const normalized = data.map((tx, idx) => {
        const amount = Number(tx?.amount);
        const idRaw = tx?.id;
        const idNum = typeof idRaw === 'number' ? idRaw : (typeof idRaw === 'string' && idRaw.trim() !== '' ? Number(idRaw) : NaN);
        const parsedIdDate = isFinite(idNum) ? new Date(idNum) : null;
        const hasValidIdDate = parsedIdDate && isFinite(parsedIdDate.getTime());
        const tsSource = tx?.ts || (hasValidIdDate ? parsedIdDate.toISOString() : null);
        const parsedTs = tsSource ? new Date(tsSource) : null;
        const hasValidTs = parsedTs && isFinite(parsedTs.getTime());
        const computedType = tx?.type || (amount >= 0 ? 'topup' : 'cashout');
        const hasDetailIndex = tx && Object.prototype.hasOwnProperty.call(tx, 'detailIndex');

        const out = {
          id: (tx?.id !== undefined && tx?.id !== null && String(tx.id).trim() !== '') ? String(tx.id) : crypto.randomUUID(),
          ts: hasValidTs ? parsedTs.toISOString() : (hasValidIdDate ? parsedIdDate.toISOString() : new Date().toISOString()),
          name: (tx?.name || '').trim(),
          amount: isFinite(amount) ? amount : 0,
          type: computedType,
          detailIndex: hasDetailIndex ? tx.detailIndex : null
        };

        if (tx && Object.prototype.hasOwnProperty.call(tx, 'orderId')) out.orderId = tx.orderId;
        if (tx && Object.prototype.hasOwnProperty.call(tx, 'itemName')) out.itemName = tx.itemName;
        if (tx && Object.prototype.hasOwnProperty.call(tx, 'paid')) out.paid = tx.paid;
        if (tx && Object.prototype.hasOwnProperty.call(tx, 'isVipPayment')) out.isVipPayment = tx.isVipPayment;
        if (tx && Object.prototype.hasOwnProperty.call(tx, 'paymentMethod')) out.paymentMethod = tx.paymentMethod;

        // Migration rules (KHÃ”NG SUY DIá»„N)
        if (out.type === 'order') {
          if (out.isVipPayment == null) out.isVipPayment = true;
          if (out.paymentMethod == null) out.paymentMethod = 'vip';
          if (out.paid == null) out.paid = true;
        }

        return out;
      }).filter(tx => tx.name);

      localStorage.setItem(VIP_TX_KEY, JSON.stringify(normalized.slice(0, 200)));
      return normalized;
    }

    function buildOrderSignature(data = {}) {
      const normalizedDetails = Array.isArray(data.details) ? data.details.map(d => ({
        name: d.name,
        qty: d.qty,
        shipQty: d.shipQty || d.shipParts || 0,
        paid: d.paid === true,
        due: Number(d.due || 0),
        unitPrice: d.unitPrice
      })) : [];

      return JSON.stringify({
        itemName: data.itemName || '',
        totalParts: data.totalParts || 0,
        alvinFree: !!data.alvinFree,
        totalCostInput: Number(data.totalCostInput || 0),
        costPerUnitInput: Number(data.costPerUnitInput || 0),
        shipFee: Number(data.shipFee || 0),
        targetProfit: Number(data.targetProfit || 0),
        priceNonShip: Number(data.priceNonShip || 0),
        priceShip: Number(data.priceShip || data.priceNonShip || 0),
        splitShipMode: !!data.splitShipMode,
        details: normalizedDetails
      });
    }

    function recordVipTransaction({ name, amount, type, itemName, orderId, detailIndex, isVipPayment, paymentMethod, ts }) {
      console.log(`[${BUILD_TAG}] recordVipTransaction`);
      if (!name || !Number.isFinite(amount)) return;

      const txType = type || (amount >= 0 ? 'topup' : 'cashout');
      const entry = {
        id: crypto.randomUUID(),
        ts: (typeof ts === 'string' && ts) ? ts : new Date().toISOString(),
        name: name.trim(),
        amount,
        type: txType
      };

      if (txType === 'order') {
        // VIP tx in vipTransactions is VIP by definition
        if (orderId === undefined || orderId === null) return;
        if (itemName === undefined || itemName === null) return;
        if (detailIndex === undefined || detailIndex === null) return;
        entry.orderId = orderId;
        entry.itemName = itemName;
        entry.detailIndex = detailIndex;
        entry.isVipPayment = true;
        entry.paid = true;
        entry.paymentMethod = 'vip';
      } else {
        if (paymentMethod !== undefined) entry.paymentMethod = paymentMethod;
        if (isVipPayment !== undefined) entry.isVipPayment = isVipPayment;
      }

      vipTransactions.unshift(entry);
      vipTransactions = vipTransactions.slice(0, 200);
      localStorage.setItem(VIP_TX_KEY, JSON.stringify(vipTransactions));
      renderVipHistory();
      populateVipMemberSelect();
    }

    /**
     * Ensure Order Transactions from Orders
     * Ensures every VIP-paid detail has a corresponding order transaction in vipTransactions
     * 
     * @param {Array} orders - Array of order objects (orderHistory)
     * @param {Array} vipTransactions - Array of VIP transaction objects
     * @returns {Object} { vipTransactions: updated, stats }
     */
    function ensureOrderTxFromOrders(orders, vipTransactions) {
      console.log(`[${BUILD_TAG}] ensureOrderTxFromOrders - Ensuring order transactions...`);

      const stats = {
        totalOrders: 0,
        totalVipDetails: 0,
        created: 0,
        updated: 0,
        skipped: 0
      };

      // Helper to normalize name for ID generation
      const normalizeNameKey = (name) => {
        return (name || '').replace(/[^a-zA-Z0-9]/g, '');
      };

      // Create map by refId for fast lookup (only order transactions with refId)
      const mapByRefId = new Map();
      vipTransactions.forEach((tx, index) => {
        if (tx.type === 'order' && tx.refId) {
          mapByRefId.set(tx.refId, { tx, index });
        }
      });

      console.log(`[EnsureOrderTx] Found ${mapByRefId.size} existing order txs with refId`);

      // Array to collect new transactions
      const newTransactions = [];

      // Process each order
      orders.forEach(order => {
        stats.totalOrders++;
        const details = order.details || [];

        details.forEach((detail, detailIndex) => {
          // Check VIP payment condition
          const isVipPaid = detail.paid === true && detail.paymentMethod === 'vip';

          if (!isVipPaid) return;

          stats.totalVipDetails++;

          // Validate due amount
          const dueAmount = Number(detail.due);
          if (!Number.isFinite(dueAmount)) {
            console.warn(`[EnsureOrderTx] Invalid due amount for ${detail.name} in order ${order.id}[${detailIndex}]:`, detail.due);
            stats.skipped++;
            return;
          }

          const expectedAmount = -dueAmount;
          const refId = `${order.id}-${detailIndex}`;
          const existing = mapByRefId.get(refId);

          if (existing) {
            // Transaction exists - check and update if needed
            const tx = existing.tx;
            let updated = false;

            if (tx.amount !== expectedAmount) {
              console.warn(`[EnsureOrderTx] Updating amount for ${refId}: ${tx.amount} => ${expectedAmount}`);
              tx.amount = expectedAmount;
              updated = true;
            }

            // Normalize other fields
            if (tx.name !== detail.name) {
              tx.name = detail.name;
              updated = true;
            }

            if (updated) {
              stats.updated++;
            }
          } else {
            // Transaction doesn't exist - create it
            const newTx = {
              id: `order:${refId}:${normalizeNameKey(detail.name)}`,
              ts: (order.date && typeof order.date === 'string')
                ? order.date
                : new Date(order.id || Date.now()).toISOString(),
              name: detail.name.trim(),
              amount: expectedAmount,
              type: 'order',
              orderId: order.id,
              itemName: order.itemName || '',
              detailIndex: detailIndex,
              refId: refId,
              paid: true,
              paymentMethod: 'vip',
              isVipPayment: true
            };

            newTransactions.push(newTx);
            mapByRefId.set(refId, { tx: newTx, index: -1 }); // -1 indicates new
            stats.created++;
          }
        });
      });

      // Merge new transactions into vipTransactions
      let result = vipTransactions;
      if (newTransactions.length > 0) {
        result = [...newTransactions, ...vipTransactions];
        console.log(`[EnsureOrderTx] Added ${newTransactions.length} new order transactions`);
      }

      console.log(`[EnsureOrderTx] Complete:`, stats);

      return {
        vipTransactions: result,
        stats: stats
      };
    }

    /**
     * Deduplicate Legacy Order Transactions
     * Removes legacy order transactions (without refId) that duplicate canonical ones (with refId)
     * 
     * @param {Array} vipTransactions - Array of VIP transaction objects
     * @returns {Object} { vipTransactions: filtered, removedCount, legacyRemaining }
     */
    function dedupeLegacyOrders(vipTransactions) {
      console.log(`[${BUILD_TAG}] dedupeLegacyOrders - Starting deduplication...`);

      let removedCount = 0;
      const TIME_THRESHOLD_MS = 5000; // 5 seconds

      // Separate canonical and legacy transactions
      const canonical = [];
      const legacy = [];
      const other = [];

      vipTransactions.forEach(tx => {
        if (tx.type === 'order') {
          if (tx.refId) {
            canonical.push(tx);
          } else {
            legacy.push(tx);
          }
        } else {
          other.push(tx);
        }
      });

      console.log(`[Dedupe] Found ${canonical.length} canonical, ${legacy.length} legacy order txs`);

      // Filter out legacy transactions that match canonical ones
      const filteredLegacy = legacy.filter(legacyTx => {
        // Look for matching canonical transaction
        const matchingCanonical = canonical.find(canonicalTx => {
          // Must match: member (name), amount
          if (canonicalTx.name !== legacyTx.name) return false;
          if (canonicalTx.amount !== legacyTx.amount) return false;

          // Check time difference (within 5 seconds)
          const canonicalDate = new Date(canonicalTx.ts || canonicalTx.date || 0);
          const legacyDate = new Date(legacyTx.ts || legacyTx.date || 0);
          const timeDiff = Math.abs(canonicalDate - legacyDate);

          return timeDiff <= TIME_THRESHOLD_MS;
        });

        if (matchingCanonical) {
          console.log(`[Dedupe] Removing legacy tx: ${legacyTx.name} ${legacyTx.amount}Ä‘ (${legacyTx.ts})`);
          removedCount++;
          return false; // Filter out
        }

        return true; // Keep
      });

      // Combine: canonical + filtered legacy + other
      const result = [...canonical, ...filteredLegacy, ...other];

      console.log(`[Dedupe] Removed ${removedCount} legacy duplicates, ${filteredLegacy.length} legacy remaining`);

      return {
        vipTransactions: result,
        removedCount: removedCount,
        legacyRemaining: filteredLegacy.length
      };
    }

    /**
     * Reconcile VIP Ledger from Order History
     * Ensures every VIP payment in orderHistory has a corresponding vipTransaction
     * 
     * @param {Array} orderHistory - Array of order objects
     * @param {Array} vipTransactions - Array of VIP transaction objects
     * @returns {Object} { vipTransactions: newList, changed: boolean, stats }
     */
    function reconcileVipLedgerFromOrders(orderHistory, vipTransactions) {
      console.log(`[${BUILD_TAG}] reconcileVipLedgerFromOrders - Starting reconciliation...`);

      const stats = {
        totalOrders: 0,
        totalVipDetails: 0,
        created: 0,
        updated: 0,
        deduped: 0,
        skipped: 0,
        normalized: 0,
        legacyRemoved: 0
      };

      // Create a map for fast lookups: key = orderId|name|detailIndex|order
      const txMap = new Map();
      const txIndexMap = new Map(); // Maps key to array of indices (for dedup)

      // Index existing vipTransactions
      vipTransactions.forEach((tx, index) => {
        if (tx.type === 'order' && tx.orderId !== undefined && tx.orderId !== null) {
          const key = `${tx.orderId}|${tx.name}|${tx.detailIndex}|order`;
          if (!txIndexMap.has(key)) {
            txIndexMap.set(key, []);
          }
          txIndexMap.get(key).push(index);

          // Keep the first one in the main map
          if (!txMap.has(key)) {
            txMap.set(key, tx);
          }
        }
      });

      // Deduplicate existing vipTransactions
      const duplicateIndices = new Set();
      for (const [key, indices] of txIndexMap.entries()) {
        if (indices.length > 1) {
          console.warn(`[Reconcile] Found ${indices.length} duplicates for key: ${key}`);
          // Keep the first one, mark others for removal
          for (let i = 1; i < indices.length; i++) {
            duplicateIndices.add(indices[i]);
            stats.deduped++;
          }
        }
      }

      // Remove duplicates
      let newVipTxs = vipTransactions.filter((tx, index) => !duplicateIndices.has(index));

      // Rebuild maps after dedup
      txMap.clear();
      newVipTxs.forEach(tx => {
        if (tx.type === 'order' && tx.orderId !== undefined && tx.orderId !== null) {
          const key = `${tx.orderId}|${tx.name}|${tx.detailIndex}|order`;
          txMap.set(key, tx);
        }
      });

      // Array to collect new transactions
      const newTransactions = [];

      // Process each order
      orderHistory.forEach(order => {
        stats.totalOrders++;
        const details = order.details || [];

        details.forEach((detail, detailIndex) => {
          // Check if this is a VIP payment
          const isVipPayment = detail.paid === true && (
            detail.paymentMethod === 'vip' ||
            detail.payMethod === 'vip' ||
            detail.isVipPayment === true
          );

          if (!isVipPayment) return;

          stats.totalVipDetails++;

          // NORMALIZE DETAIL OBJECT
          // Rule: If VIP payment (any indicator) + paid=true
          // => Must have paymentMethod='vip' and NO contradictions

          let needsNormalization = false;

          // Set paymentMethod to 'vip' if not already
          if (detail.paymentMethod !== 'vip') {
            detail.paymentMethod = 'vip';
            needsNormalization = true;
          }

          // Remove legacy isVipPayment field (no longer needed, redundant with paymentMethod)
          if (detail.isVipPayment !== undefined) {
            delete detail.isVipPayment;
            needsNormalization = true;
          }

          // Remove legacy payMethod field
          if (detail.payMethod !== undefined && detail.payMethod !== null) {
            detail.payMethod = null; // Or delete detail.payMethod
            needsNormalization = true;
          }

          // Ensure paid status
          if (detail.paid !== true) {
            detail.paid = true; // Should already be true based on filter, but enforce
            needsNormalization = true;
          }

          if (needsNormalization) {
            stats.normalized++;
          }

          // Validate due amount
          if (!Number.isFinite(detail.due)) {
            console.warn(`[Reconcile] Invalid due amount for ${detail.name} in order ${order.id}:`, detail.due);
            stats.skipped++;
            return;
          }

          const key = `${order.id}|${detail.name}|${detailIndex}|order`;
          const existingTx = txMap.get(key);

          if (existingTx) {
            // Transaction exists - check if amount matches
            const expectedAmount = -detail.due;
            if (existingTx.amount !== expectedAmount) {
              console.warn(`[Reconcile] Amount mismatch for ${key}: ${existingTx.amount} vs ${expectedAmount}`);
              existingTx.amount = expectedAmount;
              stats.updated++;
            }

            // Ensure required fields are set
            if (!existingTx.paymentMethod) {
              existingTx.paymentMethod = 'vip';
              stats.updated++;
            }
            if (!existingTx.isVipPayment) {
              existingTx.isVipPayment = true;
              stats.updated++;
            }
            if (existingTx.paid !== true) {
              existingTx.paid = true;
              stats.updated++;
            }
            // Ensure canonical tx has refId
            if (!existingTx.refId) {
              existingTx.refId = `${order.id}-${detailIndex}`;
              stats.updated++;
            }
          } else {
            // Transaction doesn't exist - create it (CANONICAL with refId)
            const ts = (order.date && typeof order.date === 'string')
              ? order.date
              : new Date(order.id || Date.now()).toISOString();

            const newTx = {
              id: `order:${order.id}:${detailIndex}:${detail.name.replace(/[^a-zA-Z0-9]/g, '')}`,
              refId: `${order.id}-${detailIndex}`, // CANONICAL MARKER
              ts: ts,
              name: detail.name.trim(),
              amount: -detail.due,
              type: 'order',
              orderId: order.id,
              itemName: order.itemName || 'Order',
              detailIndex: detailIndex,
              paid: true,
              paymentMethod: 'vip',
              isVipPayment: true
            };

            newTransactions.push(newTx);
            txMap.set(key, newTx);
            stats.created++;
          }
        });
      });

      // Merge new transactions with existing ones
      if (newTransactions.length > 0) {
        newVipTxs = [...newTransactions, ...newVipTxs];
      }

      // ENSURE ALL VIP-PAID DETAILS HAVE ORDER TRANSACTIONS
      const ensureResult = ensureOrderTxFromOrders(orderHistory, newVipTxs);
      newVipTxs = ensureResult.vipTransactions;
      if (ensureResult.stats.created > 0 || ensureResult.stats.updated > 0) {
        stats.created += ensureResult.stats.created;
        stats.updated += ensureResult.stats.updated;
      }

      // DEDUPE LEGACY ORDERS
      const dedupeResult = dedupeLegacyOrders(newVipTxs);
      newVipTxs = dedupeResult.vipTransactions;
      stats.legacyRemoved = dedupeResult.removedCount;

      // Sort by timestamp (newest first)
      newVipTxs.sort((a, b) => {
        const dateA = new Date(a.ts || 0);
        const dateB = new Date(b.ts || 0);
        return dateB - dateA;
      });

      const changed = stats.created > 0 || stats.updated > 0 || stats.deduped > 0 || stats.normalized > 0 || stats.legacyRemoved > 0;

      console.log(`[${BUILD_TAG}] Reconciliation complete:`, stats);

      return {
        vipTransactions: newVipTxs,
        changed: changed,
        stats: stats
      };
    }

    function renderVipHistory() {
      const container = document.getElementById('vipHistory');
      if (!container) return;

      if (!vipTransactions.length) {
        container.innerHTML = '<div class="empty-state" style="padding:12px 0;">ChÆ°a cÃ³ giao dá»‹ch VIP</div>';
        return;
      }

      const html = `
    <ul class="mini-list">
      ${vipTransactions.slice(0, 20).map(tx => `
        <li>
          <div>
	            <div><strong>${tx.name}</strong> â€¢ ${tx.type === 'order' ? 'Order' : (tx.type === 'cashout' ? 'RÃºt' : 'Náº¡p')}</div>
            <div class="note">${formatDate(tx.ts)}</div>
          </div>
          <div class="${tx.amount >= 0 ? 'amount-positive' : 'amount-negative'}">
            ${tx.amount >= 0 ? '+' : ''}${formatMoney(tx.amount)}
          </div>
        </li>
      `).join('')}
    </ul>
  `;
      container.innerHTML = html;
    }

    // Extract order transactions for a specific VIP member
    function getVipOrderTransactions(vipName) {
      const orderTxs = [];
      const normalizedVipName = vipName.trim().toLowerCase();

      console.log('=== DEBUG getVipOrderTransactions ===');
      console.log('Looking for VIP:', vipName, '(normalized:', normalizedVipName + ')');
      console.log('Total orders in history:', orderHistory.length);

      orderHistory.forEach((order, idx) => {
        // Debug first order structure
        if (idx === 0) {
          console.log('First order structure:', {
            id: order.id,
            ts: order.ts,
            itemName: order.itemName,
            hasDetails: !!order.details,
            detailsIsArray: Array.isArray(order.details),
            detailsLength: order.details?.length
          });
        }

        if (!order.details || !Array.isArray(order.details)) {
          if (idx < 3) console.log(`Order ${idx}: No details array`);
          return;
        }

        const timestamp = order.date || order.id;
        if (!timestamp) return;

        order.details.forEach((detail, detailIdx) => {
          const detailName = (detail.name || '').trim();
          const normalizedDetailName = detailName.toLowerCase();

          // Debug: log all detail names to see what we have
          if (idx < 3) {
            console.log(`Order ${idx}, Detail ${detailIdx}: name="${detailName}", due=${detail.due}, paid=${detail.paid}`);
          }

          if (normalizedDetailName === normalizedVipName && detail.due) {
            const date = new Date(timestamp);
            if (isNaN(date.getTime())) return;

            console.log('âœ… MATCH FOUND:', detailName, 'due:', detail.due);

            const isVipPayment = detail.isVipPayment === true || detail.paymentMethod === 'vip';
            orderTxs.push({
              id: (order.id ? String(order.id) : '') + '_' + detailName + '_' + detailIdx,
              ts: date.toISOString(),
              name: vipName,
              amount: -Math.abs(detail.due),
              type: 'order',
              itemName: order.itemName || 'Order',
              paid: detail.paid === true,
              orderId: order.id,
              detailIndex: detailIdx,
              isVipPayment,
              paymentMethod: isVipPayment ? 'vip' : (detail.paymentMethod !== undefined ? detail.paymentMethod : undefined)
            });
          }
        });
      });

      console.log('Total order transactions found:', orderTxs.length);
      console.log('=== END DEBUG ===');

      return orderTxs;
    }

    // Get icon for transaction type
    function getTransactionIcon(type) {
      switch (type) {
        case 'topup': return 'ğŸ’°';
        case 'cashout': return 'ğŸ’¸';
        case 'order': return 'ğŸœ';
        default: return 'ğŸ“';
      }
    }

    // Get label for transaction
    function getTransactionLabel(tx) {
      switch (tx.type) {
        case 'topup': return 'Náº¡p tiá»n';
        case 'cashout': return 'RÃºt tiá»n';
        case 'order': return 'Order mÃ³n Äƒn';
        default: return 'Giao dá»‹ch';
      }
    }

    // VIP Member Transaction History Functions
    function populateVipMemberSelect() {
      const select = document.getElementById('vipMemberSelect');
      if (!select) return;

      // Get unique VIP names from transactions
      const vipNames = new Set();
      vipTransactions.forEach(tx => {
        if (tx.name) vipNames.add(tx.name);
      });

      // Also add VIP names from current VIP list
      const vipArea = document.getElementById('vipArea');
      if (vipArea) {
        const vipMap = parseVip(vipArea.value);
        vipMap.forEach((_, name) => vipNames.add(name));
      }

      // Sort and populate
      const sortedNames = Array.from(vipNames).sort();
      select.innerHTML = '<option value="">-- Chá»n VIP --</option>' +
        sortedNames.map(name => `<option value="${name}">${name}</option>`).join('');
    }
    // Store all transactions globally for filtering
    let currentVipTransactions = [];

    // VIP History Functions
    const DEFAULT_INITIAL_BALANCE = {
      'a Duck': 145,
      'a Dave': 1000
    };

    function saveInitialBalance() {
      const vipName = document.getElementById('vipMemberSelect').value;
      const balance = document.getElementById('vipInitialBalance').value;

      if (!vipName) return;

      // Save to localStorage
      const key = `vipInitialBalance_${vipName}`;
      localStorage.setItem(key, balance || '0');

      // Recalculate history
      showVipMemberHistory();
    }

    function getInitialBalanceForVip(name, options = {}) {
      if (!name) return 0;
      const saved = localStorage.getItem(`vipInitialBalance_${name}`);
      if (saved !== null && saved !== undefined && saved !== '') {
        return Number(saved);
      }
      const def = DEFAULT_INITIAL_BALANCE[name];
      if (options.persistDefault && def !== undefined) {
        localStorage.setItem(`vipInitialBalance_${name}`, def);
      }
      return def || 0;
    }

    function showVipMemberHistory() {
      console.log('[VIP-HISTORY-UNIFIED] Using buildVipStatementRows (Table View)');
      const select = document.getElementById('vipMemberSelect');
      const container = document.getElementById('vipMemberHistoryContainer');
      const filtersDiv = document.getElementById('vipHistoryFilters');
      if (!select || !container) return;

      const selectedName = select.value;
      if (!selectedName) {
        container.innerHTML = '';
        if (filtersDiv) filtersDiv.style.display = 'none';
        return;
      }

      // Show filters
      if (filtersDiv) filtersDiv.style.display = 'block';

      // Render Initial Balance input (View Only / Manual Override)
      const initialBalanceInput = document.getElementById('vipInitialBalance');
      if (initialBalanceInput) {
        const saved = localStorage.getItem(`vipInitialBalance_${selectedName}`);
        if (saved) {
          initialBalanceInput.value = saved;
        } else {
          initialBalanceInput.value = '';
          initialBalanceInput.placeholder = 'AUTO';
        }
      }

      // Use UNIFIED Builder
      const { rows } = buildVipStatementRows(selectedName);

      // Filter for UI (Newest First)
      const historyRows = [...rows].reverse();

      if (historyRows.length === 0) {
        container.innerHTML = '<div class="empty-state" style="padding: 12px 0;">ChÆ°a cÃ³ giao dá»‹ch nÃ o</div>';
        return;
      }

      // Helper for formatting
      const getIcon = (label) => {
        if (label === 'Náº¡p') return 'ğŸ’°';
        if (label === 'RÃºt') return 'ğŸ’¸';
        if (label === 'Trá»« Ä‘Æ¡n') return 'ğŸœ';
        if (label === 'Opening') return 'ğŸ';
        return 'ğŸ“';
      };

      // TABLE HEADER matching the style of other tables
      // Current Balance Display
      const currentBalance = historyRows.length > 0 ? historyRows[0].balanceAfter : 0;
      const balanceColor = currentBalance >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';

      let html = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; padding: 16px; background: rgba(255,255,255,0.03); border-radius: 12px; border: 1px solid rgba(255,255,255,0.08);">
          <div>
            <div style="font-size: 13px; color: var(--text-muted); margin-bottom: 4px; text-transform: uppercase;">Sá»‘ dÆ° hiá»‡n táº¡i</div>
            <div style="font-size: 24px; font-weight: 700; color: ${balanceColor}; letter-spacing: -0.5px;">
              ${formatMoney(currentBalance)}
            </div>
          </div>
          <div style="text-align: right;">
             <div style="font-size: 13px; color: var(--text-muted); margin-bottom: 4px;">KhÃ¡ch hÃ ng</div>
             <div style="font-size: 16px; font-weight: 600; color: var(--text-primary);">${selectedName}</div>
          </div>
        </div>

        <div style="overflow-x:auto;">
          <table style="width:100%; border-collapse: collapse; font-size: 14px;">
            <thead>
              <tr style="border-bottom: 1px solid rgba(255,255,255,0.1); text-align: left;">
                <th style="padding: 12px; color: var(--text-secondary);">Thá»i gian</th>
                <th style="padding: 12px; color: var(--text-secondary);">Loáº¡i</th>
                <th style="padding: 12px; color: var(--text-secondary);">Ná»™i dung</th>
                <th style="padding: 12px; text-align: right; color: var(--text-secondary);">Sá»‘ tiá»n</th>
                <th style="padding: 12px; text-align: right; color: var(--text-secondary);">Sá»‘ dÆ°</th>
              </tr>
            </thead>
            <tbody>
      `;

      html += historyRows.map(row => {
        const amountClass = row.delta >= 0 ? 'amount-positive' : 'amount-negative';
        const sign = row.delta > 0 ? '+' : '';
        const icon = getIcon(row.typeLabel);
        // Bg color for rows if needed, or transparent
        const bgColor = 'transparent';

        return `
            <tr style="border-bottom: 1px solid rgba(255,255,255,0.05); transition: background 0.2s;" 
                onmouseover="this.style.background='rgba(255,255,255,0.05)'" 
                onmouseout="this.style.background='transparent'">
              <td style="padding: 12px; white-space: nowrap;">${row.dateLocal}</td>
              <td style="padding: 12px; white-space: nowrap;">
                  <span style="display:inline-block; width:24px;">${icon}</span> ${row.typeLabel}
              </td>
              <td style="padding: 12px;">${row.description} <div style="font-size:11px; color:#666;">${row.ref || ''}</div></td>
              <td style="padding: 12px; text-align: right; font-weight: 600;" class="${amountClass}">
                ${sign}${formatMoney(row.delta)}
              </td>
              <td style="padding: 12px; text-align: right; font-weight: 600;">
                ${formatMoney(row.balanceAfter)}
              </td>
            </tr>
        `;
      }).join('');

      html += `
            </tbody>
          </table>
        </div>
      `;

      container.innerHTML = html;
    }


    function renderVipHistoryTable(selectedName, currentBalance, transactions) {
      const container = document.getElementById('vipMemberHistoryContainer');
      if (!container) return;

      // Count transaction types
      const topupCount = transactions.filter(tx => tx.type === 'topup').length;
      const cashoutCount = transactions.filter(tx => tx.type === 'cashout').length;
      const orderCount = transactions.filter(tx => tx.type === 'order').length;

      // Compact date format function
      const compactDate = (dateStr) => {
        const d = new Date(dateStr);
        const day = String(d.getDate()).padStart(2, '0');
        const month = String(d.getMonth() + 1).padStart(2, '0');
        const year = d.getFullYear();
        const hours = String(d.getHours()).padStart(2, '0');
        const minutes = String(d.getMinutes()).padStart(2, '0');
        return `${day}/${month}/${year} ${hours}:${minutes}`;
      };

      // Render compact table
      const html = `
        <div style="margin-top: 16px;">
          <!-- Header with summary -->
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; padding: 12px 16px; background: linear-gradient(135deg, rgba(99,102,241,0.1), rgba(168,85,247,0.1)); border-radius: 12px; border: 1px solid rgba(99,102,241,0.2);">
            <div>
              <div style="font-size: 14px; color: var(--text-muted); margin-bottom: 2px;">VIP Member</div>
              <div style="font-size: 18px; font-weight: 600; color: var(--text-primary);">${selectedName}</div>
            </div>
            <div style="text-align: right;">
              <div style="font-size: 14px; color: var(--text-muted); margin-bottom: 2px;">Sá»‘ dÆ° hiá»‡n táº¡i</div>
              <div style="font-size: 22px; font-weight: 700; color: ${currentBalance >= 0 ? 'var(--accent-green)' : 'var(--accent-red)'};">
                ${formatMoney(currentBalance)}
              </div>
            </div>
          </div>

          <!-- Transaction table -->
          <div style="border-radius: 12px; overflow: hidden; border: 1px solid rgba(255,255,255,0.08);">
            <div style="max-height: 60vh; overflow-y: auto; overflow-x: auto; background: var(--glass-bg);">
              <table style="width: 100%; min-width: 700px; border-collapse: collapse; font-size: 13px;">
                <thead style="position: sticky; top: 0; background: rgba(30,30,50,0.95); backdrop-filter: blur(10px); z-index: 1;">
                  <tr>
                    <th style="padding: 10px 12px; text-align: left; font-weight: 600; color: var(--text-muted); border-bottom: 2px solid rgba(255,255,255,0.1); white-space: nowrap;">ğŸ“… NgÃ y giá»</th>
                    <th style="padding: 10px 12px; text-align: left; font-weight: 600; color: var(--text-muted); border-bottom: 2px solid rgba(255,255,255,0.1); white-space: nowrap;">Loáº¡i</th>
                    <th style="padding: 10px 12px; text-align: center; font-weight: 600; color: var(--text-muted); border-bottom: 2px solid rgba(255,255,255,0.1); white-space: nowrap;">ğŸ’³ PT</th>
                    <th style="padding: 10px 12px; text-align: right; font-weight: 600; color: var(--text-muted); border-bottom: 2px solid rgba(255,255,255,0.1); white-space: nowrap;">Sá»‘ tiá»n</th>
                    <th style="padding: 10px 12px; text-align: left; font-weight: 600; color: var(--text-muted); border-bottom: 2px solid rgba(255,255,255,0.1);">Chi tiáº¿t</th>
                    <th style="padding: 10px 12px; text-align: right; font-weight: 600; color: var(--text-muted); border-bottom: 2px solid rgba(255,255,255,0.1); white-space: nowrap;">Sá»‘ dÆ°</th>
                  </tr>
                </thead>
                <tbody>
                  ${transactions.map((tx, idx) => {
        const isEven = idx % 2 === 0;
        const bgColor = isEven ? 'rgba(255,255,255,0.02)' : 'transparent';
        const typeLabel = tx.type === 'topup' ? 'ğŸ’° Náº¡p' : tx.type === 'cashout' ? 'ğŸ’¸ RÃºt' : 'ğŸœ Order';

        // PT column (render-only; no inference "paid => VIP"):
        // - Order: VIP if isVipPayment===true or paymentMethod==='vip'
        //          Cash if paid===true and not VIP
        //          Unpaid if paid!==true
        // - Topup/Cashout: '-'
        let paymentMethod = '-';
        if (tx.type === 'order') {
          const isVip = tx.isVipPayment === true || tx.paymentMethod === 'vip';
          const isPaid = tx.paid === true;
          if (isVip) {
            paymentMethod = '<span style="background: linear-gradient(135deg, #10b981, #34d399); color: white; padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 600;">VIP</span>';
          } else if (isPaid) {
            paymentMethod = '<span style="background: rgba(255,255,255,0.12); color: var(--text-primary); padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 600;">Cash</span>';
          } else {
            paymentMethod = '<span style="background: rgba(239,68,68,0.18); color: #fecaca; padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 600;">Unpaid</span>';
          }
        }

        const amountColor = tx.amount >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';
        const balanceColor = tx.balance >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';

        return `
                      <tr style="background: ${bgColor}; transition: background 0.2s;" onmouseover="this.style.background='rgba(99,102,241,0.08)'" onmouseout="this.style.background='${bgColor}'">
                        <td style="padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,0.05); color: var(--text-secondary); white-space: nowrap;">${compactDate(tx.ts)}</td>
                        <td style="padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,0.05); white-space: nowrap;">${typeLabel}</td>
                        <td style="padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,0.05); text-align: center; white-space: nowrap;">${paymentMethod}</td>
                        <td style="padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,0.05); text-align: right; font-weight: 600; color: ${amountColor}; white-space: nowrap;">
                          ${tx.amount >= 0 ? '+' : ''}${formatMoney(tx.amount)}
                        </td>
                        <td style="padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,0.05); color: var(--text-secondary);">
	                          ${tx.type === 'order' ? `${tx.itemName || 'Order'} ${tx.paid === true ? 'âœ…' : 'â³'}` : '-'}
                        </td>
                        <td style="padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,0.05); text-align: right; font-weight: 600; color: ${balanceColor}; white-space: nowrap;">
                          ${formatMoney(tx.balance)}
                        </td>
                      </tr>
                    `;
      }).join('')}
                </tbody>
              </table>
            </div>
          </div>

          <!-- Summary footer -->
          <div style="margin-top: 12px; padding: 12px 16px; background: rgba(255,255,255,0.03); border-radius: 12px; border: 1px solid rgba(255,255,255,0.08);">
            <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 8px;">
              <div style="font-size: 13px; color: var(--text-muted);">
                <strong style="color: var(--text-primary);">Tá»•ng: ${transactions.length}</strong> giao dá»‹ch
              </div>
              <div style="font-size: 13px; color: var(--text-muted); display: flex; gap: 16px;">
                <span>ğŸ’° Náº¡p: <strong style="color: var(--accent-green);">${topupCount}</strong></span>
                <span>ğŸ’¸ RÃºt: <strong style="color: var(--accent-yellow);">${cashoutCount}</strong></span>
                <span>ğŸœ Order: <strong style="color: var(--accent-blue);">${orderCount}</strong></span>
              </div>
            </div>
          </div>
        </div>
      `;

      container.innerHTML = html;
    }

    // Apply filters to VIP history
    function applyVipHistoryFilters() {
      if (currentVipTransactions.length === 0) return;

      const select = document.getElementById('vipMemberSelect');
      const vipArea = document.getElementById('vipArea');
      const selectedName = select ? select.value : '';
      const vipMap = vipArea ? parseVip(vipArea.value) : new Map();
      const currentBalance = Number(vipMap.get(selectedName) || 0);
      const initialBalanceRaw = String(document.getElementById('vipInitialBalance')?.value || '').trim();
      const hasManualStartBalance = initialBalanceRaw !== '';
      const manualStartBalance = hasManualStartBalance ? Number(initialBalanceRaw) : 0;

      // Get filter values
      const dateFrom = document.getElementById('filterDateFrom')?.value;
      const dateTo = document.getElementById('filterDateTo')?.value;
      const txType = document.getElementById('filterTxType')?.value || 'all';
      const paymentStatus = document.getElementById('filterPaymentStatus')?.value || 'all';

      // Apply filters
      let filtered = [...currentVipTransactions];

      // Date range filter
      if (dateFrom) {
        const fromDate = new Date(dateFrom);
        fromDate.setHours(0, 0, 0, 0);
        filtered = filtered.filter(tx => new Date(tx.ts) >= fromDate);
      }
      if (dateTo) {
        const toDate = new Date(dateTo);
        toDate.setHours(23, 59, 59, 999);
        filtered = filtered.filter(tx => new Date(tx.ts) <= toDate);
      }

      // Transaction type filter
      if (txType !== 'all') {
        filtered = filtered.filter(tx => tx.type === txType);
      }

      // Payment status filter (only for orders)
      if (paymentStatus !== 'all') {
        filtered = filtered.filter(tx => {
          if (tx.type !== 'order') return true; // Keep non-order transactions
          return paymentStatus === 'paid' ? tx.paid : !tx.paid;
        });
      }

      // Update result count
      const countSpan = document.getElementById('filterResultCount');
      if (countSpan) {
        countSpan.textContent = `Hiá»ƒn thá»‹ ${filtered.length}/${currentVipTransactions.length} giao dá»‹ch`;
      }

      const hasActiveFilter =
        !!dateFrom ||
        !!dateTo ||
        txType !== 'all' ||
        paymentStatus !== 'all';

      // Recalculate running balance for filtered list (chronological)
      // - Manual start: use it
      // - AUTO start (only when no active filters): end at vipList currentBalance
      // - Filtered view + no manual start: do not force matching vipList, start at 0
      const sortedOldestFirst = [...filtered].sort((a, b) => new Date(a.ts) - new Date(b.ts));
      const sumDeltaFiltered = sortedOldestFirst.reduce((sum, tx) => {
        const isVipOrder = tx.type === 'order' && (tx.isVipPayment === true || tx.paymentMethod === 'vip');
        const impacts = tx.type === 'topup' || tx.type === 'cashout' || isVipOrder;
        const delta = impacts ? Number(tx.amount || 0) : 0;
        return sum + delta;
      }, 0);

      let runningBalance = 0;
      if (hasManualStartBalance) runningBalance = manualStartBalance;
      else if (!hasActiveFilter) runningBalance = currentBalance - sumDeltaFiltered;
      else runningBalance = 0;

      const recalculated = sortedOldestFirst.map(tx => {
        const isVipOrder = tx.type === 'order' && (tx.isVipPayment === true || tx.paymentMethod === 'vip');
        const impacts = tx.type === 'topup' || tx.type === 'cashout' || isVipOrder;
        const delta = impacts ? Number(tx.amount || 0) : 0;
        runningBalance += delta;
        return { ...tx, balance: runningBalance };
      });

      // Render filtered results (use final runningBalance for header)
      renderVipHistoryTable(selectedName, currentBalance, recalculated);
    }

    // Clear all filters
    function clearVipHistoryFilters() {
      document.getElementById('filterDateFrom').value = '';
      document.getElementById('filterDateTo').value = '';
      document.getElementById('filterTxType').value = 'all';
      document.getElementById('filterPaymentStatus').value = 'all';

      const countSpan = document.getElementById('filterResultCount');
      if (countSpan) countSpan.textContent = '';

      // Re-render with all transactions
      const select = document.getElementById('vipMemberSelect');
      const vipArea = document.getElementById('vipArea');
      const selectedName = select ? select.value : '';
      const currentBalance = vipArea ? (parseVip(vipArea.value).get(selectedName) || 0) : 0;

      renderVipHistoryTable(selectedName, currentBalance, currentVipTransactions);
    }

    // Export VIP history to CSV
    function exportVipHistoryToCSV() {
      const select = document.getElementById('vipMemberSelect');
      if (!select || !select.value) {
        alert('âš ï¸ Vui lÃ²ng chá»n VIP member trÆ°á»›c khi xuáº¥t CSV');
        return;
      }

      const selectedName = select.value;

      // Get currently displayed transactions (respecting filters)
      const vipArea = document.getElementById('vipArea');
      const currentBalance = vipArea ? (parseVip(vipArea.value).get(selectedName) || 0) : 0;

      // Get filter values to determine which transactions to export
      const dateFrom = document.getElementById('filterDateFrom')?.value;
      const dateTo = document.getElementById('filterDateTo')?.value;
      const txType = document.getElementById('filterTxType')?.value || 'all';
      const paymentStatus = document.getElementById('filterPaymentStatus')?.value || 'all';

      // Apply same filters as display
      let transactions = [...currentVipTransactions];

      if (dateFrom) {
        const fromDate = new Date(dateFrom);
        fromDate.setHours(0, 0, 0, 0);
        transactions = transactions.filter(tx => new Date(tx.ts) >= fromDate);
      }
      if (dateTo) {
        const toDate = new Date(dateTo);
        toDate.setHours(23, 59, 59, 999);
        transactions = transactions.filter(tx => new Date(tx.ts) <= toDate);
      }
      if (txType !== 'all') {
        transactions = transactions.filter(tx => tx.type === txType);
      }
      if (paymentStatus !== 'all') {
        transactions = transactions.filter(tx => {
          if (tx.type !== 'order') return true;
          return paymentStatus === 'paid' ? tx.paid : !tx.paid;
        });
      }

      if (transactions.length === 0) {
        alert('âš ï¸ KhÃ´ng cÃ³ giao dá»‹ch nÃ o Ä‘á»ƒ xuáº¥t');
        return;
      }

      // Format date for CSV
      const formatDateCSV = (dateStr) => {
        const d = new Date(dateStr);
        const day = String(d.getDate()).padStart(2, '0');
        const month = String(d.getMonth() + 1).padStart(2, '0');
        const year = d.getFullYear();
        const hours = String(d.getHours()).padStart(2, '0');
        const minutes = String(d.getMinutes()).padStart(2, '0');
        return `${day}/${month}/${year} ${hours}:${minutes}`;
      };

      // Get transaction type label
      const getTypeLabel = (type) => {
        if (type === 'topup') return 'Náº¡p tiá»n';
        if (type === 'cashout') return 'RÃºt tiá»n';
        if (type === 'order') return 'Order';
        return 'Giao dá»‹ch';
      };

      // Format amount for CSV (remove 'Ä‘' suffix)
      const formatAmountCSV = (amount) => {
        return amount.toFixed(0);
      };

      // Build CSV content
      let csv = [];

      // Add UTF-8 BOM for Excel compatibility with Vietnamese characters
      csv.push('\uFEFF');

      // Add header info
      csv.push(`VIP Member: ${selectedName}\n`);
      csv.push(`Sá»‘ dÆ° hiá»‡n táº¡i: ${formatAmountCSV(currentBalance)}Ä‘\n`);
      csv.push(`NgÃ y xuáº¥t: ${formatDateCSV(new Date().toISOString())}\n`);
      csv.push(`Tá»•ng sá»‘ giao dá»‹ch: ${transactions.length}\n`);
      csv.push('\n');

      // Add table header
      csv.push('NgÃ y giá»,Loáº¡i,Sá»‘ tiá»n (Ä‘),Chi tiáº¿t,Sá»‘ dÆ° (Ä‘)\n');

      // Add transaction rows
      transactions.forEach(tx => {
        const date = formatDateCSV(tx.ts);
        const type = getTypeLabel(tx.type);
        const amount = formatAmountCSV(tx.amount);
        const detail = tx.type === 'order'
          ? `${tx.itemName} ${tx.paid === true ? '[ÄÃ£ tráº£]' : '[ChÆ°a tráº£]'}`
          : '-';
        const balance = formatAmountCSV(tx.balance);

        // Escape commas and quotes in detail field
        const escapedDetail = detail.replace(/"/g, '""');
        const detailField = detail.includes(',') ? `"${escapedDetail}"` : detail;

        csv.push(`${date},${type},${amount},${detailField},${balance}\n`);
      });

      // Add summary footer
      csv.push('\n');
      const topupCount = transactions.filter(tx => tx.type === 'topup').length;
      const cashoutCount = transactions.filter(tx => tx.type === 'cashout').length;
      const orderCount = transactions.filter(tx => tx.type === 'order').length;
      csv.push(`Tá»•ng há»£p:,Náº¡p: ${topupCount} láº§n,RÃºt: ${cashoutCount} láº§n,Order: ${orderCount} láº§n,\n`);

      // Create blob and download
      const csvContent = csv.join('');
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');

      // Generate filename with date
      const now = new Date();
      const dateStr = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}`;
      const filename = `vip_transactions_${selectedName.replace(/\s+/g, '_')}_${dateStr}.csv`;

      link.href = URL.createObjectURL(blob);
      link.download = filename;
      link.style.display = 'none';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);

      // Show success message
      const filterCount = document.getElementById('filterResultCount');
      if (filterCount) {
        const originalText = filterCount.textContent;
        filterCount.innerHTML = `<span style="color: var(--accent-green);">âœ… ÄÃ£ xuáº¥t ${transactions.length} giao dá»‹ch</span>`;
        setTimeout(() => {
          filterCount.textContent = originalText;
        }, 3000);
      }
    }

    // ========== Global Search Functions ==========

    let searchTimeout = null;

    function handleGlobalSearch(query) {
      const resultsContainer = document.getElementById('searchResults');
      const clearBtn = document.querySelector('.search-clear');

      // Show/hide clear button
      clearBtn.style.display = query ? 'block' : 'none';

      if (!query || query.trim().length < 2) {
        resultsContainer.classList.remove('show');
        return;
      }

      // Debounce search
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(() => {
        const results = searchAllData(query.trim());
        renderSearchResults(results);
      }, 200);
    }

    function searchAllData(query) {
      const lowerQuery = query.toLowerCase();
      const results = {
        vips: [],
        orders: [],
        items: []
      };

      // Search VIPs
      const vipArea = document.getElementById('vipArea');
      if (vipArea) {
        const vipMap = parseVip(vipArea.value);
        vipMap.forEach((balance, name) => {
          if (name.toLowerCase().includes(lowerQuery)) {
            results.vips.push({ name, balance });
          }
        });
      }

      // Search Orders
      orderHistory.forEach(order => {
        const itemMatch = order.itemName && order.itemName.toLowerCase().includes(lowerQuery);
        const dateStr = formatDate(order.date || order.id);
        const dateMatch = dateStr.toLowerCase().includes(lowerQuery);

        // Search in order details (VIP names)
        let detailMatch = false;
        if (order.details && Array.isArray(order.details)) {
          detailMatch = order.details.some(d =>
            d.name && d.name.toLowerCase().includes(lowerQuery)
          );
        }

        if (itemMatch || dateMatch || detailMatch) {
          results.orders.push(order);
        }
      });

      // Search unique item names
      const itemCounts = new Map();
      orderHistory.forEach(order => {
        if (order.itemName) {
          const itemLower = order.itemName.toLowerCase();
          if (itemLower.includes(lowerQuery)) {
            itemCounts.set(order.itemName, (itemCounts.get(order.itemName) || 0) + 1);
          }
        }
      });

      itemCounts.forEach((count, item) => {
        results.items.push({ name: item, count });
      });

      // Limit results
      results.vips = results.vips.slice(0, 5);
      results.orders = results.orders.slice(0, 5);
      results.items = results.items.slice(0, 5);

      return results;
    }

    function renderSearchResults(results) {
      const container = document.getElementById('searchResults');
      const hasResults = results.vips.length > 0 || results.orders.length > 0 || results.items.length > 0;

      if (!hasResults) {
        container.innerHTML = '<div class="search-no-results">âŒ KhÃ´ng tÃ¬m tháº¥y káº¿t quáº£</div>';
        container.classList.add('show');
        return;
      }

      let html = '';

      // VIP Results
      if (results.vips.length > 0) {
        html += '<div class="search-result-section">';
        html += '<div class="search-section-title">ğŸ‘¥ VIP Members</div>';
        results.vips.forEach(vip => {
          const balanceClass = vip.balance >= 0 ? 'positive' : 'negative';
          html += `
            <div class="search-result-item" onclick="goToVip('${vip.name}')">
              <span class="search-result-icon">ğŸ‘¤</span>
              <div class="search-result-content">
                <div class="search-result-title">${vip.name}</div>
                <div class="search-result-subtitle">
                  <span class="balance-badge ${balanceClass}">${formatMoney(vip.balance)}</span>
                </div>
              </div>
            </div>
          `;
        });
        html += '</div>';
      }

      // Order Results
      if (results.orders.length > 0) {
        html += '<div class="search-result-section">';
        html += '<div class="search-section-title">ğŸ“‹ Orders</div>';
        results.orders.forEach(order => {
          const dateStr = formatDate(order.date || order.id);
          html += `
            <div class="search-result-item" onclick="goToOrder(${order.id})">
              <span class="search-result-icon">ğŸœ</span>
              <div class="search-result-content">
                <div class="search-result-title">${order.itemName}</div>
                <div class="search-result-subtitle">${dateStr}</div>
              </div>
            </div>
          `;
        });
        html += '</div>';
      }

      // Item Results
      if (results.items.length > 0) {
        html += '<div class="search-result-section">';
        html += '<div class="search-section-title">ğŸ½ï¸ Items</div>';
        results.items.forEach(item => {
          html += `
            <div class="search-result-item" onclick="searchOrdersByItem('${item.name}')">
              <span class="search-result-icon">ğŸ”</span>
              <div class="search-result-content">
                <div class="search-result-title">${item.name}</div>
                <div class="search-result-subtitle">
                  <span class="count-badge">${item.count} Ä‘Æ¡n</span>
                </div>
              </div>
            </div>
          `;
        });
        html += '</div>';
      }

      container.innerHTML = html;
      container.classList.add('show');
    }

    function clearGlobalSearch() {
      document.getElementById('globalSearch').value = '';
      document.getElementById('searchResults').classList.remove('show');
      document.querySelector('.search-clear').style.display = 'none';
    }

    function goToVip(vipName) {
      clearGlobalSearch();
      switchTab(null, 'debt');

      // Select VIP in dropdown
      setTimeout(() => {
        const select = document.getElementById('vipMemberSelect');
        if (select) {
          select.value = vipName;
          showVipMemberHistory();
          select.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
      }, 100);
    }

    function goToOrder(orderId) {
      clearGlobalSearch();
      switchTab(null, 'history');

      // Highlight and scroll to order
      setTimeout(() => {
        viewOrderDetails(orderId);
      }, 100);
    }

    function searchOrdersByItem(itemName) {
      clearGlobalSearch();
      switchTab(null, 'history');

      // TODO: Could add filter functionality here
      console.log('Search orders for item:', itemName);
    }

    // Keyboard shortcut: Ctrl+K to focus search
    document.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
        e.preventDefault();
        document.getElementById('globalSearch').focus();
      }

      // ESC to close search results
      if (e.key === 'Escape') {
        clearGlobalSearch();
      }
    });

    // ========== GitHub Settings & Main Functions ==========

    /**
     * Load user's GitHub repositories and populate dropdown
     */
    async function loadGithubRepos() {
      const token = document.getElementById('githubToken').value.trim();
      const repoSelect = document.getElementById('githubRepo');
      const statusDiv = document.getElementById('repoLoadingStatus');

      if (!token) {
        // No token, reset dropdown
        repoSelect.innerHTML = '<option value="">-- Nháº­p token trÆ°á»›c --</option>';
        return;
      }

      try {
        statusDiv.style.display = 'block';
        statusDiv.textContent = 'â³ Loading repositories...';

        // Temporarily save token to localStorage for API call
        // (it will be saved permanently when user clicks "LÆ°u cÃ i Ä‘áº·t")
        localStorage.setItem(GITHUB_TOKEN_KEY, token);

        // Fetch user's repos
        const repos = await githubApiRequest('/user/repos?per_page=100&sort=updated');

        if (!repos || repos.length === 0) {
          repoSelect.innerHTML = '<option value="">-- No repositories found --</option>';
          statusDiv.textContent = 'â„¹ï¸ No repositories found';
          return;
        }

        // Populate dropdown with repos
        repoSelect.innerHTML = '<option value="">-- Select repository --</option>';

        repos.forEach(repo => {
          const option = document.createElement('option');
          option.value = repo.full_name; // e.g., "vuhoanganh/OrderHelper"
          option.textContent = `${repo.full_name} ${repo.private ? 'ğŸ”’' : ''}`;
          repoSelect.appendChild(option);
        });

        // Auto-select if only one repo or if OrderHelper exists
        const orderHelperRepo = repos.find(r => r.name.toLowerCase().includes('orderhelper'));
        if (orderHelperRepo) {
          repoSelect.value = orderHelperRepo.full_name;
        } else if (repos.length === 1) {
          repoSelect.value = repos[0].full_name;
        }

        statusDiv.textContent = `âœ… Loaded ${repos.length} repositories`;
        setTimeout(() => { statusDiv.style.display = 'none'; }, 3000);

      } catch (err) {
        console.error('Load repos error:', err);
        repoSelect.innerHTML = '<option value="">-- Error loading repos --</option>';
        statusDiv.textContent = `âŒ ${err.message}`;
        statusDiv.style.color = 'var(--accent-red)';
      }
    }

    /**
     * Load branches for selected repository
     */
    async function loadGithubBranches() {
      const repo = document.getElementById('githubRepo').value.trim();
      const branchSelect = document.getElementById('githubBranch');
      const statusDiv = document.getElementById('branchLoadingStatus');

      if (!repo) {
        // No repo selected, reset to default
        branchSelect.innerHTML = '<option value="main">main</option>';
        return;
      }

      try {
        statusDiv.style.display = 'block';
        statusDiv.textContent = 'â³ Loading branches...';

        const [owner, repoName] = repo.split('/');

        // Fetch repo branches
        const branches = await githubApiRequest(`/repos/${owner}/${repoName}/branches`);

        if (!branches || branches.length === 0) {
          branchSelect.innerHTML = '<option value="main">main</option>';
          statusDiv.textContent = 'â„¹ï¸ No branches found, using default: main';
          setTimeout(() => { statusDiv.style.display = 'none'; }, 3000);
          return;
        }

        // Populate dropdown with branches
        branchSelect.innerHTML = '';

        branches.forEach(branch => {
          const option = document.createElement('option');
          option.value = branch.name;
          option.textContent = branch.name;
          branchSelect.appendChild(option);
        });

        // Auto-select main or master if exists
        const mainBranch = branches.find(b => b.name === 'main');
        const masterBranch = branches.find(b => b.name === 'master');

        if (mainBranch) {
          branchSelect.value = 'main';
        } else if (masterBranch) {
          branchSelect.value = 'master';
        } else {
          // Select first branch
          branchSelect.value = branches[0].name;
        }

        statusDiv.textContent = `âœ… Loaded ${branches.length} branches`;
        setTimeout(() => { statusDiv.style.display = 'none'; }, 2000);

      } catch (err) {
        console.error('Load branches error:', err);
        branchSelect.innerHTML = '<option value="main">main</option>';
        statusDiv.textContent = `âŒ ${err.message}`;
        statusDiv.style.color = 'var(--accent-red)';
        setTimeout(() => {
          statusDiv.style.display = 'none';
          statusDiv.style.color = 'var(--accent-blue)';
        }, 5000);
      }
    }

    function saveGithubSettings() {
      const token = document.getElementById('githubToken').value.trim();
      const repo = document.getElementById('githubRepo').value.trim();
      const branch = document.getElementById('githubBranch').value.trim();
      const autoBackupEnabled = document.getElementById('githubAutoBackupEnabled').checked;
      const interval = parseInt(document.getElementById('githubBackupInterval').value) || 30;

      if (!token || !repo) {
        alert('âš ï¸ Vui lÃ²ng nháº­p GitHub Token vÃ  Repository!');
        return;
      }

      // Validate repo format
      if (!repo.includes('/')) {
        alert('âš ï¸ Repository pháº£i cÃ³ format: owner/repo (vÃ­ dá»¥: vuhoanganh/OrderHelper)');
        return;
      }

      // Save to localStorage
      localStorage.setItem(GITHUB_TOKEN_KEY, token);
      localStorage.setItem(GITHUB_REPO_KEY, repo);
      localStorage.setItem(GITHUB_BRANCH_KEY, branch || 'main');
      localStorage.setItem(GITHUB_AUTO_BACKUP_ENABLED_KEY, autoBackupEnabled);
      localStorage.setItem(GITHUB_BACKUP_INTERVAL_KEY, interval);

      addBackupLog('âœ… ÄÃ£ lÆ°u cÃ i Ä‘áº·t GitHub');
      showBackupStatus('âœ… ÄÃ£ lÆ°u cÃ i Ä‘áº·t thÃ nh cÃ´ng!', 'success');

      // Restart auto-backup if enabled
      if (autoBackupEnabled) {
        initGithubAutoBackup();
        addBackupLog(`ğŸ”„ ÄÃ£ báº­t auto-backup (má»—i ${interval} phÃºt)`);
      } else {
        if (githubAutoBackupInterval) {
          clearInterval(githubAutoBackupInterval);
          githubAutoBackupInterval = null;
          addBackupLog('â¸ï¸ ÄÃ£ táº¯t auto-backup');
        }
      }

      alert('âœ… ÄÃ£ lÆ°u cÃ i Ä‘áº·t GitHub!');
    }

    function loadGithubSettings() {
      const token = localStorage.getItem(GITHUB_TOKEN_KEY) || '';
      const repo = localStorage.getItem(GITHUB_REPO_KEY) || '';
      const branch = localStorage.getItem(GITHUB_BRANCH_KEY) || 'master';
      const autoBackupEnabled = localStorage.getItem(GITHUB_AUTO_BACKUP_ENABLED_KEY) === 'true';
      const interval = parseInt(localStorage.getItem(GITHUB_BACKUP_INTERVAL_KEY)) || 30;

      document.getElementById('githubToken').value = token;
      document.getElementById('githubRepo').value = repo;
      document.getElementById('githubBranch').value = branch;
      document.getElementById('githubAutoBackupEnabled').checked = autoBackupEnabled;
      document.getElementById('githubBackupInterval').value = interval;

      // Update last backup display
      updateBackupStatusDisplay();

      // Start auto-backup if enabled
      if (autoBackupEnabled && token && repo) {
        initGithubAutoBackup();
      }
    }

    function updateBackupStatusDisplay() {
      const lastBackupTime = localStorage.getItem(GITHUB_LAST_BACKUP_KEY);
      const lastCommitSha = localStorage.getItem(GITHUB_LAST_COMMIT_SHA_KEY);

      const timeElem = document.getElementById('lastBackupTime');
      const commitElem = document.getElementById('lastBackupCommit');
      const statusElem = document.getElementById('backupStatusIndicator');
      const detailElem = document.getElementById('backupStatusDetail');

      if (timeElem) {
        if (lastBackupTime) {
          const date = new Date(parseInt(lastBackupTime));
          timeElem.textContent = formatDate(date);
        } else {
          timeElem.textContent = 'ChÆ°a backup';
        }
      }

      if (commitElem) {
        if (lastCommitSha) {
          commitElem.textContent = `Commit: ${lastCommitSha.substring(0, 7)}`;
        } else {
          commitElem.textContent = '--';
        }
      }

      if (statusElem && detailElem) {
        const autoBackupEnabled = localStorage.getItem(GITHUB_AUTO_BACKUP_ENABLED_KEY) === 'true';
        if (autoBackupEnabled) {
          statusElem.textContent = 'ğŸŸ¢ Active';
          const interval = parseInt(localStorage.getItem(GITHUB_BACKUP_INTERVAL_KEY)) || 30;
          detailElem.textContent = `Auto-backup: ${interval} phÃºt`;
        } else {
          statusElem.textContent = 'âšª Inactive';
          detailElem.textContent = 'Auto-backup táº¯t';
        }
      }
    }

    function downloadBackup() {
      try {
        addBackupLog('ğŸ“¥ Starting local backup download...');
        // Collect all data from localStorage
        const backup = {
          version: "1.0",
          timestamp: new Date().toISOString(),
          backupTime: Date.now(),
          data: {
            orderHistory: JSON.parse(localStorage.getItem('orderHistory') || '[]'),
            vipTransactions: JSON.parse(localStorage.getItem('vipTransactions') || '[]'),
            vipList: localStorage.getItem('vipList') || ''
          },
          metadata: {
            orderCount: JSON.parse(localStorage.getItem('orderHistory') || '[]').length,
            transactionCount: JSON.parse(localStorage.getItem('vipTransactions') || '[]').length,
            exportedBy: 'Order Helper Pro',
            exportDate: new Date().toLocaleString('vi-VN', { timeZone: 'Asia/Ho_Chi_Minh' })
          }
        };

        addBackupLog(`ğŸ“Š Data: ${backup.metadata.orderCount} orders, ${backup.metadata.transactionCount} transactions`);

        // Check first item encoding
        if (backup.data.orderHistory.length > 0) {
          const firstItem = backup.data.orderHistory[0].itemName;
          addBackupLog(`ğŸ”¤ First item: ${firstItem}`);
          addBackupLog(`ğŸ” Encoding check: ${firstItem.charCodeAt(0)} ${firstItem.charCodeAt(1)} ${firstItem.charCodeAt(2)}`);
        }

        // Create blob and download
        const blob = new Blob([JSON.stringify(backup, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        const now = new Date();
        const datePart = now.toLocaleDateString('en-GB').replace(/\//g, '-');
        const timePart = now.toLocaleTimeString('en-GB', { hour12: false }).replace(/:/g, '');
        a.href = url;
        a.download = `backup-${datePart}-${timePart}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        addBackupLog(`âœ… Downloaded: backup-${datePart}-${timePart}.json`);

        // Also download draft file if exists
        const draft = localStorage.getItem(DRAFT_STORAGE_KEY);
        if (draft) {
          // Use confirm() to ensure user interaction (required for Chromium browsers like Cá»‘c Cá»‘c)
          setTimeout(() => {
            if (confirm('âœ… File backup Ä‘Ã£ táº£i xong!\n\nğŸ“ Báº¥m OK Ä‘á»ƒ táº£i file draft.json')) {
              const draftBlob = new Blob([draft], { type: 'application/json' });
              const draftUrl = URL.createObjectURL(draftBlob);
              const draftLink = document.createElement('a');
              draftLink.href = draftUrl;
              draftLink.download = 'draft.json';
              document.body.appendChild(draftLink);
              draftLink.click();
              document.body.removeChild(draftLink);
              URL.revokeObjectURL(draftUrl);
              addBackupLog('âœ… Downloaded: draft.json');
            }
          }, 300);
        } else {
          alert('âœ… ÄÃ£ táº£i xuá»‘ng file backup!');
        }

      } catch (err) {
        alert('âŒ Lá»—i khi táº¡o backup: ' + err.message);
        console.error(err);
      }
    }

    function restoreFromFile() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';

      input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        try {
          addBackupLog(`ğŸ“‚ Restoring from: ${file.name}`);
          const text = await file.text();
          const data = JSON.parse(text);

          // Detect file type: draft.json or backup.json
          const isDraftFile = data.draftOrder && !data.data;

          if (isDraftFile) {
            // This is a draft.json file
            addBackupLog('ğŸ“„ Detected: Draft file');

            const draftData = data;
            const lastModified = draftData.draftOrder?.lastModified || 0;
            const modifiedDate = lastModified ? new Date(lastModified).toLocaleString('vi-VN') : 'KhÃ´ng rÃµ';

            const confirmMsg = `Restore Ä‘Æ¡n nhÃ¡p tá»«:\n${file.name}\n\nÄÆ¡n: ${draftData.draftOrder?.itemName || '(trá»‘ng)'}\nSá»‘ ngÆ°á»i: ${(draftData.draftOrder?.people || []).length}\nSá»­a láº§n cuá»‘i: ${modifiedDate}\n\nâš ï¸ ÄÆ¡n nhÃ¡p hiá»‡n táº¡i sáº½ bá»‹ ghi Ä‘Ã¨!`;
            if (!confirm(confirmMsg)) return;

            localStorage.setItem(DRAFT_STORAGE_KEY, JSON.stringify(draftData));
            addBackupLog('âœ… Restored draft order');

            // Apply draft to UI immediately
            if (typeof restoreDraftToUI === 'function') {
              restoreDraftToUI(draftData);
            }

            alert('âœ… ÄÃ£ restore Ä‘Æ¡n nhÃ¡p thÃ nh cÃ´ng!');
            // setTimeout(() => location.reload(), 500); // Reloading is no longer strictly necessary if UI is updated
            return;
          }

          // This is a backup.json file
          const backup = data;

          // Check encoding of restored data
          if (backup.data?.orderHistory?.length > 0) {
            const firstItem = backup.data.orderHistory[0].itemName;
            addBackupLog(`ğŸ”¤ File first item: ${firstItem}`);
            addBackupLog(`ğŸ” Bytes: ${firstItem.split('').map(c => c.charCodeAt(0)).slice(0, 5).join(', ')}`);
          }

          if (!backup.data || !backup.data.orderHistory || !backup.data.vipTransactions || !backup.data.vipList) {
            alert('âŒ File backup khÃ´ng há»£p lá»‡!');
            return;
          }

          const confirmMsg = `Restore tá»«:\n${file.name}\n\n${backup.data.orderHistory.length} orders\n${backup.data.vipTransactions.length} transactions\n\nâš ï¸ Dá»¯ liá»‡u hiá»‡n táº¡i sáº½ bá»‹ ghi Ä‘Ã¨!`;
          if (!confirm(confirmMsg)) return;

          localStorage.setItem('orderHistory', JSON.stringify(backup.data.orderHistory));

          // Filter out confirmed duplicate transactions before saving
          let cleanedVipTx = backup.data.vipTransactions.filter(tx => !CONFIRMED_DELETE_TXN_IDS.includes(tx.id));
          const removedFromBackup = backup.data.vipTransactions.length - cleanedVipTx.length;
          if (removedFromBackup > 0) {
            addBackupLog(`ğŸ—‘ï¸ Removed ${removedFromBackup} duplicate transaction(s) from backup`);
          }

          localStorage.setItem('vipTransactions', JSON.stringify(cleanedVipTx));
          localStorage.setItem('vipList', backup.data.vipList);

          addBackupLog(`âœ… Restored: ${backup.data.orderHistory.length} orders, ${backup.data.vipTransactions.length} transactions`);

          // Verify localStorage encoding
          const restored = JSON.parse(localStorage.getItem('orderHistory'));
          if (restored.length > 0) {
            addBackupLog(`ğŸ”¤ localStorage first item: ${restored[0].itemName}`);
          }

          alert('âœ… Restore thÃ nh cÃ´ng!');
          setTimeout(() => location.reload(), 1000);
        } catch (err) {
          alert('âŒ Lá»—i: ' + err.message);
        }
      };

      input.click();
    }

    async function backupToGithub() {
      try {
        addBackupLog('ğŸš€ Báº¯t Ä‘áº§u backup...');
        showBackupStatus('â³ Äang backup lÃªn GitHub...', 'info');

        const repo = localStorage.getItem(GITHUB_REPO_KEY);
        const branch = localStorage.getItem(GITHUB_BRANCH_KEY) || 'master';

        if (!repo) {
          throw new Error('ChÆ°a cÃ i Ä‘áº·t repository');
        }

        const [owner, repoName] = repo.split('/');
        if (!owner || !repoName) {
          throw new Error('Repository format khÃ´ng há»£p lá»‡');
        }

        const timestamp = new Date().toISOString();
        const now = new Date();

        // Generate filename like: backup-13-12-2025-190912.json
        const day = String(now.getDate()).padStart(2, '0');
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const year = now.getFullYear();
        const hours = String(now.getHours()).padStart(2, '0');
        const minutes = String(now.getMinutes()).padStart(2, '0');
        const seconds = String(now.getSeconds()).padStart(2, '0');
        const versionedFilename = `backup-${day}-${month}-${year}-${hours}${minutes}${seconds}.json`;

        // Prepare combined backup data
        const backupData = {
          version: '1.0',
          timestamp,
          backupTime: Date.now(),
          data: {
            orderHistory: orderHistory,
            vipList: localStorage.getItem('vipList') || '',
            vipTransactions: vipTransactions
          },
          metadata: {
            orderCount: orderHistory.length,
            transactionCount: vipTransactions.length,
            exportedBy: 'Order Helper Pro',
            exportDate: `${hours}:${minutes}:${seconds} ${day}/${month}/${year}`
          }
        };

        const backupJSON = JSON.stringify(backupData, null, 2);

        // 1. Upload latest file (for sync)
        addBackupLog('ğŸ“¤ Uploading kitchen_backup.json (latest)...');
        const latestFile = await getGithubFile(owner, repoName, 'kitchen_backup.json', branch);
        await createOrUpdateGithubFile(
          owner,
          repoName,
          'kitchen_backup.json',
          backupJSON,
          `Backup data - ${timestamp}`,
          latestFile?.sha
        );
        addBackupLog('âœ… Latest file uploaded');

        // 2. Upload versioned file (for history)
        addBackupLog(`ğŸ“¤ Uploading DB/${versionedFilename} (history)...`);
        const versionedPath = `DB/${versionedFilename}`;
        const versionedFile = await getGithubFile(owner, repoName, versionedPath, branch);
        const result = await createOrUpdateGithubFile(
          owner,
          repoName,
          versionedPath,
          backupJSON,
          `Versioned backup - ${timestamp}`,
          versionedFile?.sha
        );
        addBackupLog('âœ… Versioned file uploaded');

        // Save backup info
        localStorage.setItem(GITHUB_LAST_BACKUP_KEY, Date.now());
        if (result?.commit?.sha) {
          localStorage.setItem(GITHUB_LAST_COMMIT_SHA_KEY, result.commit.sha);
        }

        updateBackupStatusDisplay();
        addBackupLog(`âœ… Hybrid backup complete!`);
        addBackupLog(`   Latest: kitchen_backup.json`);
        addBackupLog(`   History: DB/${versionedFilename}`);
        addBackupLog(`   Data: ${orderHistory.length} orders, ${vipTransactions.length} VIP transactions`);
        showBackupStatus('âœ… Backup thÃ nh cÃ´ng!', 'success');

      } catch (err) {
        const errorMsg = `âŒ Lá»—i backup: ${err.message}`;
        addBackupLog(errorMsg);
        showBackupStatus(errorMsg, 'warning');
        alert(errorMsg);
        console.error('Backup error:', err);
      }
    }

    async function restoreFromGithub() {
      if (!confirm('âš ï¸ Restore sáº½ ghi Ä‘Ã¨ dá»¯ liá»‡u hiá»‡n táº¡i. Báº¡n cÃ³ cháº¯c cháº¯n?')) {
        return;
      }

      try {
        addBackupLog('ğŸ“¥ Báº¯t Ä‘áº§u restore...');
        showBackupStatus('â³ Äang restore tá»« GitHub...', 'info');

        const repo = localStorage.getItem(GITHUB_REPO_KEY);
        const branch = localStorage.getItem(GITHUB_BRANCH_KEY) || 'master';

        if (!repo) {
          throw new Error('ChÆ°a cÃ i Ä‘áº·t repository');
        }

        const [owner, repoName] = repo.split('/');

        // Fetch combined backup file
        addBackupLog('ğŸ“¥ Äang táº£i kitchen_backup.json...');
        const backupFile = await getGithubFile(owner, repoName, 'kitchen_backup.json', branch);

        if (!backupFile) {
          throw new Error('KhÃ´ng tÃ¬m tháº¥y backup file trÃªn GitHub');
        }

        const backupData = JSON.parse(backupFile.content);

        // Restore order history
        if (backupData.data?.orderHistory && Array.isArray(backupData.data.orderHistory)) {
          orderHistory = backupData.data.orderHistory;
          orderHistory.sort((a, b) => (Date.parse(a?.date) || 0) - (Date.parse(b?.date) || 0));
          localStorage.setItem('orderHistory', JSON.stringify(orderHistory));
          addBackupLog(`âœ… ÄÃ£ restore ${orderHistory.length} orders`);
        }
        syncVipListFromLatestSnapshot();

        // Restore VIP list
        if (backupData.data?.vipList) {
          localStorage.setItem('vipList', backupData.data.vipList);
          document.getElementById('vipArea').value = backupData.data.vipList;
          addBackupLog('âœ… ÄÃ£ restore VIP list');
        }

        // Restore VIP transactions
        if (backupData.data?.vipTransactions && Array.isArray(backupData.data.vipTransactions)) {
          vipTransactions = backupData.data.vipTransactions;
          localStorage.setItem(VIP_TX_KEY, JSON.stringify(vipTransactions));
          addBackupLog(`âœ… ÄÃ£ restore ${vipTransactions.length} VIP transactions`);
        }

        // Refresh UI (rollback: no auto normalize/recompute)
        populateVipMemberSelect();
        renderVipHistory();
        loadDebtManagement();
        loadHistory();

        addBackupLog('âœ… Restore hoÃ n táº¥t!');
        showBackupStatus('âœ… Restore thÃ nh cÃ´ng!', 'success');
        alert('âœ… ÄÃ£ restore dá»¯ liá»‡u tá»« GitHub thÃ nh cÃ´ng!');

      } catch (err) {
        const errorMsg = `âŒ Lá»—i restore: ${err.message}`;
        addBackupLog(errorMsg);
        showBackupStatus(errorMsg, 'warning');
        alert(errorMsg);
        console.error('Restore error:', err);
      }
    }

    function initGithubAutoBackup() {
      // Clear existing interval
      if (githubAutoBackupInterval) {
        clearInterval(githubAutoBackupInterval);
      }

      const interval = parseInt(localStorage.getItem(GITHUB_BACKUP_INTERVAL_KEY)) || 30;
      const enabled = localStorage.getItem(GITHUB_AUTO_BACKUP_ENABLED_KEY) === 'true';

      if (!enabled) return;

      // Set up new interval (convert minutes to milliseconds)
      githubAutoBackupInterval = setInterval(async () => {
        addBackupLog('ğŸ”„ Auto-backup triggered');
        await backupToGithub();
      }, interval * 60 * 1000);

      addBackupLog(`ğŸ”„ Auto-backup scheduled (every ${interval} minutes)`);
    }

    // ========== GitHub Sync Functions ==========

    /**
     * Pull latest data from GitHub
     * @returns {Object} Remote data and metadata
     */
    async function pullFromGithub() {
      try {
        addBackupLog('ğŸ“¥ Pulling data from GitHub...');

        const repo = localStorage.getItem(GITHUB_REPO_KEY);
        const branch = localStorage.getItem(GITHUB_BRANCH_KEY) || 'master';

        if (!repo) {
          throw new Error('ChÆ°a cÃ i Ä‘áº·t repository');
        }

        const [owner, repoName] = repo.split('/');
        if (!owner || !repoName) {
          throw new Error('Repository format khÃ´ng há»£p lá»‡');
        }

        // Fetch remote backup file
        const remoteFile = await getGithubFile(owner, repoName, 'kitchen_backup.json', branch);

        if (!remoteFile || !remoteFile.content) {
          addBackupLog('â„¹ï¸ No remote data found');
          return null;
        }

        // Parse remote data
        const remoteData = JSON.parse(remoteFile.content);

        addBackupLog(`âœ… Pulled: ${remoteData.data?.orderHistory?.length || 0} orders, ${remoteData.data?.vipTransactions?.length || 0} transactions`);

        return {
          data: remoteData.data,
          timestamp: remoteData.timestamp,
          backupTime: remoteData.backupTime
        };

      } catch (err) {
        addBackupLog(`âŒ Pull failed: ${err.message}`);
        throw err;
      }
    }

    /**
     * Merge local and remote data using last-write-wins strategy
     * @param {Object} localData - Local data
     * @param {Object} remoteData - Remote data
     * @returns {Object} Merged data
     */
    function mergeData(localData, remoteData) {
      addBackupLog('ğŸ”„ Merging data...');

      // Merge orderHistory by ID (keep newest by timestamp)
      const orderMap = new Map();

      // Add local orders
      (localData.orderHistory || []).forEach(order => {
        orderMap.set(order.id, order);
      });

      // Add/update with remote orders (newer wins)
      (remoteData.orderHistory || []).forEach(order => {
        const existing = orderMap.get(order.id);
        if (!existing) {
          orderMap.set(order.id, order);
        } else {
          // Compare timestamps - newer wins
          const existingTime = new Date(existing.date || existing.id).getTime();
          const remoteTime = new Date(order.date || order.id).getTime();
          if (remoteTime > existingTime) {
            orderMap.set(order.id, order);
          }
        }
      });

      // Merge vipTransactions by ID (keep all unique)
      const txMap = new Map();

      (localData.vipTransactions || []).forEach(tx => {
        txMap.set(tx.id, tx);
      });

      (remoteData.vipTransactions || []).forEach(tx => {
        if (!txMap.has(tx.id)) {
          txMap.set(tx.id, tx);
        }
      });

      const merged = {
        orderHistory: Array.from(orderMap.values())
          .sort((a, b) => new Date(b.date || b.id) - new Date(a.date || a.id)),
        vipTransactions: Array.from(txMap.values())
          .sort((a, b) => new Date(b.ts || b.id) - new Date(a.ts || a.id))
      };

      addBackupLog(`âœ… Merged: ${merged.orderHistory.length} orders, ${merged.vipTransactions.length} transactions`);

      return merged;
    }

    /**
     * Apply remote/merged data to local storage
     * @param {Object} data - Data to apply
     */
    function applyRemoteData(data) {
      addBackupLog('ğŸ’¾ Applying data to localStorage...');

      // Update localStorage
      orderHistory = data.orderHistory || [];
      orderHistory.sort((a, b) => (Date.parse(a?.date) || 0) - (Date.parse(b?.date) || 0));
      vipTransactions = data.vipTransactions || [];

      localStorage.setItem('orderHistory', JSON.stringify(orderHistory));
      localStorage.setItem(VIP_TX_KEY, JSON.stringify(vipTransactions));
      syncVipListFromLatestSnapshot();

      addBackupLog('âœ… Data applied successfully');
    }

    /**
     * Full sync: Pull from GitHub, merge with local, push back
     */
    async function syncNow() {
      try {
        addBackupLog('ğŸ”„ Starting full sync...');
        showBackupStatus('ğŸ”„ Syncing...', 'info');

        // 1. Pull remote data
        const remote = await pullFromGithub();

        if (!remote) {
          // No remote data, just push local
          addBackupLog('ğŸ“¤ No remote data, pushing local...');
          await backupToGithub();
          showBackupStatus('âœ… Sync complete (pushed local)', 'success');
          return;
        }

        // 2. Get local data
        const local = {
          orderHistory: orderHistory,
          vipTransactions: vipTransactions
        };

        // 3. Merge
        const merged = mergeData(local, remote.data);

        // 4. Apply merged data locally
        applyRemoteData(merged);

        // 5. Push merged data back to GitHub
        addBackupLog('ğŸ“¤ Pushing merged data...');
        await backupToGithub();

        // 6. Refresh UI (rollback: no auto normalize/recompute)
        populateVipMemberSelect();
        renderVipHistory();
        loadDebtManagement();
        loadHistory();

        addBackupLog('âœ… Full sync complete!');
        showBackupStatus('âœ… Sync complete!', 'success');

        return merged;

      } catch (err) {
        const errorMsg = `âŒ Sync failed: ${err.message}`;
        addBackupLog(errorMsg);
        showBackupStatus(errorMsg, 'warning');
        throw err;
      }
    }

    function refreshQuickOrderList() {
      const select = document.getElementById('quickOrderSelect');
      if (!select) return;

      const seen = new Set();
      const items = [];

      orderHistory.forEach(order => {
        const name = (order?.itemName || '').trim();
        if (!name || seen.has(name)) return;
        seen.add(name);
        const ts = new Date(order?.date || order?.id || 0).getTime() || 0;
        items.push({ name, ts });
      });

      if (items.length === 0) {
        select.innerHTML = '<option value="">ChÆ°a cÃ³ mÃ³n nÃ o</option>';
        return;
      }

      items.sort((a, b) => b.ts - a.ts);
      select.innerHTML = items.map(i => `<option value="${i.name}">${i.name}</option>`).join('');
    }

    // Draft autosave helpers
    function getDraftPayload(hasChanges = draftDirty) {
      const people = Array.from(document.querySelectorAll('#orderTable tbody tr')).map(tr => {
        const nameInput = tr.children[0]?.querySelector('input');
        const qtyInput = tr.children[1]?.querySelector('input');
        const shipPartsInput = tr.children[2]?.querySelector('input');
        const paidCheck = tr.children[3]?.querySelector('input[type="checkbox"]');
        return {
          name: (nameInput?.value || '').trim(),
          qty: Number(qtyInput?.value || 0),
          shipParts: Number(shipPartsInput?.value || 0),
          paid: !!paidCheck?.checked
        };
      }).filter(p => p.name);

      return {
        draftOrder: {
          itemName: document.getElementById('itemName')?.value || '',
          totalParts: Number(document.getElementById('n')?.value || 0),
          alvinFree: !!document.getElementById('alvinFree')?.checked,
          desiredPrice: Number(document.getElementById('desiredPrice')?.value || 0),
          people,
          lastModified: Date.now(),
          hasChanges: hasChanges === true
        }
      };
    }

    function applyPeopleToTable(people = []) {
      const tbody = document.querySelector('#orderTable tbody');
      if (!tbody) return;
      suppressDraftChange = true;
      tbody.innerHTML = '';

      if (!Array.isArray(people) || people.length === 0) {
        addRow();
        suppressDraftChange = false;
        return;
      }

      people.forEach(p => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
      <td><input class="name-input" value="${p.name || ''}" placeholder="Nháº­p tÃªn..."></td>
      <td><input type="number" min="1" step="1" value="${p.qty || 1}"></td>
      <td><input type="number" min="0" step="1" value="${p.shipParts || 0}" class="ship-count-input" placeholder="0"></td>
	      <td style="text-align: center;"><input type="checkbox" class="payment-check" ${p.paid === true ? 'checked' : ''}></td>
      <td style="text-align: center;"><button class="btn btn-danger" onclick="delRow(this)">âœ•</button></td>
    `;
        tbody.appendChild(tr);
      });

      suppressDraftChange = false;
    }

    function updateDraftStatusUI(draftOrder = {}) {
      const dot = document.getElementById('draftStatusDot');
      const statusText = document.getElementById('draftStatusText');
      const metaText = document.getElementById('draftMetaText');
      const hasChanges = draftOrder.hasChanges || draftDirty;
      const lastModified = draftOrder.lastModified || draftOrder.draftModified || Date.now();

      if (dot) {
        dot.classList.toggle('saved', !hasChanges);
        dot.classList.toggle('unsaved', hasChanges);
      }
      if (statusText) {
        statusText.textContent = hasChanges ? 'NhÃ¡p cÃ³ thay Ä‘á»•i (chÆ°a backup iCloud)' : 'NhÃ¡p Ä‘Ã£ lÆ°u';
      }
      if (metaText) {
        metaText.textContent = `Tá»± Ä‘á»™ng lÆ°u 30 phÃºt/láº§n | LÆ°u cuá»‘i: ${formatDraftTime(lastModified)}`;
      }
    }

    function setDraftBanner(message) {
      const banner = document.getElementById('draftBannerMessage');
      if (banner) banner.textContent = message || '';
    }

    function saveDraftToLocalStorage() {
      const draft = getDraftPayload(true);
      localStorage.setItem(DRAFT_STORAGE_KEY, JSON.stringify(draft));
      draftDirty = true;
      updateDraftStatusUI(draft.draftOrder);
      return draft;
    }

    function loadDraftFromLocalStorage() {
      try {
        const raw = localStorage.getItem(DRAFT_STORAGE_KEY);
        return raw ? JSON.parse(raw) : null;
      } catch (_err) {
        return null;
      }
    }

    function restoreDraftToUI(draftData) {
      if (!draftData || !draftData.draftOrder) return;

      const data = draftData.draftOrder;
      document.getElementById('itemName').value = data.itemName || '';
      document.getElementById('n').value = data.totalParts || 0;
      document.getElementById('alvinFree').checked = !!data.alvinFree;
      const desiredPriceInput = document.getElementById('desiredPrice');
      if (desiredPriceInput) desiredPriceInput.value = data.desiredPrice || '';
      selectedPrice = data.desiredPrice ? Number(data.desiredPrice) : null;
      applyPeopleToTable(data.people || []);

      draftDirty = !!data.hasChanges;
      updateDraftStatusUI(data);
      setDraftBanner('ğŸ“‹ ÄÃ£ khÃ´i phá»¥c Ä‘Æ¡n nhÃ¡p');

      // Clear pricing fields when restoring draft (after F5 or restore)
      if (typeof clearPricingFields === 'function') {
        clearPricingFields();
      }
    }

    function markDraftChanged() {
      if (suppressDraftChange) return;
      lastComputedSignature = null;
      lastComputedOrder = null;
      draftDirty = true;
      updateDraftStatusUI({ hasChanges: true, lastModified: Date.now() });
      if (debouncedLocalDraftSave) {
        debouncedLocalDraftSave();
      } else {
        saveDraftToLocalStorage();
      }
    }

    function recordDraftMeta(path, savedAt, name = '') {
      const meta = JSON.parse(localStorage.getItem(DRAFT_META_KEY) || '[]').filter(Boolean);
      meta.unshift({ path, savedAt, name });

      // Deduplicate by path
      const unique = [];
      const seen = new Set();
      meta.forEach(entry => {
        if (!entry.path || seen.has(entry.path)) return;
        seen.add(entry.path);
        unique.push(entry);
      });

      localStorage.setItem(DRAFT_META_KEY, JSON.stringify(unique.slice(0, 10)));
    }

    async function deleteDraftFile(path) {
      try {
        if (window.orderHelperNative?.deleteFile) {
          await window.orderHelperNative.deleteFile(path);
          return true;
        }
        if (window.webkit?.messageHandlers?.orderHelperNative) {
          window.webkit.messageHandlers.orderHelperNative.postMessage({ action: 'deleteFile', path });
          return true;
        }
      } catch (err) {
        console.error('Delete draft failed', err);
      }
      return false;
    }

    async function cleanupOldDraftBackups() {
      const entries = JSON.parse(localStorage.getItem(DRAFT_META_KEY) || '[]').filter(Boolean);
      const now = Date.now();

      const toKeep = entries
        .filter(e => e.path)
        .sort((a, b) => (b.savedAt || 0) - (a.savedAt || 0));

      const fresh = toKeep.filter(e => now - (e.savedAt || 0) <= 7 * 24 * 60 * 60 * 1000);
      const survivors = fresh.slice(0, 5);
      const survivorPaths = new Set(survivors.map(s => s.path));
      const toDelete = toKeep.filter(e => !survivorPaths.has(e.path));

      for (const entry of toDelete) {
        await deleteDraftFile(entry.path);
      }

      localStorage.setItem(DRAFT_META_KEY, JSON.stringify(survivors));
    }

    async function writeFileToICloud(path, content, { allowDownloadFallback = false } = {}) {
      try {
        if (window.orderHelperNative?.writeFile) {
          await window.orderHelperNative.writeFile({ path, content });
          return { ok: true };
        }
        if (window.orderHelperNative?.writeTextFile) {
          await window.orderHelperNative.writeTextFile(path, content);
          return { ok: true };
        }
        if (window.webkit?.messageHandlers?.orderHelperNative) {
          window.webkit.messageHandlers.orderHelperNative.postMessage({ action: 'writeFile', path, content });
          return { ok: true };
        }
      } catch (err) {
        return { ok: false, error: err?.message || 'Unknown write error' };
      }

      if (allowDownloadFallback) {
        const a = document.createElement('a');
        const blob = new Blob([content], { type: 'application/json' });
        a.href = URL.createObjectURL(blob);
        a.download = path.split('/').pop();
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
        return { ok: true, fallback: true };
      }

      return { ok: false, error: 'KhÃ´ng cÃ³ bridge Ä‘á»ƒ ghi iCloud' };
    }

    function appendLog(message) {
      const line = `[${new Date().toISOString()}] ${message}`;
      console.error(line);
      try {
        if (window.orderHelperNative?.appendLog) {
          window.orderHelperNative.appendLog(line);
          return;
        }
        if (window.webkit?.messageHandlers?.orderHelperNative) {
          window.webkit.messageHandlers.orderHelperNative.postMessage({ action: 'appendLog', message: line });
        }
      } catch (_err) {
        // ignore
      }
    }

    function getDraftFilename(ts) {
      const d = new Date(ts);
      const pad = (n) => String(n).padStart(2, '0');
      const yyyy = d.getFullYear();
      const mm = pad(d.getMonth() + 1);
      const dd = pad(d.getDate());
      const hh = pad(d.getHours());
      const min = pad(d.getMinutes());
      return `draft_order_${yyyy}-${mm}-${dd}_${hh}${min}.json`;
    }

    async function saveDraftToICloud({ force = false, allowDownloadFallback = false, reason = 'auto' } = {}) {
      if (!force && !draftDirty) return false;

      if (draftBackupInFlight) return false;
      draftBackupInFlight = true;

      const draft = getDraftPayload(force || draftDirty);
      const now = Date.now();
      const filename = getDraftFilename(now);
      const path = `${DRAFT_DIR}/${filename}`;
      const content = JSON.stringify(draft, null, 2);

      try {
        if (window.orderHelperNative?.ensureDir) {
          try {
            await window.orderHelperNative.ensureDir(DRAFT_DIR);
          } catch (_err) {
            // ignore dir creation errors, writer may still handle it
          }
        }

        const res = await writeFileToICloud(path, content, { allowDownloadFallback });

        if (res.ok) {
          draft.draftOrder.hasChanges = false;
          draft.draftOrder.lastModified = now;
          localStorage.setItem(DRAFT_STORAGE_KEY, JSON.stringify(draft));
          draftDirty = false;
          lastDraftBackupPath = path;
          updateDraftStatusUI(draft.draftOrder);

          // NEW: Ensure metadata is recorded with the item name
          recordDraftMeta(path, now, draft.draftOrder.itemName);
          setDraftBanner(`âœ… ÄÃ£ backup iCloud (${filename})`);
          cleanupOldDraftBackups();
          if (draftBackupRetryTimeout) {
            clearTimeout(draftBackupRetryTimeout);
            draftBackupRetryTimeout = null;
          }
          return true;
        }

        setDraftBanner('âš ï¸ LÆ°u iCloud tháº¥t báº¡i, sáº½ thá»­ láº¡i sau');
        appendLog(`Draft backup failed (${reason}): ${res.error || 'unknown error'}`);

        if (!draftBackupRetryTimeout) {
          draftBackupRetryTimeout = setTimeout(() => {
            draftBackupRetryTimeout = null;
            saveDraftToICloud({ force: true, reason: 'retry' });
          }, DRAFT_RETRY_INTERVAL_MS);
        }

        return false;
      } finally {
        draftBackupInFlight = false;
      }
    }

    async function readFileFromICloud(path) {
      appendLog(`[NativeDebug] Attempting to read: ${path}`);

      if (!window.orderHelperNative) {
        appendLog(`[NativeDebug] window.orderHelperNative is MISSING`);
      } else {
        const methods = Object.keys(window.orderHelperNative);
        appendLog(`[NativeDebug] Bridge found. Methods: ${methods.join(', ')}`);

        try {
          // Attempt 1: readTextFile(path)
          if (typeof window.orderHelperNative.readTextFile === 'function') {
            appendLog(`[NativeDebug] Trying readTextFile(path)...`);
            const res = await window.orderHelperNative.readTextFile(path);
            if (res && res.length > 0) {
              appendLog(`[NativeDebug] readTextFile success (${res.length} chars)`);
              return res;
            }
            appendLog(`[NativeDebug] readTextFile(path) returned empty/falsy`);
          }

          // Attempt 2: readFile(path)
          if (typeof window.orderHelperNative.readFile === 'function') {
            appendLog(`[NativeDebug] Trying readFile(path)...`);
            const res = await window.orderHelperNative.readFile(path);
            if (res && (typeof res === 'string' || (res && res.content))) {
              appendLog(`[NativeDebug] readFile success`);
              return typeof res === 'string' ? res : res.content;
            }
            appendLog(`[NativeDebug] readFile(path) returned empty/falsy`);
          }

          // Attempt 3: readFile({ path })
          if (typeof window.orderHelperNative.readFile === 'function') {
            appendLog(`[NativeDebug] Trying readFile({path})...`);
            const res = await window.orderHelperNative.readFile({ path });
            if (res && (typeof res === 'string' || (res && res.content))) {
              appendLog(`[NativeDebug] readFile({path}) success`);
              return typeof res === 'string' ? res : res.content;
            }
          }
        } catch (err) {
          appendLog(`[NativeDebug] Bridge exception: ${err.message}`);
        }
      }

      appendLog(`[NativeDebug] All native attempts failed. Protocol: ${location.protocol}`);

      // Fallback for non-file origins
      if (location.protocol !== 'file:') {
        try {
          const res = await fetch(`file://${encodeURI(path)}`);
          if (res.ok) return await res.text();
        } catch (_err) { }
      }

      return null;
    }


    async function deleteDraftFromManager(path, event) {
      if (event) event.stopPropagation(); // Don't load the draft if clicking delete

      const filename = path.split('/').pop();
      if (!confirm(`Báº¡n cÃ³ cháº¯c cháº¯n muá»‘n xoÃ¡ vÄ©nh viá»…n file nhÃ¡p "${filename}"?`)) return;

      setDraftBanner('ğŸ—‘ï¸ Äang xoÃ¡...');

      // 1. Delete actual file if native bridge is available
      if (window.orderHelperNative?.deleteFile) {
        try {
          await window.orderHelperNative.deleteFile(path);
        } catch (err) {
          console.error('Delete file error:', err);
        }
      }

      // 2. Update metadata in localStorage
      const meta = JSON.parse(localStorage.getItem(DRAFT_META_KEY) || '[]').filter(e => e && e.path !== path);
      localStorage.setItem(DRAFT_META_KEY, JSON.stringify(meta));

      // 3. Refresh the UI
      showDraftManager();
      setDraftBanner('âœ… ÄÃ£ xoÃ¡ file nhÃ¡p');
    }

    async function loadDraftByPath(path) {
      // Check if native bridge exists
      const hasBridge = !!(window.orderHelperNative?.readFile || window.orderHelperNative?.readTextFile);

      if (!hasBridge) {
        // Browser mode - can't read files directly, show file picker
        alert('âš ï¸ TrÃ¬nh duyá»‡t khÃ´ng thá»ƒ Ä‘á»c file trá»±c tiáº¿p.\n\nVui lÃ²ng chuyá»ƒn sang tab "Backup" vÃ  sá»­ dá»¥ng nÃºt "Táº£i tá»« file" Ä‘á»ƒ load láº¡i Ä‘Æ¡n nhÃ¡p.');
        closeModal('draftManagerModal');
        return;
      }

      setDraftBanner('âŒ› Äang táº£i...');
      const content = await readFileFromICloud(path);
      if (!content) {
        setDraftBanner('âŒ Lá»—i: KhÃ´ng thá»ƒ Ä‘á»c file');
        return;
      }
      try {
        const data = JSON.parse(content);
        const payload = data && data.draftOrder ? data.draftOrder : data;
        restoreDraftToUI({ draftOrder: { ...payload, hasChanges: false } });
        draftDirty = false;
        updateDraftStatusUI({ ...payload, hasChanges: false });
        setDraftBanner('ğŸ“‚ ÄÃ£ khÃ´i phá»¥c nhÃ¡p');
        closeModal('draftManagerModal');
      } catch (err) {
        setDraftBanner('âŒ File khÃ´ng há»£p lá»‡');
      }
    }

    async function refreshDraftListFromDisk() {
      if (!window.orderHelperNative?.listFiles) {
        alert('TÃ­nh nÄƒng nÃ y chá»‰ há»— trá»£ trÃªn á»©ng dá»¥ng Desktop.');
        return;
      }

      setDraftBanner('ğŸ” Äang quÃ©t file nhÃ¡p...');
      try {
        const files = await window.orderHelperNative.listFiles(DRAFT_DIR);
        if (!Array.isArray(files)) return;

        const entries = files
          .filter(f => typeof f === 'string' && f.startsWith('draft_order_') && f.endsWith('.json'))
          .map(name => {
            // Try to parse timestamp from filename: draft_order_2026-01-01_1331.json
            const parts = name.replace('draft_order_', '').replace('.json', '').split('_');
            let ts = Date.now();
            if (parts.length >= 2) {
              const datePart = parts[0]; // 2026-01-01
              const timePart = parts[1]; // 1331
              const year = datePart.split('-')[0];
              const month = datePart.split('-')[1];
              const day = datePart.split('-')[2];
              const hour = timePart.substring(0, 2);
              const min = timePart.substring(2, 4);
              ts = new Date(`${year}-${month}-${day}T${hour}:${min}:00`).getTime();
            }
            return { path: `${DRAFT_DIR}/${name}`, savedAt: ts, name: '' };
          });

        // Merge with existing meta to preserve names if possible
        const existingMap = new Map();
        const currentMeta = JSON.parse(localStorage.getItem(DRAFT_META_KEY) || '[]').filter(Boolean);
        currentMeta.forEach(m => existingMap.set(m.path, m.name));

        const merged = entries.map(e => ({
          ...e,
          name: existingMap.get(e.path) || ''
        })).sort((a, b) => b.savedAt - a.savedAt);

        localStorage.setItem(DRAFT_META_KEY, JSON.stringify(merged.slice(0, 20)));
        showDraftManager(); // Re-render
        setDraftBanner(`âœ… ÄÃ£ tÃ¬m tháº¥y ${merged.length} file nhÃ¡p`);
      } catch (err) {
        alert('Lá»—i khi quÃ©t file: ' + err.message);
      }
    }

    function showDraftManager() {
      const entries = JSON.parse(localStorage.getItem(DRAFT_META_KEY) || '[]').filter(e => e && e.path);
      const container = document.getElementById('draftListContainer');
      if (!container) return;

      const hasBridge = !!(window.orderHelperNative?.readFile || window.orderHelperNative?.readTextFile);

      if (entries.length === 0) {
        container.innerHTML = '<div style="text-align: center; padding: 20px; opacity: 0.7;">ChÆ°a cÃ³ Ä‘Æ¡n nhÃ¡p nÃ o Ä‘Æ°á»£c lÆ°u.</div>';
      } else {
        if (!hasBridge) {
          container.innerHTML = `
            <div style="text-align: center; padding: 20px; background: rgba(251, 191, 36, 0.1); border-radius: 12px; border: 1px solid rgba(251, 191, 36, 0.3); margin-bottom: 16px;">
              <div style="font-size: 1.2rem; margin-bottom: 8px;">âš ï¸ TrÃ¬nh duyá»‡t khÃ´ng thá»ƒ Ä‘á»c file trá»±c tiáº¿p</div>
              <div style="font-size: 0.9rem; opacity: 0.9;">Báº¡n cÃ³ ${entries.length} Ä‘Æ¡n nhÃ¡p Ä‘Ã£ lÆ°u. Äá»ƒ táº£i láº¡i, vui lÃ²ng:</div>
              <ol style="text-align: left; margin-top: 12px; padding-left: 20px; font-size: 0.85rem;">
                <li>Chuyá»ƒn sang tab <strong>â˜ï¸ Backup</strong></li>
                <li>Báº¥m nÃºt <strong>ğŸ“‚ Táº£i tá»« file</strong></li>
                <li>Chá»n file nhÃ¡p tá»« thÆ° má»¥c: <code style="background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 4px;">/Kitchen/drafts</code></li>
              </ol>
            </div>
            ` + entries.map((e, idx) => {
            const name = e.name || '(KhÃ´ng cÃ³ tÃªn)';
            const date = new Date(e.savedAt).toLocaleString('vi-VN');
            const filename = e.path.split('/').pop();
            return `
                <div class="draft-list-item" style="opacity: 0.6; cursor: default;">
                  <div class="draft-item-info">
                    <div class="draft-item-name">${name}</div>
                    <div class="draft-item-meta">${date} â€¢ ${filename}</div>
                  </div>
                  <div class="draft-item-action">
                    <button class="btn btn-ghost" style="padding: 8px 12px; font-size: 13px; opacity: 0.5;" disabled>ğŸ”’ KhÃ³a</button>
                  </div>
                </div>
              `;
          }).join('');
        } else {
          container.innerHTML = entries.map((e, idx) => {
            const name = e.name || '(KhÃ´ng cÃ³ tÃªn)';
            const date = new Date(e.savedAt).toLocaleString('vi-VN');
            return `
              <div class="draft-list-item" onclick="loadDraftByPath('${e.path}')">
                <div class="draft-item-info">
                  <div class="draft-item-name">${name}</div>
                  <div class="draft-item-meta">${date}</div>
                </div>
                <div class="draft-item-action">
                  <button class="btn btn-ghost" style="padding: 8px 12px; font-size: 13px;">ğŸ“‚ Táº£i</button>
                  <button class="btn-delete-draft" onclick="deleteDraftFromManager('${e.path}', event)" title="XoÃ¡ vÄ©nh viá»…n file nÃ y">âœ•</button>
                </div>
              </div>
            `;
          }).join('');
        }
      }

      const modal = document.getElementById('draftManagerModal');
      if (modal) modal.classList.add('active');
    }

    // ========== Simple Draft Management (localStorage only) ==========

    function saveTempDraft() {
      const draft = getDraftPayload(true);
      const timestamp = Date.now();
      const key = `draft-${timestamp}`;
      const itemName = draft.draftOrder?.itemName || 'KhÃ´ng cÃ³ tÃªn';

      localStorage.setItem(key, JSON.stringify(draft));
      setDraftBanner(`âœ… ÄÃ£ lÆ°u táº¡m: ${itemName}`);

      // Update UI
      setTimeout(() => setDraftBanner(''), 2000);
    }

    function loadTempDraft(key) {
      const data = localStorage.getItem(key);
      if (!data) {
        alert('âŒ KhÃ´ng tÃ¬m tháº¥y Ä‘Æ¡n nhÃ¡p');
        return;
      }

      try {
        const parsed = JSON.parse(data);
        const payload = parsed.draftOrder || parsed;
        restoreDraftToUI({ draftOrder: { ...payload, hasChanges: false } });
        draftDirty = false;
        updateDraftStatusUI({ ...payload, hasChanges: false });
        setDraftBanner('ğŸ“‚ ÄÃ£ khÃ´i phá»¥c Ä‘Æ¡n táº¡m');
        closeModal('draftManagerModal');

        // Clear pricing fields after loading draft
        clearPricingFields();
      } catch (err) {
        alert('âŒ Lá»—i khi táº£i Ä‘Æ¡n: ' + err.message);
      }
    }

    function deleteTempDraft(key, event) {
      if (event) event.stopPropagation();

      if (!confirm('ğŸ—‘ï¸ Báº¡n cÃ³ cháº¯c muá»‘n xoÃ¡ Ä‘Æ¡n nÃ y?')) return;

      localStorage.removeItem(key);
      showDraftManager(); // Refresh
      setDraftBanner('âœ… ÄÃ£ xoÃ¡');
    }

    function showDraftManager() {
      const allKeys = Object.keys(localStorage);
      const draftKeys = allKeys.filter(k => k.startsWith('draft-'));

      const drafts = draftKeys.map(key => {
        try {
          const data = JSON.parse(localStorage.getItem(key));
          const order = data.draftOrder || data;
          const timestamp = parseInt(key.replace('draft-', ''));
          return {
            key,
            name: order.itemName || 'KhÃ´ng cÃ³ tÃªn',
            totalParts: order.totalParts || 0,
            people: order.people?.length || 0,
            savedAt: timestamp
          };
        } catch {
          return null;
        }
      }).filter(Boolean).sort((a, b) => b.savedAt - a.savedAt); // Má»›i nháº¥t trÆ°á»›c

      const container = document.getElementById('draftListContainer');
      if (!container) return;

      if (drafts.length === 0) {
        container.innerHTML = `
          <div style="text-align: center; padding: 40px; opacity: 0.7;">
            <div style="font-size: 3rem; margin-bottom: 12px;">ğŸ“‚</div>
            <div style="font-size: 1.1rem;">ChÆ°a cÃ³ Ä‘Æ¡n táº¡m nÃ o</div>
            <div style="font-size: 0.9rem; margin-top: 8px; opacity: 0.7;">Báº¥m "LÆ°u táº¡m" Ä‘á»ƒ lÆ°u Ä‘Æ¡n hiá»‡n táº¡i</div>
          </div>
        `;
      } else {
        container.innerHTML = drafts.map(d => {
          const date = new Date(d.savedAt).toLocaleString('vi-VN');
          return `
            <div class="draft-list-item" onclick="loadTempDraft('${d.key}')">
              <div class="draft-item-info">
                <div class="draft-item-name">${d.name}</div>
                <div class="draft-item-meta">${date} â€¢ ${d.totalParts} pháº§n â€¢ ${d.people} ngÆ°á»i</div>
              </div>
              <div class="draft-item-action">
                <button class="btn btn-ghost" style="padding: 8px 12px; font-size: 13px;">ğŸ“‚ Táº£i</button>
                <button class="btn-delete-draft" onclick="deleteTempDraft('${d.key}', event)" title="XoÃ¡ Ä‘Æ¡n nÃ y">âœ•</button>
              </div>
            </div>
          `;
        }).join('');
      }

      const modal = document.getElementById('draftManagerModal');
      if (modal) modal.classList.add('active');
    }

    function startNewOrder() {
      if (draftDirty) {
        if (!confirm('âš ï¸ ÄÆ¡n hiá»‡n táº¡i chÆ°a Ä‘Æ°á»£c lÆ°u. Báº¡n cÃ³ cháº¯c muá»‘n báº¯t Ä‘áº§u Ä‘Æ¡n má»›i?')) return;
      }
      clearDraft();
      setDraftBanner('â• Sáºµn sÃ ng cho Ä‘Æ¡n má»›i');
    }

    async function loadLatestDraftFromICloud() {
      let entries = JSON.parse(localStorage.getItem(DRAFT_META_KEY) || '[]').filter(e => e && e.path);

      if (entries.length === 0 && window.orderHelperNative?.listFiles) {
        try {
          const files = await window.orderHelperNative.listFiles(DRAFT_DIR);
          if (Array.isArray(files)) {
            entries = files
              .filter(f => typeof f === 'string' && f.startsWith('draft_order_') && f.endsWith('.json'))
              .map(name => ({ path: `${DRAFT_DIR}/${name}`, savedAt: Date.now() }));
            localStorage.setItem(DRAFT_META_KEY, JSON.stringify(entries));
          }
        } catch (_err) {
          // ignore listing failures
        }
      }

      if (entries.length === 0) {
        setDraftBanner('â„¹ï¸ KhÃ´ng tÃ¬m tháº¥y nhÃ¡p iCloud nÃ o Ä‘á»ƒ táº£i');
        return;
      }

      const latest = entries.sort((a, b) => (b.savedAt || 0) - (a.savedAt || 0))[0];
      const content = await readFileFromICloud(latest.path);

      if (!content) {
        setDraftBanner('âŒ KhÃ´ng thá»ƒ Ä‘á»c nhÃ¡p tá»« iCloud');
        appendLog('Load draft from iCloud failed: missing content');
        return;
      }

      try {
        const data = JSON.parse(content);
        const payload = data && data.draftOrder ? data.draftOrder : data;
        restoreDraftToUI({ draftOrder: { ...payload, hasChanges: false } });
        draftDirty = false;
        updateDraftStatusUI({ ...payload, hasChanges: false });
        setDraftBanner('ğŸ“‚ ÄÃ£ táº£i nhÃ¡p tá»« iCloud');
      } catch (err) {
        appendLog(`Parse draft failed: ${err?.message || err}`);
        setDraftBanner('âŒ File nhÃ¡p khÃ´ng há»£p lá»‡');
      }
    }

    function clearDraft() {
      localStorage.removeItem(DRAFT_STORAGE_KEY);
      draftDirty = false;
      document.getElementById('itemName').value = '';
      document.getElementById('n').value = '';
      document.getElementById('alvinFree').checked = true;
      applyPeopleToTable([]);
      updateDraftStatusUI({ hasChanges: false, lastModified: Date.now() });
      setDraftBanner('ğŸ—‘ï¸ ÄÃ£ xoÃ¡ nhÃ¡p cá»¥c bá»™');
    }

    function setupDraftListeners() {
      const watchedSelectors = ['#quickInput', '#itemName', '#n', '#alvinFree', '#totalCost', '#costPerUnit', '#shipFee', '#targetProfit', '#desiredPrice', '#itemDesc', '#deadline'];
      watchedSelectors.forEach(sel => {
        const el = document.querySelector(sel);
        if (el) {
          el.addEventListener('input', markDraftChanged);
          el.addEventListener('change', markDraftChanged);
        }
      });

      const table = document.getElementById('orderTable');
      if (table) {
        table.addEventListener('input', markDraftChanged);
        table.addEventListener('change', markDraftChanged);
      }
    }

    function startDraftBackupInterval() {
      if (draftBackupIntervalId) clearInterval(draftBackupIntervalId);
      draftBackupIntervalId = setInterval(() => {
        saveDraftToICloud({ reason: 'interval' });
      }, DRAFT_BACKUP_INTERVAL_MS);
    }

    function handleBeforeUnload() {
      if (draftDirty) {
        saveDraftToLocalStorage();
        saveDraftToICloud({ force: true, reason: 'beforeunload' });
      }
    }

    function initDraftAutosave() {
      debouncedLocalDraftSave = debounce(() => saveDraftToLocalStorage(), 1000);

      const storedDraft = loadDraftFromLocalStorage();
      if (storedDraft) {
        restoreDraftToUI(storedDraft);
      } else {
        loadLatestDraftFromICloud();
      }

      updateDraftStatusUI(storedDraft?.draftOrder || { hasChanges: false, lastModified: null });

      setupDraftListeners();
      startDraftBackupInterval();
      window.addEventListener('beforeunload', handleBeforeUnload);
    }

    function manualSaveDraft() {
      saveDraftToLocalStorage();
      saveDraftToICloud({ force: true, allowDownloadFallback: true, reason: 'manual' });
    }

    // Tab Management
    function switchTab(evt, tabName) {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));

      const target = evt?.currentTarget || evt?.target;
      if (target) target.classList.add('active');
      document.getElementById(tabName).classList.add('active');

      // Load data for specific tabs
      if (tabName === 'history') loadHistory();
      if (tabName === 'debt') loadDebtManagement();
      if (tabName === 'stats') loadStats();
    }
    window.switchTab = switchTab;

    // Quick Parse Input
    function parseQuickInput() {
      const input = document.getElementById('quickInput').value.trim();
      if (!input) {
        alert('Vui lÃ²ng nháº­p danh sÃ¡ch order');
        return;
      }

      // Parse VIP for smart matching
      const vipMap = parseVip(document.getElementById('vipArea').value);
      const vipMatcher = vipMap._matcher || new SmartNameMatcher();

      // Clear existing table
      const tbody = document.querySelector('#orderTable tbody');
      tbody.innerHTML = '';

      // Parse format: lines or commas, with optional qty via space/colon
      const items = input
        .split(/[\n,]+/)
        .map(s => s.trim())
        .filter(s => s);
      let totalParts = 0;
      const suggestions = [];

      items.forEach(item => {
        // Extract name and quantity
        const match = item.match(/^(.+?)[\s:]+(\d+)$/);
        const inputName = match ? match[1].trim() : item.trim();
        const qty = match ? parseInt(match[2]) : 1;

        totalParts += qty;

        // Smart match against VIP
        const matchedVIP = vipMatcher.find(inputName);
        let finalName = inputName;

        if (matchedVIP && matchedVIP.original !== inputName) {
          finalName = matchedVIP.original;
          suggestions.push({
            input: inputName,
            suggested: matchedVIP.original
          });
        }

        // Add row to table
        const tr = document.createElement('tr');
        tr.innerHTML = `
      <td><input class="name-input" value="${finalName}"></td>
      <td><input type="number" min="1" step="1" value="${qty}"></td>
      <td><input type="number" min="0" step="1" value="0" class="ship-count-input" placeholder="0"></td>
      <td style="text-align: center;"><input type="checkbox" class="payment-check"></td>
      <td style="text-align: center;"><button class="btn btn-danger" onclick="delRow(this)">âœ•</button></td>
    `;
        tbody.appendChild(tr);
      });

      // Update total parts (add 1 for LÃ£o nhÃ¢n gia)
      document.getElementById('n').value = totalParts + 1;

      // Clear quick input
      document.getElementById('quickInput').value = '';

      // Show success message with suggestions
      let msg = `âœ… ÄÃ£ parse ${items.length} ngÆ°á»i, tá»•ng ${totalParts + 1} pháº§n (bao gá»“m LÃ£o nhÃ¢n gia)`;

      if (suggestions.length > 0) {
        msg += '\n\nğŸ”„ Smart matching Ä‘Ã£ tá»± Ä‘á»™ng sá»­a tÃªn:';
        suggestions.forEach(s => {
          msg += `\nâ€¢ "${s.input}" â†’ "${s.suggested}"`;
        });
      }

      markDraftChanged();
      alert(msg);
    }

    // Table Management
    function addRow() {
      const tbody = document.querySelector('#orderTable tbody');
      const tr = document.createElement('tr');
      tr.innerHTML = `
    <td><input class="name-input" value="" placeholder="Nháº­p tÃªn..."></td>
    <td><input type="number" min="1" step="1" value="1"></td>
    <td><input type="number" min="0" step="1" value="0" class="ship-count-input" placeholder="0"></td>
    <td style="text-align: center;"><input type="checkbox" class="payment-check"></td>
    <td style="text-align: center;"><button class="btn btn-danger" onclick="delRow(this)">âœ•</button></td>
  `;
      tbody.appendChild(tr);
      markDraftChanged();
    }

    function delRow(btn) {
      btn.closest('tr').remove();
      markDraftChanged();
    }

    // Price Suggestion
    function suggestPrices() {
      const n = Number(document.getElementById('n').value || 0);
      const alvinFree = document.getElementById('alvinFree').checked;
      const totalCost = Number(document.getElementById('totalCost').value || 0);
      const costPerUnit = Number(document.getElementById('costPerUnit').value || 0);
      const shipFee = Number(document.getElementById('shipFee').value || 0);
      const targetProfit = Number(document.getElementById('targetProfit').value || 6);

      // Validation: Check minimum parts
      const minParts = alvinFree ? 2 : 1;
      if (n < minParts) {
        alert(`âš ï¸ Lá»—i: Khi báº­t "LÃ£o nhÃ¢n gia free", tá»•ng pháº§n pháº£i â‰¥ 2.\n\nHiá»‡n táº¡i: ${n} pháº§n\nYÃªu cáº§u tá»‘i thiá»ƒu: ${minParts} pháº§n\n\nğŸ’¡ Gá»£i Ã½: TÄƒng sá»‘ pháº§n lÃªn hoáº·c táº¯t "LÃ£o nhÃ¢n gia free".`);
        return;
      }

      const denom = alvinFree ? (n - 1) : n;

      // Double check denom (safety guard)
      if (denom <= 0) {
        alert('âš ï¸ Lá»—i há»‡ thá»‘ng: Máº«u sá»‘ khÃ´ng há»£p lá»‡. Vui lÃ²ng kiá»ƒm tra láº¡i tá»•ng pháº§n.');
        return;
      }

      let T = 0;
      if (costPerUnit > 0) {
        T = n * costPerUnit + shipFee;
      } else if (totalCost > 0) {
        T = totalCost + shipFee;
      } else {
        alert('Vui lÃ²ng nháº­p Tá»•ng tiá»n mÃ³n (T) hoáº·c Chi phÃ­/pháº§n (c)');
        return;
      }

      const priceBreakEven = ceilInt(T / denom);
      const priceProfit = ceilInt((T + targetProfit) / denom);

      const suggestionHTML = `
    <div class="price-suggestion">
      <div class="price-card" onclick="selectPrice(${priceBreakEven}, event)">
        <div class="price-card-label">HoÃ  vá»‘n</div>
        <div class="price-card-value">${priceBreakEven}Ä‘</div>
        <div class="price-card-desc">Thu = Chi</div>
      </div>
      <div class="price-card active" onclick="selectPrice(${priceProfit}, event)">
        <div class="price-card-label">Lá»i ${targetProfit}Ä‘</div>
        <div class="price-card-value">${priceProfit}Ä‘</div>
        <div class="price-card-desc">Lá»i tá»‘i thiá»ƒu ${targetProfit}Ä‘</div>
      </div>
    </div>
  `;

      document.getElementById('priceSuggestion').innerHTML = suggestionHTML;
      selectPrice(priceProfit);
    }

    function handleDesiredPriceInput() {
      const input = document.getElementById('desiredPrice');
      if (!input) return;

      const manualPrice = Number(input.value || 0);
      document.querySelectorAll('.price-card').forEach(card => card.classList.remove('active'));

      if (manualPrice > 0) {
        selectedPrice = manualPrice;
      } else {
        selectedPrice = null;
      }
    }

    function selectPrice(price, evt) {
      document.querySelectorAll('.price-card').forEach(card => {
        card.classList.remove('active');
      });

      if (evt && evt.target) {
        evt.target.closest('.price-card').classList.add('active');
      }

      selectedPrice = price;
      const desiredPriceInput = document.getElementById('desiredPrice');
      if (desiredPriceInput) desiredPriceInput.value = price;
    }

    // Main Compute Function
    function compute(options = {}) {
      const saveHistory = !!options.save;
      const silent = !!options.silent;
      const skipIfUnchanged = !!options.skipIfUnchanged;
      const itemName = document.getElementById('itemName').value.trim() || 'MÃ³n Äƒn';
      const n = Number(document.getElementById('n').value || 0);
      const alvinFree = document.getElementById('alvinFree').checked;
      const totalCost = Number(document.getElementById('totalCost').value || 0);
      const costPerUnit = Number(document.getElementById('costPerUnit').value || 0);
      const shipFee = Number(document.getElementById('shipFee').value || 0);
      const targetProfitInput = Number(document.getElementById('targetProfit')?.value || 0);
      const desiredPriceInput = Number(document.getElementById('desiredPrice')?.value || 0);
      const itemDesc = document.getElementById('itemDesc')?.value || '';
      const deadline = document.getElementById('deadline')?.value || '';
      const isEditingExisting = !!editingOrderId;

      // Validation: Check minimum parts
      const minParts = alvinFree ? 2 : 1;
      if (n < minParts) {
        alert(`âš ï¸ Lá»—i: Khi báº­t "LÃ£o nhÃ¢n gia free", tá»•ng pháº§n pháº£i â‰¥ 2.\n\nHiá»‡n táº¡i: ${n} pháº§n\nYÃªu cáº§u tá»‘i thiá»ƒu: ${minParts} pháº§n\n\nğŸ’¡ Gá»£i Ã½: TÄƒng sá»‘ pháº§n lÃªn hoáº·c táº¯t "LÃ£o nhÃ¢n gia free".`);
        return null;
      }

      const denom = alvinFree ? (n - 1) : n;
      if (denom <= 0) {
        alert('âš ï¸ Lá»—i há»‡ thá»‘ng: Máº«u sá»‘ khÃ´ng há»£p lá»‡. Vui lÃ²ng kiá»ƒm tra láº¡i tá»•ng pháº§n.');
        return null;
      }

      let T = 0;
      if (costPerUnit > 0) {
        T = n * costPerUnit + shipFee;
      } else if (totalCost > 0) {
        T = totalCost + shipFee;
      }

      // Parse Order Table
      const rows = Array.from(document.querySelectorAll('#orderTable tbody tr')).map(tr => {
        const nameInput = tr.children[0].querySelector('input');
        const qtyInput = tr.children[1].querySelector('input');
        const shipPartsInput = tr.children[2].querySelector('input');
        const paidCheck = tr.children[3].querySelector('input[type="checkbox"]');
        const name = (nameInput.value || '').trim();
        const qty = Number(qtyInput.value || 0);
        let shipParts = Number(shipPartsInput.value || 0);
        shipParts = Math.max(0, Math.min(shipParts, qty)); // clamp 0..qty
        const paid = paidCheck.checked;
        return { name, qty, paid, shipParts };
      }).filter(r => r.name && r.qty > 0);

      const shipCount = rows.reduce((sum, r) => sum + r.shipParts, 0);
      const nonShipCount = rows.reduce((sum, r) => sum + (r.qty - r.shipParts), 0);

      // Decide pricing mode
      let sellingPrice = selectedPrice;
      let priceNonShip = null;
      let priceShip = null;
      let revenue = 0;
      let profit = 0;
      const foodCostOnly = T - shipFee;

      const canSplitShip = shipFee > 0 && shipCount > 0;

      if (canSplitShip) {
        // Base giÃ¡: chia Ä‘á»u tiá»n mÃ³n; ship chia riÃªng cho pháº§n cÃ³ ship
        const basePrice = foodCostOnly / denom;
        priceNonShip = ceilInt(basePrice);
        const surchargePerShip = shipFee / shipCount;
        priceShip = ceilInt(basePrice + surchargePerShip);
        sellingPrice = priceNonShip; // keep for backward compatibility fields

        const revenueNonShip = priceNonShip * nonShipCount;
        const revenueShip = priceShip * shipCount;
        revenue = revenueNonShip + revenueShip;
        profit = revenue - (foodCostOnly + shipFee);
      } else {
        if (!selectedPrice) {
          alert('Vui lÃ²ng báº¥m "Äá» xuáº¥t 2 má»©c giÃ¡" vÃ  chá»n giÃ¡ bÃ¡n trÆ°á»›c.');
          return null;
        }
        sellingPrice = selectedPrice;
        priceNonShip = sellingPrice;
        priceShip = sellingPrice;
        revenue = denom * sellingPrice;
        profit = revenue - T;
      }

      // Parse VIP with smart matching
      const vipFromArea = parseVip(document.getElementById('vipArea').value);
      const vipPersisted = parseVip(localStorage.getItem('vipList') || '');
      let vipMap = new Map([...vipPersisted, ...vipFromArea]);

      // Get matcher from vipMap
      const vipMatcher = vipFromArea._matcher || new SmartNameMatcher();

      // Re-populate matcher with all VIP data
      vipMap.forEach((balance, name) => {
        vipMatcher.add(name, balance);
      });

      // Process payments with smart name matching
      const members = [];
      const vipChanged = new Set();
      const orderDetails = [];
      const nameCorrections = []; // Track name corrections

      rows.forEach(r => {
        const shipQty = r.shipParts;
        const nonShipQty = r.qty - shipQty;
        const due = shipQty * priceShip + nonShipQty * priceNonShip;

        // Smart match: check if this name matches any VIP
        const matchedVIP = vipMatcher.find(r.name);

        if (matchedVIP) {
          // Found VIP match!
          const originalName = matchedVIP.original;
          const currentBalance = matchedVIP.data;
          const newBalance = currentBalance - due;

          // Update VIP balance
          vipMap.set(originalName, newBalance);
          vipMatcher.add(originalName, newBalance);
          vipChanged.add(originalName);

          // Track if name was corrected
          if (r.name !== originalName) {
            nameCorrections.push({
              input: r.name,
              corrected: originalName
            });
          }

          orderDetails.push({
            name: originalName, // Use original VIP name
            qty: r.qty,
            shipQty,
            nonShipQty,
            due: due,
            paid: true, // VIP auto-paid
            isVipPayment: true,
            paymentMethod: 'vip',
            unitPrice: shipQty > 0 && nonShipQty > 0 ? `${formatMoney(priceNonShip)} / ${formatMoney(priceShip)}` : (shipQty > 0 ? priceShip : priceNonShip)
          });
        } else {
          // Not VIP, add to members
          orderDetails.push({
            name: r.name,
            qty: r.qty,
            shipQty,
            nonShipQty,
            due: due,
            paid: r.paid,
            unitPrice: shipQty > 0 && nonShipQty > 0 ? `${formatMoney(priceNonShip)} / ${formatMoney(priceShip)}` : (shipQty > 0 ? priceShip : priceNonShip)
          });

          if (!r.paid) {
            members.push({ name: r.name, due: due, qty: r.qty });
          }
        }
      });

      // Save to history
      const order = {
        id: editingOrderId || Date.now(),
        date: editingOrderDate || new Date().toISOString(),
        itemName: itemName,
        totalParts: n,
        alvinFree,
        sellingPrice: sellingPrice,
        sellingPriceShip: priceShip,
        sellingPriceNonShip: priceNonShip,
        splitShipMode: canSplitShip,
        shipCount,
        nonShipCount,
        shipFee,
        totalCost: T,
        totalCostInput: totalCost,
        costPerUnitInput: costPerUnit,
        targetProfit: targetProfitInput,
        desiredPriceInput,
        itemDesc,
        deadline,
        revenue: revenue,
        profit: profit,
        details: orderDetails,
        vipSnapshot: Array.from(vipMap.entries())
      };

      const orderSignature = buildOrderSignature({
        itemName,
        totalParts: n,
        alvinFree,
        totalCostInput: totalCost,
        costPerUnitInput: costPerUnit,
        shipFee,
        targetProfit: targetProfitInput,
        priceNonShip,
        priceShip,
        splitShipMode: canSplitShip,
        details: orderDetails
      });
      order.signature = orderSignature;
      lastComputedSignature = orderSignature;
      lastComputedOrder = order;

      let savedToHistory = false;
      const skipSave = saveHistory && skipIfUnchanged && lastSavedSignature === orderSignature;

      if (saveHistory && !skipSave) {
        if (isEditingExisting) {
          const idx = orderHistory.findIndex(o => o.id === editingOrderId);
          if (idx >= 0) {
            orderHistory[idx] = order;
          } else {
            orderHistory.unshift(order);
          }
        } else {
          orderHistory.unshift(order);
        }
        localStorage.setItem('orderHistory', JSON.stringify(orderHistory));

        // Create VIP transactions only for details explicitly paid by VIP
        orderDetails.forEach((detail, detailIndex) => {
          const isVipPayment = detail.isVipPayment === true || detail.paymentMethod === 'vip';
          if (!detail.paid || !isVipPayment) return;

          const existingTx = vipTransactions.find(tx =>
            tx.type === 'order' &&
            tx.orderId === order.id &&
            tx.name === detail.name &&
            tx.detailIndex === detailIndex
          );
          if (existingTx) return;

          recordVipTransaction({
            name: detail.name,
            amount: -detail.due,
            type: 'order',
            itemName: order.itemName,
            orderId: order.id,
            detailIndex,
            isVipPayment: true,
            paymentMethod: 'vip'
          });
        });

        lastSavedSignature = orderSignature;
        savedToHistory = true;
      } else if (saveHistory && skipSave) {
        lastSavedSignature = orderSignature;
      }
      if (saveHistory && (savedToHistory || skipSave)) {
        refreshQuickOrderList();
        updateDishNameSuggestions();
      }
      if (saveHistory && (savedToHistory || skipSave)) {
        editingOrderId = null;
        editingOrderDate = null;
      }

      // Generate Summary HTML
      const priceDetailText = canSplitShip
        ? `Ko ship: ${formatMoney(priceNonShip)} | CÃ³ ship: ${formatMoney(priceShip)}`
        : `${formatMoney(sellingPrice)}/pháº§n`;

      const revenueDetail = canSplitShip
        ? `${nonShipCount} Ã— ${formatMoney(priceNonShip)} + ${shipCount} Ã— ${formatMoney(priceShip)}`
        : `${denom} Ã— ${formatMoney(sellingPrice)}`;

      const summaryHTML = `
    <div class="summary-grid">
      <div class="summary-item">
        <h3>Tá»•ng pháº§n (n)</h3>
        <div class="summary-value">${n} pháº§n</div>
        <div class="summary-detail">${alvinFree ? `Thu ${denom} pháº§n (LÃ£o nhÃ¢n gia free)` : `Thu ${n} pháº§n`}</div>
      </div>
      <div class="summary-item">
        <h3>Tá»•ng chi (T)</h3>
        <div class="summary-value">${formatMoney(T)}</div>
        <div class="summary-detail">${costPerUnit > 0 ? `${n} Ã— ${formatMoney(costPerUnit)}` : formatMoney(totalCost)} + ship ${formatMoney(shipFee)}</div>
      </div>
      <div class="summary-item">
        <h3>Thu</h3>
        <div class="summary-value">${formatMoney(revenue)}</div>
        <div class="summary-detail">${revenueDetail}</div>
      </div>
      <div class="summary-item">
        <h3>Káº¿t quáº£</h3>
        <div class="summary-value ${profit >= 0 ? 'profit-positive' : 'profit-negative'}">
          ${profit >= 0 ? 'Lá»i' : 'Lá»—'} ${formatMoney(Math.abs(profit))}
        </div>
        <div class="summary-detail">HoÃ  vá»‘n: ${ceilInt(T / denom)}Ä‘/pháº§n</div>
      </div>
    </div>

    <div class="summary-grid" style="margin-top: 12px;">
      <div class="summary-item">
        <h3>ÄÆ¡n giÃ¡</h3>
        <div class="summary-value">${priceDetailText}</div>
        <div class="summary-detail">${canSplitShip ? `Ship ${shipCount} pháº§n | KhÃ´ng ship ${nonShipCount} pháº§n` : 'Ãp dá»¥ng chung cho táº¥t cáº£'}</div>
      </div>
      ${canSplitShip ? `
      <div class="summary-item">
        <h3>Chi tiáº¿t ship</h3>
        <div class="summary-value">${formatMoney(shipFee)}</div>
        <div class="summary-detail">${formatMoney(shipFee / shipCount)} má»—i pháº§n ship (lÃ m trÃ²n khi tÃ­nh tiá»n)</div>
      </div>` : ''}
    </div>

    <div class="grid" style="margin-top: 20px;">
      <div class="glass-card" style="padding: 20px;">
        <h3 style="font-size: 16px; margin-bottom: 12px; color: var(--text-secondary);">ğŸ‘‘ VIP (sá»‘ dÆ° sau khi trá»«)</h3>
        ${vipMap.size > 0 ? `
          <ul class="info-list">
            ${Array.from(vipMap.entries()).map(([name, bal]) => {
        const charged = vipChanged.has(name);
        const chargeAmount = charged
          ? orderDetails.filter(d => d.name === name).reduce((sum, d) => sum + d.due, 0)
          : 0;
        return `
              <li>
                <span class="name">${name}${charged ? ` (Ä‘Ã£ trá»« ${formatMoney(chargeAmount)})` : ''}</span>
                <span>
                  <span class="value">${formatMoney(bal)}</span>
                </span>
              </li>
            `;
      }).join('')}
          </ul>
        ` : '<div class="empty-state"><div class="empty-state-icon">ğŸ«™</div>ChÆ°a cÃ³ VIP</div>'}
      </div>

      <div class="glass-card" style="padding: 20px;">
        <h3 style="font-size: 16px; margin-bottom: 12px; color: var(--text-secondary);">ğŸ‘¥ Member (chÆ°a tráº£)</h3>
        ${members.length > 0 ? `
          <ul class="info-list">
            ${members.map(m => `
              <li>
                <span class="name">${m.name}${m.qty > 1 ? ` (${m.qty} pháº§n)` : ''}</span>
                <span class="value" style="color: var(--accent-red);">-${formatMoney(m.due)}</span>
              </li>
            `).join('')}
          </ul>
        ` : '<div class="empty-state"><div class="empty-state-icon">âœ…</div>Táº¥t cáº£ Ä‘Ã£ thanh toÃ¡n</div>'}
      </div>
    </div>
  `;

      document.getElementById('summarySection').innerHTML = summaryHTML;

      // Generate Final Message - Show VIP balance AFTER deduction
      const vipLine = vipMap.size > 0
        ? Array.from(vipMap.entries()).map(([name, bal]) => {
          // Check if this VIP was in the order
          const wasCharged = vipChanged.has(name);
          return `${name} (${formatMoney(bal)})`;
        }).join(', ')
        : 'â€”';

      const memLine = members.length > 0
        ? members.map(m => `${m.name}${m.qty > 1 ? ` (${m.qty} pháº§n)` : ''} (-${formatMoney(m.due)})`).join(', ')
        : 'â€”';

      const priceLine = canSplitShip
        ? `${formatMoney(priceNonShip)} ko ship | ${formatMoney(priceShip)} cÃ³ ship (ship ${shipCount} pháº§n, phÃ­ ${formatMoney(shipFee)})`
        : `${formatMoney(sellingPrice)}/pháº§n`;

      const finalMsg = `ğŸ½ ${itemName}: ${priceLine}\nğŸ‘‘ VIP: ${vipLine}\nğŸ‘¥ Member (chÆ°a tráº£): ${memLine}`;

      document.getElementById('finalMsg').value = finalMsg;

      if (saveHistory) {
        // Update VIP storage
        const vipText = vipToText(vipMap);
        document.getElementById('vipArea').value = vipText;
        persistVipList(vipText);

        if (skipSave) {
          if (!silent) {
            alert('â„¹ï¸ ÄÆ¡n nÃ y Ä‘Ã£ Ä‘Æ°á»£c lÆ°u trÆ°á»›c Ä‘Ã³, khÃ´ng lÆ°u trÃ¹ng.');
          } else {
            setDraftBanner('â„¹ï¸ ÄÆ¡n nÃ y Ä‘Ã£ Ä‘Æ°á»£c lÆ°u trÆ°á»›c Ä‘Ã³');
          }
        } else if (nameCorrections.length > 0) {
          const correctionMsg = nameCorrections
            .map(c => `â€¢ "${c.input}" â†’ "${c.corrected}"`)
            .join('\n');
          if (!silent) {
            alert(`âœ… ÄÃ£ lÆ°u Ä‘Æ¡n!\n\nğŸ”„ Smart matching Ä‘Ã£ tá»± Ä‘á»™ng sá»­a tÃªn:\n${correctionMsg}`);
          } else {
            setDraftBanner('âœ… ÄÃ£ lÆ°u Ä‘Æ¡n (Ä‘Ã£ sá»­a tÃªn smart matching)');
          }
        } else if (!silent) {
          alert('âœ… ÄÃ£ lÆ°u Ä‘Æ¡n vÃ o lá»‹ch sá»­!');
        } else {
          setDraftBanner('âœ… ÄÃ£ lÆ°u Ä‘Æ¡n vÃ o lá»‹ch sá»­');
        }

        // Rollback: do not auto recompute VIP balances

        // Clear pricing fields after successful save
        clearPricingFields();
      } else {
        setDraftBanner('â„¹ï¸ ÄÃ£ tÃ­nh táº¡m, báº¥m "LÆ°u Ä‘Æ¡n" Ä‘á»ƒ ghi vÃ o lá»‹ch sá»­');

        // Also clear pricing fields even if not saving to history
        clearPricingFields();
      }

      return { order, saved: savedToHistory || skipSave, signature: orderSignature };
    }

    // Clear pricing fields after compute
    function clearPricingFields() {
      document.getElementById('totalCost').value = '0';
      document.getElementById('costPerUnit').value = '0';
      document.getElementById('shipFee').value = '0';
      document.getElementById('targetProfit').value = '6'; // Default
      document.getElementById('desiredPrice').value = '';
      document.getElementById('priceSuggestion').innerHTML = '';
    }

    // Generate Open Order Message
    function generateOpenMsg() {
      const select = document.getElementById('quickOrderSelect');
      const qtyInput = document.getElementById('quickOrderQty');
      const fallbackName = document.getElementById('itemName')?.value.trim() || 'MÃ³n Äƒn';
      const itemName = select && select.value ? select.value : fallbackName;
      const qty = Math.max(1, Number(qtyInput?.value || 1));

      document.getElementById('openMsg').value = `${itemName} +${qty} order`;
    }

    // Reset Output
    function resetOutput() {
      document.getElementById('summarySection').innerHTML = '';
      document.getElementById('finalMsg').value = '';
      document.getElementById('openMsg').value = '';
      document.getElementById('priceSuggestion').innerHTML = '';
      const desiredPriceInput = document.getElementById('desiredPrice');
      if (desiredPriceInput) desiredPriceInput.value = '';
      selectedPrice = null;
    }

    // Copy Message
    function copyMsg(id, event) {
      const ta = document.getElementById(id);
      ta.select();
      ta.setSelectionRange(0, 99999);

      try {
        document.execCommand('copy');

        if (event && event.target) {
          const btn = event.target;
          const originalText = btn.textContent;
          btn.textContent = 'âœ“ ÄÃ£ copy!';
          setTimeout(() => {
            btn.textContent = originalText;
          }, 2000);
        } else {
          alert('âœ… ÄÃ£ copy!');
        }
      } catch (err) {
        alert('Vui lÃ²ng copy thá»§ cÃ´ng báº±ng Ctrl+C');
      }
    }

    function copyAndSaveFinalMsg(event) {
      const finalMsgArea = document.getElementById('finalMsg');
      const hasMessage = finalMsgArea.value.trim().length > 0;
      const isUnsaved = lastComputedSignature !== lastSavedSignature;

      if (!hasMessage || isUnsaved) {
        const res = compute({ save: true, silent: true, skipIfUnchanged: true });
        if (!res) return;
      }

      copyMsg('finalMsg', event);
    }

    // ========== Order History Filters ==========

    let historyFilters = {
      fromDate: null,
      toDate: null,
      vip: '',
      itemName: ''
    };

    function populateVIPFilterDropdown() {
      const select = document.getElementById('filterVIP');
      if (!select) return;

      // Get unique VIP names from orders
      const vipNames = new Set();
      orderHistory.forEach(order => {
        if (order.details && Array.isArray(order.details)) {
          order.details.forEach(detail => {
            if (detail.name) vipNames.add(detail.name);
          });
        }
      });

      // Also add from VIP list
      const vipArea = document.getElementById('vipArea');
      if (vipArea) {
        const vipMap = parseVip(vipArea.value);
        vipMap.forEach((_, name) => vipNames.add(name));
      }

      // Populate dropdown
      const options = '<option value="">Táº¥t cáº£</option>' +
        Array.from(vipNames).sort().map(name =>
          `<option value="${name}">${name}</option>`
        ).join('');
      select.innerHTML = options;
    }

    function applyHistoryFilters() {
      // Get filter values
      historyFilters.fromDate = document.getElementById('filterFromDate').value;
      historyFilters.toDate = document.getElementById('filterToDate').value;
      historyFilters.vip = document.getElementById('filterVIP').value;
      historyFilters.itemName = document.getElementById('filterItem').value.toLowerCase();

      // Re-render with filters
      renderHistory();

      // Update summary
      updateFilterSummary();
    }

    function clearHistoryFilters() {
      document.getElementById('filterFromDate').value = '';
      document.getElementById('filterToDate').value = '';
      document.getElementById('filterVIP').value = '';
      document.getElementById('filterItem').value = '';

      historyFilters = {
        fromDate: null,
        toDate: null,
        vip: '',
        itemName: ''
      };

      renderHistory();
      updateFilterSummary();
    }

    function updateFilterSummary() {
      const summary = document.getElementById('filterSummary');
      if (!summary) return;

      const activeFilters = [];
      if (historyFilters.fromDate) activeFilters.push(`Tá»« ${historyFilters.fromDate}`);
      if (historyFilters.toDate) activeFilters.push(`Ä‘áº¿n ${historyFilters.toDate}`);
      if (historyFilters.vip) activeFilters.push(`VIP: ${historyFilters.vip}`);
      if (historyFilters.itemName) activeFilters.push(`MÃ³n: ${historyFilters.itemName}`);

      if (activeFilters.length > 0) {
        summary.textContent = 'ğŸ” ' + activeFilters.join(' â€¢ ');
      } else {
        summary.textContent = '';
      }
    }

    function filterOrderHistory(orders) {
      return orders.filter(order => {
        // Date filter
        if (historyFilters.fromDate || historyFilters.toDate) {
          const orderDate = new Date(order.date || order.id);
          const orderDateStr = orderDate.toISOString().split('T')[0];

          if (historyFilters.fromDate && orderDateStr < historyFilters.fromDate) {
            return false;
          }
          if (historyFilters.toDate && orderDateStr > historyFilters.toDate) {
            return false;
          }
        }

        // VIP filter
        if (historyFilters.vip) {
          const hasVIP = order.details && order.details.some(d => d.name === historyFilters.vip);
          if (!hasVIP) return false;
        }

        // Item name filter
        if (historyFilters.itemName) {
          const itemMatch = order.itemName && order.itemName.toLowerCase().includes(historyFilters.itemName);
          if (!itemMatch) return false;
        }

        return true;
      });
    }

    // Render History
    function renderHistory() {
      const historyList = document.getElementById('historyList');

      if (orderHistory.length === 0) {
        historyList.innerHTML = '<div class="empty-state"><div class="empty-state-icon">ğŸ“­</div>ChÆ°a cÃ³ Ä‘Æ¡n hÃ ng nÃ o</div>';
        refreshQuickOrderList();
        return;
      }

      // Apply filters
      const filteredOrders = filterOrderHistory(orderHistory);

      if (filteredOrders.length === 0) {
        historyList.innerHTML = '<div class="empty-state">âŒ KhÃ´ng tÃ¬m tháº¥y Ä‘Æ¡n hÃ ng nÃ o phÃ¹ há»£p vá»›i bá»™ lá»c</div>';
        refreshQuickOrderList();
        return;
      }


      // Sort by most recent first (descending order by date)
      const sortedOrders = filteredOrders.sort((a, b) => {
        const dateA = new Date(a.date || a.id);
        const dateB = new Date(b.date || b.id);
        return dateB - dateA; // Descending: newest first
      });

      historyList.innerHTML = sortedOrders.map(order => {
        const paidCount = order.details.filter(d => d?.paid === true).length;
        const totalCount = order.details.length;
        const statusClass = paidCount === totalCount ? 'status-paid' : (paidCount > 0 ? 'status-partial' : 'status-unpaid');
        const statusText = paidCount === totalCount ? 'ÄÃ£ thanh toÃ¡n' : `${paidCount}/${totalCount} Ä‘Ã£ tráº£`;
        const historyPriceLine = order.splitShipMode
          ? `${order.nonShipCount || 0}Ã—${formatMoney(order.sellingPriceNonShip || order.sellingPrice)} + ${order.shipCount || 0}Ã—${formatMoney(order.sellingPriceShip || order.sellingPrice)}`
          : `${order.totalParts} pháº§n Ã— ${formatMoney(order.sellingPrice)}`;

        return `
      <div class="history-item" onclick="showOrderDetail(${order.id})">
        <div class="history-header">
          <div class="history-title">${order.itemName}</div>
          <div class="history-date">${formatDate(order.date)}</div>
        </div>
        <div class="history-details">
          ${historyPriceLine} = ${formatMoney(order.revenue)} 
          <span class="${order.profit >= 0 ? 'profit-positive' : 'profit-negative'}">
            (${order.profit >= 0 ? 'Lá»i' : 'Lá»—'} ${formatMoney(Math.abs(order.profit))})
          </span>
          <span class="status-badge ${statusClass}">${statusText}</span>
        </div>
      </div>
    `;
      }).join('');
      refreshQuickOrderList();
    }

    // Backward-compatible alias for legacy calls
    function loadHistory() {
      renderHistory();
    }

    function showOrderDetail(orderId) {
      const order = orderHistory.find(o => o.id === orderId);
      if (!order) return;
      activeOrderModalId = orderId;

      const modalBody = document.getElementById('modalBody');
      const modalPriceLabel = order.splitShipMode
        ? `Ko ship ${formatMoney(order.sellingPriceNonShip || order.sellingPrice)} | Ship ${formatMoney(order.sellingPriceShip || order.sellingPrice)}`
        : `${formatMoney(order.sellingPrice)}/pháº§n`;

      modalBody.innerHTML = `
    <div class="form-group">
      <label class="form-label">TÃªn mÃ³n</label>
      <div style="font-size: 18px; font-weight: 600; color: var(--text-primary);">${order.itemName}</div>
    </div>

    <div class="form-row">
      <div class="form-group">
        <label class="form-label">NgÃ y giá»</label>
        <div style="color: var(--text-primary);">${formatDate(order.date)}</div>
      </div>
      <div class="form-group">
        <label class="form-label">GiÃ¡ bÃ¡n</label>
        <div style="color: var(--text-primary);">${modalPriceLabel}</div>
      </div>
    </div>

    <div class="summary-grid" style="margin: 20px 0;">
      <div class="summary-item">
        <h3>Tá»•ng chi</h3>
        <div class="summary-value">${formatMoney(order.totalCost)}</div>
      </div>
      <div class="summary-item">
        <h3>Thu vá»</h3>
        <div class="summary-value">${formatMoney(order.revenue)}</div>
      </div>
      <div class="summary-item">
        <h3>Káº¿t quáº£</h3>
        <div class="summary-value ${order.profit >= 0 ? 'profit-positive' : 'profit-negative'}">
          ${order.profit >= 0 ? 'Lá»i' : 'Lá»—'} ${formatMoney(Math.abs(order.profit))}
        </div>
      </div>
    </div>

    <div class="form-group">
      <label class="form-label">Danh sÃ¡ch order</label>
      <div class="table-wrapper">
        <table class="table">
          <thead>
              <tr>
                <th>TÃªn</th>
                <th style="text-align: right;">Sá»‘ pháº§n</th>
                <th style="text-align: right;">ÄÆ¡n giÃ¡</th>
                <th style="text-align: right;">Ship</th>
                <th style="text-align: right;">ThÃ nh tiá»n</th>
                <th style="text-align: center;">Tráº¡ng thÃ¡i</th>
              </tr>
            </thead>
            <tbody>
	              ${order.details.map(d => `
	              <tr>
	                <td>${d.name}</td>
	                <td style="text-align: right;">${d.qty}</td>
	                <td style="text-align: right;">${typeof d.unitPrice === 'string' ? d.unitPrice : formatMoney(d.unitPrice || order.sellingPrice)}</td>
	                <td style="text-align: right;">${d.shipQty ? `${d.shipQty} ğŸšš` : '0'}</td>
	                <td style="text-align: right;">${formatMoney(d.due)}</td>
	                <td style="text-align: center;">
	                  <span class="status-badge ${d.paid === true ? 'status-paid' : 'status-unpaid'}">
	                    ${d.paid === true ? 'ÄÃ£ tráº£' : 'ChÆ°a tráº£'}
	                  </span>
	                </td>
	              </tr>
	            `).join('')}
          </tbody>
        </table>
      </div>
    </div>

    <div class="btn-group" style="margin-top: 20px;">
      <button class="btn btn-secondary" onclick="editOrder(${order.id})">âœï¸ Chá»‰nh sá»­a Ä‘Æ¡n</button>
      <button class="btn btn-info" onclick="markAllPaid(${order.id})">âœ“ ÄÃ¡nh dáº¥u táº¥t cáº£ Ä‘Ã£ tráº£</button>
      <button class="btn btn-danger" onclick="deleteOrder(${order.id})">ğŸ—‘ï¸ XoÃ¡ Ä‘Æ¡n nÃ y</button>
    </div>
  `;

      document.getElementById('orderModal').classList.add('active');
    }

    function editOrder(orderId) {
      const order = orderHistory.find(o => o.id === orderId);
      if (!order) return;

      editingOrderId = orderId;
      editingOrderDate = order.date;
      closeModal();

      const newOrderTab = document.querySelector('.tab[onclick*="newOrder"]');
      switchTab({ currentTarget: newOrderTab }, 'newOrder');

      document.getElementById('itemName').value = order.itemName || '';
      const totalPartsValue = order.totalParts || order.nonShipCount + order.shipCount || '';
      document.getElementById('n').value = totalPartsValue;
      document.getElementById('alvinFree').checked = !!order.alvinFree;
      document.getElementById('shipFee').value = order.shipFee || 0;

      const totalCostInputValue = order.totalCostInput !== undefined
        ? order.totalCostInput
        : Math.max((order.totalCost || 0) - (order.shipFee || 0), 0);
      document.getElementById('totalCost').value = totalCostInputValue ?? 0;
      document.getElementById('costPerUnit').value = order.costPerUnitInput ?? 0;

      const targetProfitInputEl = document.getElementById('targetProfit');
      if (targetProfitInputEl) {
        targetProfitInputEl.value = order.targetProfit !== undefined ? order.targetProfit : (targetProfitInputEl.value || 0);
      }

      const desiredPriceInput = document.getElementById('desiredPrice');
      const desiredPriceValue = order.desiredPriceInput ?? order.sellingPriceNonShip ?? order.sellingPrice ?? '';
      if (desiredPriceInput) desiredPriceInput.value = desiredPriceValue;
      selectedPrice = desiredPriceValue ? Number(desiredPriceValue) : null;

      const itemDescInput = document.getElementById('itemDesc');
      if (itemDescInput) itemDescInput.value = order.itemDesc || '';
      const deadlineInput = document.getElementById('deadline');
      if (deadlineInput) deadlineInput.value = order.deadline || '';

      const people = (order.details || []).map(d => ({
        name: d.name,
        qty: d.qty,
        shipParts: d.shipQty || d.shipParts || 0,
        paid: d.paid
      }));
      applyPeopleToTable(people);

      markDraftChanged();
      setDraftBanner('âœï¸ Äang chá»‰nh sá»­a Ä‘Æ¡n tá»« lá»‹ch sá»­. Báº¥m "LÆ°u Ä‘Æ¡n" Ä‘á»ƒ cáº­p nháº­t.');
    }

    function closeModal(id) {
      const targetId = id || 'orderModal';
      const el = document.getElementById(targetId);
      if (el) el.classList.remove('active');
      if (targetId === 'orderModal') activeOrderModalId = null;
    }

    function deleteOrder(orderId) {
      if (!confirm('XÃ¡c nháº­n xoÃ¡ Ä‘Æ¡n hÃ ng nÃ y?')) return;

      orderHistory = orderHistory.filter(o => o.id !== orderId);
      localStorage.setItem('orderHistory', JSON.stringify(orderHistory));

      closeModal();
      loadHistory();
      alert('âœ… ÄÃ£ xoÃ¡ Ä‘Æ¡n hÃ ng');
    }

    function markAllPaid(orderId) {
      const order = orderHistory.find(o => o.id === orderId);
      if (!order) return;

      order.details.forEach(d => d.paid = true);
      localStorage.setItem('orderHistory', JSON.stringify(orderHistory));

      showOrderDetail(orderId);
      alert('âœ… ÄÃ£ Ä‘Ã¡nh dáº¥u táº¥t cáº£ Ä‘Ã£ thanh toÃ¡n');
    }

    function openPaymentMethodModal(options) {
      const { title, info, onConfirm } = options;
      const modal = document.getElementById('paymentMethodModal');
      const titleEl = document.getElementById('paymentModalTitle');
      const infoEl = document.getElementById('paymentModalInfo');
      const selectEl = document.getElementById('paymentMethodSelect');
      const confirmBtn = document.getElementById('paymentModalConfirmBtn');

      if (titleEl) titleEl.textContent = title || 'Chá»n phÆ°Æ¡ng thá»©c thanh toÃ¡n';
      if (infoEl) infoEl.textContent = info || '';
      if (selectEl) selectEl.value = 'cash'; // Default to cash

      confirmBtn.onclick = () => {
        const method = selectEl.value;
        closeModal('paymentMethodModal');
        if (onConfirm) onConfirm(method);
      };

      modal.classList.add('active');
    }

    function markDebtorPaid(name) {
      console.log(`[${BUILD_TAG}] markDebtorPaid`);
      if (!name) return;
      const target = name.trim();
      const changes = [];
      let totalCleared = 0;

      orderHistory.forEach(order => {
        order.details.forEach((d, idx) => {
          if (d?.paid !== true && d?.name === target) {
            changes.push({ orderId: order.id, detailIndex: idx, due: d.due });
            totalCleared += d.due;
          }
        });
      });

      if (changes.length === 0) {
        alert('â„¹ï¸ KhÃ´ng tháº¥y cÃ´ng ná»£ cáº§n cáº­p nháº­t cho ngÆ°á»i nÃ y');
        return;
      }

      openPaymentMethodModal({
        title: `Tráº£ háº¿t ná»£ cho ${target}`,
        info: `Tá»•ng cá»™ng: ${formatMoney(totalCleared)} (${changes.length} Ä‘Æ¡n chÆ°a thanh toÃ¡n)`,
        onConfirm: (paymentMethod) => {
          const vipArea = document.getElementById('vipArea');
          const vipMap = vipArea ? parseVip(vipArea.value) : new Map();
          const hasVip = vipMap.has(target);

          // Mark as paid
          changes.forEach(change => {
            const order = orderHistory.find(o => o.id === change.orderId);
            if (order && order.details[change.detailIndex]) {
              if (paymentMethod === 'vip') {
                order.details[change.detailIndex].isVipPayment = true;
                order.details[change.detailIndex].paymentMethod = 'vip';
                order.details[change.detailIndex].paid = true;
                const existingTx = vipTransactions.find(tx =>
                  tx.type === 'order' &&
                  tx.orderId === order.id &&
                  tx.name === target &&
                  tx.detailIndex === change.detailIndex
                );
                if (!existingTx) {
                  recordVipTransaction({
                    name: target,
                    amount: -change.due,
                    type: 'order',
                    itemName: order.itemName,
                    orderId: order.id,
                    detailIndex: change.detailIndex,
                    isVipPayment: true,
                    paymentMethod: 'vip'
                  });
                }
              } else {
                order.details[change.detailIndex].isVipPayment = false;
                order.details[change.detailIndex].paymentMethod = 'cash';
                order.details[change.detailIndex].paid = true;
              }
            }
          });

          if (paymentMethod === 'vip') {
            if (hasVip) {
              vipMap.set(target, Number(vipMap.get(target) || 0) - Number(totalCleared || 0));
            } else {
              // User chose VIP but is not in VIP list - add them with negative balance
              vipMap.set(target, -Number(totalCleared || 0));
            }
            const vipText = vipToText(vipMap);
            if (vipArea) vipArea.value = vipText;
            persistVipList(vipText);
          }

          lastDebtorPaidSnapshot = { name: target, changes };
          localStorage.setItem('orderHistory', JSON.stringify(orderHistory));
          loadDebtManagement();
          loadHistory();
          if (activeOrderModalId !== null) showOrderDetail(activeOrderModalId);
          renderVipHistory();
          populateVipMemberSelect();

          const paymentText = paymentMethod === 'vip' ? 'tá»« VIP' : 'báº±ng tiá»n máº·t';
          alert(`âœ… ÄÃ£ Ä‘Ã¡nh dáº¥u ${target} Ä‘Ã£ tráº£ háº¿t ná»£ ${paymentText}\nTá»•ng: ${formatMoney(totalCleared)}`);
        }
      });
    }

    function markSingleDebtPaid(orderId, detailIndex, name) {
      console.log(`[${BUILD_TAG}] markSingleDebtPaid`);
      const order = orderHistory.find(o => o.id === orderId);
      if (!order || !order.details?.[detailIndex]) return;

      const detail = order.details[detailIndex];
      if (detail.paid === true) {
        alert('â„¹ï¸ Má»¥c nÃ y Ä‘Ã£ Ä‘Æ°á»£c Ä‘Ã¡nh dáº¥u tráº£ rá»“i');
        return;
      }

      const target = (name || detail.name).trim();

      openPaymentMethodModal({
        title: `ÄÃ¡nh dáº¥u Ä‘Ã£ tráº£ cho ${target}`,
        info: `${order.itemName} - ${formatMoney(detail.due)} (${detail.qty} pháº§n)`,
        onConfirm: (paymentMethod) => {
          const vipArea = document.getElementById('vipArea');
          const vipMap = vipArea ? parseVip(vipArea.value) : new Map();
          const hasVip = vipMap.has(target);

          if (paymentMethod === 'vip') {
            const existingTx = vipTransactions.find(tx =>
              tx.type === 'order' &&
              tx.orderId === order.id &&
              tx.name === target &&
              tx.detailIndex === detailIndex
            );

            if (!existingTx) {
              recordVipTransaction({
                name: target,
                amount: -detail.due,
                type: 'order',
                itemName: order.itemName,
                orderId: order.id,
                detailIndex,
                isVipPayment: true,
                paymentMethod: 'vip'
              });
            }
            detail.isVipPayment = true;
            detail.paymentMethod = 'vip';
          } else {
            detail.isVipPayment = false;
            detail.paymentMethod = 'cash';
          }

          detail.paid = true;

          if (paymentMethod === 'vip') {
            if (hasVip) {
              vipMap.set(target, Number(vipMap.get(target) || 0) - Number(detail.due || 0));
            } else {
              // User chose VIP but is not in VIP list - add them with negative balance
              vipMap.set(target, -Number(detail.due || 0));
            }
            const vipText = vipToText(vipMap);
            if (vipArea) vipArea.value = vipText;
            persistVipList(vipText);
          }

          lastDebtorPaidSnapshot = {
            name: target,
            changes: [{ orderId, detailIndex, due: detail.due }]
          };

          localStorage.setItem('orderHistory', JSON.stringify(orderHistory));
          loadDebtManagement();
          loadHistory();
          if (activeOrderModalId !== null) showOrderDetail(activeOrderModalId);
          renderVipHistory();
          populateVipMemberSelect();

          const paymentText = paymentMethod === 'vip' ? 'tá»« VIP' : 'báº±ng tiá»n máº·t';
          alert(`âœ… ÄÃ£ Ä‘Ã¡nh dáº¥u Ä‘Ã£ tráº£ ${paymentText}`);
        }
      });
    }

    function undoLastDebtorPaid() {
      if (!lastDebtorPaidSnapshot || !lastDebtorPaidSnapshot.changes?.length) {
        alert('â„¹ï¸ KhÃ´ng cÃ³ thao tÃ¡c nÃ o Ä‘á»ƒ hoÃ n tÃ¡c');
        return;
      }

      const { name, changes } = lastDebtorPaidSnapshot;

      // Check if this person has VIP - if so, refund the amount
      const vipMap = parseVip(document.getElementById('vipArea').value);
      const hasVIP = vipMap.has(name);

      if (hasVIP) {
        const currentBalance = vipMap.get(name);
        let totalRefund = 0;

        changes.forEach(change => {
          if (change.due) {
            totalRefund += change.due;
          }
        });

        // Refund to VIP balance
        const newBalance = currentBalance + totalRefund;
        vipMap.set(name, newBalance);

        // Update VIP textarea and persist
        const vipText = vipToText(vipMap);
        document.getElementById('vipArea').value = vipText;
        persistVipList(vipText);
      }

      // Mark as unpaid
      changes.forEach(change => {
        const order = orderHistory.find(o => o.id === change.orderId);
        if (order && order.details[change.detailIndex]) {
          order.details[change.detailIndex].paid = false;
        }
      });

      localStorage.setItem('orderHistory', JSON.stringify(orderHistory));
      loadDebtManagement();
      loadHistory();
      renderVipHistory();
      populateVipMemberSelect();

      const refundText = hasVIP ? ' (Ä‘Ã£ hoÃ n tiá»n vÃ o VIP)' : '';
      alert(`â†©ï¸ ÄÃ£ hoÃ n tÃ¡c Ä‘Ã¡nh dáº¥u Ä‘Ã£ tráº£ cho ${name}${refundText}`);
      lastDebtorPaidSnapshot = null;
    }

    // Export helper for manual use and automation
    function exportForAutomation(options = {}) {
      const { download = true, silent = false } = options;

      try {
        const stored = localStorage.getItem('orderHistory');
        const parsed = stored ? JSON.parse(stored) : [];
        const filename = `order_history_${new Date().toISOString().split('T')[0]}.json`;
        const content = JSON.stringify(parsed, null, 2);

        if (download) {
          const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(content);
          const linkElement = document.createElement('a');
          linkElement.setAttribute('href', dataUri);
          linkElement.setAttribute('download', filename);
          document.body.appendChild(linkElement);
          linkElement.click();
          document.body.removeChild(linkElement);
        }

        const result = { success: true, filename, count: parsed.length, content };
        window.__autobackupResult = result;
        return result;
      } catch (error) {
        const result = { success: false, error: error.message };
        window.__autobackupResult = result;
        if (!silent) {
          alert('âŒ Lá»—i export: ' + error.message);
        }
        return result;
      }
    }

    function exportHistory() {
      const res = exportForAutomation({ download: true, silent: true });
      if (!res.success) {
        alert('âŒ KhÃ´ng thá»ƒ export: ' + res.error);
      }
    }

    function clearHistory() {
      if (!confirm('XÃ¡c nháº­n xoÃ¡ toÃ n bá»™ lá»‹ch sá»­ Ä‘Æ¡n hÃ ng?')) return;

      orderHistory = [];
      localStorage.setItem('orderHistory', JSON.stringify(orderHistory));
      refreshQuickOrderList();
      loadHistory();
      alert('âœ… ÄÃ£ xoÃ¡ toÃ n bá»™ lá»‹ch sá»­');
    }

    // Debt Management
    function loadDebtManagement() {
      const debtMap = new Map();

      orderHistory.forEach(order => {
        order.details.forEach((d, detailIndex) => {
          if (d?.paid !== true) {
            const current = debtMap.get(d.name) || { total: 0, orders: [] };
            current.total += d.due;
            current.orders.push({
              orderId: order.id,
              itemName: order.itemName,
              date: order.date,
              detailIndex,
              qty: d.qty,
              due: d.due
            });
            debtMap.set(d.name, current);
          }
        });
      });

      // Summary
      const totalDebt = Array.from(debtMap.values()).reduce((sum, d) => sum + d.total, 0);
      const debtorCount = debtMap.size;

      const summaryHTML = `
    <div class="stats-grid">
      <div class="stat-card">
        <div class="stat-icon">ğŸ’°</div>
        <div class="stat-value">${formatMoney(totalDebt)}</div>
        <div class="stat-label">Tá»•ng cÃ´ng ná»£</div>
      </div>
      <div class="stat-card">
        <div class="stat-icon">ğŸ‘¥</div>
        <div class="stat-value">${debtorCount}</div>
        <div class="stat-label">NgÆ°á»i Ä‘ang ná»£</div>
      </div>
    </div>
  `;

      document.getElementById('debtSummary').innerHTML = summaryHTML;

      // Details
      if (debtMap.size === 0) {
        document.getElementById('debtDetails').innerHTML = '<div class="empty-state"><div class="empty-state-icon">âœ…</div>KhÃ´ng cÃ³ cÃ´ng ná»£</div>';
        return;
      }

      const undoBtn = `
    <div class="btn-group" style="margin-bottom: 12px;">
      <button class="btn btn-info" onclick="undoLastDebtorPaid()">â†©ï¸ HoÃ n tÃ¡c láº§n cuá»‘i</button>
    </div>
  `;

      const detailsHTML = undoBtn + Array.from(debtMap.entries())
        .sort((a, b) => b[1].total - a[1].total)
        .map(([name, data]) => `
      <div class="glass-card" style="margin-bottom: 16px; padding: 20px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
          <div>
            <div style="font-size: 20px; font-weight: 700; color: var(--text-primary);">${name}</div>
            <div style="font-size: 14px; color: var(--text-muted);">${data.orders.length} Ä‘Æ¡n chÆ°a thanh toÃ¡n</div>
          </div>
	          <div style="text-align: right;">
	            <div style="font-size: 24px; font-weight: 700; color: var(--accent-red);">${formatMoney(data.total)}</div>
	            <button class="btn btn-primary" style="margin-top: 8px;" onclick='markDebtorPaid(${JSON.stringify(name)})'>Tráº£ háº¿t</button>
	          </div>
	        </div>

        <div class="table-wrapper">
          <table class="table">
            <thead>
	              <tr>
	                <th>NgÃ y</th>
	                <th>MÃ³n</th>
	                <th style="text-align: right;">Sá»‘ pháº§n</th>
	                <th style="text-align: right;">Tiá»n</th>
	                <th style="text-align: center;">Tráº¡ng thÃ¡i</th>
	                <th style="text-align: center;">HÃ nh Ä‘á»™ng</th>
	              </tr>
	            </thead>
	            <tbody>
	              ${data.orders.map(o => `
	                <tr>
	                  <td onclick="showOrderDetail(${o.orderId})" style="cursor: pointer;">${formatDate(o.date).split(' ')[0]}</td>
	                  <td onclick="showOrderDetail(${o.orderId})" style="cursor: pointer;">${o.itemName}</td>
	                  <td style="text-align: right;" onclick="showOrderDetail(${o.orderId})" style="cursor: pointer;">${o.qty}</td>
	                  <td style="text-align: right;" onclick="showOrderDetail(${o.orderId})" style="cursor: pointer;">${formatMoney(o.due)}</td>
	                  <td style="text-align: center;">
	                    <span class="status-badge status-unpaid">ChÆ°a tráº£</span>
	                  </td>
	                  <td style="text-align: center;">
	                    <button class="btn btn-primary" style="padding: 6px 10px; font-size: 12px;"
	                      onclick='markSingleDebtPaid(${o.orderId}, ${o.detailIndex}, ${JSON.stringify(name)});'>
	                      ÄÃ¡nh dáº¥u Ä‘Ã£ tráº£
	                    </button>
	                  </td>
	                </tr>
	              `).join('')}
	            </tbody>
	          </table>
        </div>
      </div>
    `).join('');

      document.getElementById('debtDetails').innerHTML = detailsHTML;
    }

    // Stats
    function renderStats() {
      if (orderHistory.length === 0) {
        document.getElementById('statsContent').innerHTML = '<div class="empty-state"><div class="empty-state-icon">ğŸ“Š</div>ChÆ°a cÃ³ dá»¯ liá»‡u Ä‘á»ƒ thá»‘ng kÃª</div>';
        return;
      }

      const totalOrders = orderHistory.length;
      const totalRevenue = orderHistory.reduce((sum, o) => sum + o.revenue, 0);
      const totalCost = orderHistory.reduce((sum, o) => sum + o.totalCost, 0);
      const totalProfit = totalRevenue - totalCost;

      const statsHTML = `
    <div class="stats-grid">
      <div class="stat-card">
        <div class="stat-icon">ğŸ“¦</div>
        <div class="stat-value">${totalOrders}</div>
        <div class="stat-label">Tá»•ng Ä‘Æ¡n hÃ ng</div>
      </div>
      <div class="stat-card">
        <div class="stat-icon">ğŸ’µ</div>
        <div class="stat-value">${formatMoney(totalRevenue)}</div>
        <div class="stat-label">Tá»•ng thu</div>
      </div>
      <div class="stat-card">
        <div class="stat-icon">ğŸ’¸</div>
        <div class="stat-value">${formatMoney(totalCost)}</div>
        <div class="stat-label">Tá»•ng chi</div>
      </div>
      <div class="stat-card">
        <div class="stat-icon">${totalProfit >= 0 ? 'ğŸ“ˆ' : 'ğŸ“‰'}</div>
        <div class="stat-value ${totalProfit >= 0 ? 'profit-positive' : 'profit-negative'}">
          ${formatMoney(Math.abs(totalProfit))}
        </div>
        <div class="stat-label">${totalProfit >= 0 ? 'Lá»£i nhuáº­n' : 'Thua lá»—'}</div>
      </div>
    </div>

    <div class="glass-card" style="margin-top: 24px; padding: 20px;">
      <h3 style="font-size: 16px; margin-bottom: 16px; color: var(--text-secondary);">ğŸ½ Top mÃ³n Ä‘Æ°á»£c order nhiá»u nháº¥t</h3>
      ${getTopItems()}
    </div>

    <div class="glass-card" style="margin-top: 24px; padding: 20px;">
      <h3 style="font-size: 16px; margin-bottom: 16px; color: var(--text-secondary);">ğŸ‘¥ Top ngÆ°á»i order nhiá»u nháº¥t</h3>
      ${getTopPeople()}
    </div>

    <div class="glass-card" style="margin-top: 24px; padding: 20px;">
      <h3 style="font-size: 16px; margin-bottom: 16px; color: var(--text-secondary);">ğŸ“‘ BÃ¡o cÃ¡o VIP (náº¡p/rÃºt)</h3>
      <div class="form-group">
        <label class="form-label">Chá»n VIP</label>
        <select id="vipReportSelect" class="form-input"></select>
      </div>
      <div id="vipReportContent" class="info-list"></div>
    </div>
  `;

      document.getElementById('statsContent').innerHTML = statsHTML;
      initVipReportPanel();
    }

    // Backward-compatible alias for stats tab
    function loadStats() { renderStats(); }

    function getTopItems() {
      const itemMap = new Map();

      orderHistory.forEach(order => {
        const current = itemMap.get(order.itemName) || { count: 0, revenue: 0 };
        current.count += 1;
        current.revenue += order.revenue;
        itemMap.set(order.itemName, current);
      });

      const sorted = Array.from(itemMap.entries())
        .sort((a, b) => b[1].count - a[1].count)
        .slice(0, 5);

      if (sorted.length === 0) return '<div class="empty-state-icon">â€”</div>';

      return `
    <ul class="info-list">
      ${sorted.map(([name, data]) => `
        <li>
          <span class="name">${name}</span>
          <span>
            <span class="value">${data.count} láº§n</span>
            <span class="note">${formatMoney(data.revenue)}</span>
          </span>
        </li>
      `).join('')}
    </ul>
  `;
    }

    function getTopPeople() {
      const peopleMap = new Map();

      orderHistory.forEach(order => {
        order.details.forEach(d => {
          const current = peopleMap.get(d.name) || { count: 0, total: 0 };
          current.count += d.qty;
          current.total += d.due;
          peopleMap.set(d.name, current);
        });
      });

      const sorted = Array.from(peopleMap.entries())
        .sort((a, b) => b[1].count - a[1].count)
        .slice(0, 5);

      if (sorted.length === 0) return '<div class="empty-state-icon">â€”</div>';

      return `
    <ul class="info-list">
      ${sorted.map(([name, data]) => `
        <li>
          <span class="name">${name}</span>
          <span>
            <span class="value">${data.count} pháº§n</span>
            <span class="note">${formatMoney(data.total)}</span>
          </span>
        </li>
      `).join('')}
    </ul>
  `;
    }

    function getVipNamesFromTransactions() {
      const names = new Set();
      vipTransactions.forEach(tx => {
        if (tx?.name) names.add(tx.name);
      });
      return Array.from(names).sort((a, b) => a.localeCompare(b, 'vi', { sensitivity: 'base' }));
    }

    function initVipReportPanel() {
      const select = document.getElementById('vipReportSelect');
      const content = document.getElementById('vipReportContent');
      if (!select || !content) return;

      const names = getVipNamesFromTransactions();
      if (names.length === 0) {
        select.innerHTML = '<option value="">ChÆ°a cÃ³ giao dá»‹ch VIP</option>';
        content.innerHTML = '<div class="empty-state" style="padding:12px 0;">ChÆ°a cÃ³ giao dá»‹ch VIP</div>';
        return;
      }

      select.innerHTML = ['<option value="">Chá»n VIP...</option>'].concat(
        names.map(n => `<option value="${n}">${n}</option>`)
      ).join('');

      select.onchange = (e) => {
        renderVipReport(e.target.value);
      };

      renderVipReport(names[0]);
      select.value = names[0];
    }


    // Load VIP on page load
    document.addEventListener('DOMContentLoaded', () => {
      hydrateVipAreaFromData();
      // REMOVED: syncVipListFromLatestSnapshot() - this was overwriting localStorage with old snapshots
      // VIP balances should be managed through transactions only
      const rawVipTx = JSON.parse(localStorage.getItem(VIP_TX_KEY) || '[]');
      vipTransactions = VIP_PATCH_ENABLED ? normalizeVipTransactions(rawVipTx) : rawVipTx;

      // Filter out confirmed duplicate transactions
      const beforeFilterCount = vipTransactions.length;
      vipTransactions = vipTransactions.filter(tx => !CONFIRMED_DELETE_TXN_IDS.includes(tx.id));
      const deletedCount = beforeFilterCount - vipTransactions.length;
      if (deletedCount > 0) {
        console.log(`[Init] Removed ${deletedCount} confirmed duplicate transaction(s)`);
      }

      // Reconcile VIP ledger to ensure consistency
      console.log('[Init] Running VIP ledger reconciliation...');
      const reconcileResult = reconcileVipLedgerFromOrders(orderHistory, vipTransactions);
      if (reconcileResult.changed) {
        console.log('[Init] VIP ledger updated:', reconcileResult.stats);
        vipTransactions = reconcileResult.vipTransactions;
        localStorage.setItem(VIP_TX_KEY, JSON.stringify(vipTransactions));
        // Update orderHistory if details were normalized
        localStorage.setItem('orderHistory', JSON.stringify(orderHistory));
      }

      renderVipHistory();
      refreshQuickOrderList();
      updateDishNameSuggestions();
      loadGithubSettings();
      populateVipMemberSelect();
      populateVIPFilterDropdown(); // Populate filter dropdown
      populateVipReportMembers(); // Populate VIP Report dropdown
      recomputeVipBalances(); // Recompute and render VIP list
      // Enable dish name suggestions dropdown
      const itemNameInput = document.getElementById('itemName');
      if (itemNameInput) {
        ['focus', 'click'].forEach(evt => itemNameInput.addEventListener(evt, openDishSuggestions));
      }

      // Lock VIP textarea to prevent manual editing
      const vipArea = document.getElementById('vipArea');
      if (vipArea) {
        vipArea.setAttribute('readonly', true);
        vipArea.style.cursor = 'not-allowed';
        vipArea.style.opacity = '0.8';
        vipArea.title = 'Chá»‰ cÃ³ thá»ƒ thay Ä‘á»•i qua Náº¡p VIP, Cash Out, hoáº·c Order';
      }

      // ENABLED: Draft autosave (previously disabled due to bridge errors)
      initDraftAutosave();

      // Add listener for alvinFree checkbox to adjust min value of n
      const alvinFreeCheckbox = document.getElementById('alvinFree');
      const nInput = document.getElementById('n');

      if (alvinFreeCheckbox && nInput) {
        alvinFreeCheckbox.addEventListener('change', function () {
          if (this.checked) {
            nInput.min = 2;
            if (Number(nInput.value) < 2) {
              nInput.value = 2;
            }
          } else {
            nInput.min = 1;
          }
        });
      }

      const desiredPriceInput = document.getElementById('desiredPrice');
      if (desiredPriceInput) {
        desiredPriceInput.addEventListener('input', handleDesiredPriceInput);
        desiredPriceInput.addEventListener('change', handleDesiredPriceInput);
      }

      // Auto-backup mode: run export silently after load
      if (autoBackupMode) {
        setTimeout(() => {
          exportForAutomation({ download: false, silent: true });
        }, 1200);
      }

      // Auto-pull from GitHub on load (if configured)
      const githubRepo = localStorage.getItem(GITHUB_REPO_KEY);
      const githubToken = localStorage.getItem(GITHUB_TOKEN_KEY);

      if (githubRepo && githubToken) {
        setTimeout(async () => {
          try {
            addBackupLog('ğŸ”„ Auto-pull on load...');
            const remote = await pullFromGithub();

            if (remote) {
              // Check if remote is newer than local
              const localTimestamp = localStorage.getItem('lastDataTimestamp') || '0';
              const remoteTimestamp = remote.backupTime || remote.timestamp;

              if (remoteTimestamp > localTimestamp) {
                const local = {
                  orderHistory: orderHistory,
                  vipTransactions: vipTransactions
                };

                const merged = mergeData(local, remote.data);
                applyRemoteData(merged);

                // Refresh UI (rollback: no auto normalize/recompute)
                populateVipMemberSelect();
                renderVipHistory();
                loadDebtManagement();
                loadHistory();

                // Save timestamp
                localStorage.setItem('lastDataTimestamp', remoteTimestamp);

                addBackupLog(`âœ… Auto-pull complete: synced ${merged.orderHistory.length} orders`);
              } else {
                addBackupLog('â„¹ï¸ Local data is up to date');
              }
            } else {
              addBackupLog('â„¹ï¸ No remote data found (repo may be empty)');
            }
          } catch (err) {
            // Silently handle expected errors (empty repo, etc)
            if (err.message && err.message.includes('No commit found')) {
              addBackupLog('â„¹ï¸ Repo is empty, will backup on first save');
            } else if (err.message && err.message.includes('Not Found')) {
              addBackupLog('â„¹ï¸ Backup file not found, will create on first backup');
            } else {
              // Log unexpected errors
              console.warn('Auto-pull failed:', err);
              addBackupLog(`âš ï¸ Auto-pull skipped: ${err.message}`);
            }
          }
        }, 2000); // Delay to not block initial load
      }
    });

    // VIP Management Functions
    function addNewVIP() {
      // Open modal
      document.getElementById('vipTopupModal').classList.add('active');
      // Clear previous values
      document.getElementById('vipTopupName').value = '';
      document.getElementById('vipTopupAmount').value = '';
      // Focus on name input
      setTimeout(() => document.getElementById('vipTopupName').focus(), 100);
    }

    function closeVipTopupModal() {
      document.getElementById('vipTopupModal').classList.remove('active');
    }

    function submitVipTopup() {
      const name = document.getElementById('vipTopupName').value.trim();
      const amount = document.getElementById('vipTopupAmount').value;

      if (!name) {
        alert('âš ï¸ Vui lÃ²ng nháº­p tÃªn VIP!');
        document.getElementById('vipTopupName').focus();
        return;
      }

      if (!amount || isNaN(amount) || Number(amount) <= 0) {
        alert('âš ï¸ Sá»‘ tiá»n khÃ´ng há»£p lá»‡!');
        document.getElementById('vipTopupAmount').focus();
        return;
      }

      const vipMap = parseVip(document.getElementById('vipArea').value);
      const currentBalance = vipMap.get(name) || 0;
      const newBalance = currentBalance + Number(amount);

      vipMap.set(name, newBalance);

      const vipText = vipToText(vipMap);
      document.getElementById('vipArea').value = vipText;
      persistVipList(vipText);

      recordVipTransaction({ name: name, amount: Number(amount), type: 'topup' });

      // Close modal
      closeVipTopupModal();

      // Update VIP Report dropdown
      populateVipReportMembers();

      // Show success
      alert(`âœ… ÄÃ£ náº¡p ${formatMoney(Number(amount))} cho ${name}\nSá»‘ dÆ° má»›i: ${formatMoney(newBalance)}`);
    }

    function cashOutVIP() {
      // Parse VIP list
      const vipMap = parseVip(document.getElementById('vipArea').value);

      // Populate dropdown
      const select = document.getElementById('vipCashOutName');
      select.innerHTML = '<option value="">-- Chá»n VIP --</option>';

      for (const [name, balance] of vipMap.entries()) {
        const option = document.createElement('option');
        option.value = name;
        option.textContent = `${name} (${formatMoney(balance)})`;
        select.appendChild(option);
      }

      // Clear previous values
      document.getElementById('vipCashOutCurrentBalance').value = '';
      document.getElementById('vipCashOutAmount').value = '';

      // Open modal
      document.getElementById('vipCashOutModal').classList.add('active');
    }

    function closeVipCashOutModal() {
      document.getElementById('vipCashOutModal').classList.remove('active');
    }

    function updateCashOutBalance() {
      const name = document.getElementById('vipCashOutName').value;
      if (!name) {
        document.getElementById('vipCashOutCurrentBalance').value = '';
        return;
      }

      const vipMap = parseVip(document.getElementById('vipArea').value);
      const balance = vipMap.get(name) || 0;
      document.getElementById('vipCashOutCurrentBalance').value = formatMoney(balance);
    }

    function submitVipCashOut() {
      const name = document.getElementById('vipCashOutName').value;

      if (!name) {
        alert('âš ï¸ Vui lÃ²ng chá»n VIP!');
        return;
      }

      const vipMap = parseVip(document.getElementById('vipArea').value);
      const currentBalance = vipMap.get(name) || 0;

      if (currentBalance <= 0) {
        alert('âš ï¸ VIP nÃ y khÃ´ng cÃ³ sá»‘ dÆ°!');
        return;
      }

      const amountInput = document.getElementById('vipCashOutAmount').value;
      let amount = 0;

      if (!amountInput || amountInput.trim() === '') {
        // RÃºt háº¿t
        amount = currentBalance;
      } else {
        amount = Number(amountInput);
        if (isNaN(amount) || amount <= 0) {
          alert('âš ï¸ Sá»‘ tiá»n khÃ´ng há»£p lá»‡!');
          document.getElementById('vipCashOutAmount').focus();
          return;
        }
        if (amount > currentBalance) {
          alert(`âš ï¸ Sá»‘ tiá»n rÃºt vÆ°á»£t quÃ¡ sá»‘ dÆ° hiá»‡n táº¡i (${formatMoney(currentBalance)})!`);
          document.getElementById('vipCashOutAmount').focus();
          return;
        }
      }

      const newBalance = currentBalance - amount;

      if (newBalance === 0) {
        if (!confirm(`RÃºt háº¿t ${formatMoney(amount)} vÃ  xÃ³a ${name} khá»i danh sÃ¡ch VIP?`)) {
          return;
        }
        vipMap.delete(name);
      } else {
        vipMap.set(name, newBalance);
      }

      const vipText = vipToText(vipMap);
      document.getElementById('vipArea').value = vipText;
      persistVipList(vipText);

      recordVipTransaction({ name: name, amount: amount, type: 'cashout' });

      // Close modal
      closeVipCashOutModal();

      // Update VIP Report dropdown
      populateVipReportMembers();

      // Show success
      if (newBalance === 0) {
        alert(`âœ… ÄÃ£ rÃºt ${formatMoney(amount)} vÃ  xÃ³a ${name} khá»i danh sÃ¡ch VIP`);
      } else {
        alert(`âœ… ÄÃ£ rÃºt ${formatMoney(amount)} cho ${name}\nSá»‘ dÆ° má»›i: ${formatMoney(newBalance)}`);
      }
    }
    function importHistory() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';

      input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            const data = JSON.parse(event.target.result);

            if (!Array.isArray(data)) {
              throw new Error('Invalid format');
            }

            if (confirm(`Báº¡n cÃ³ cháº¯c muá»‘n import ${data.length} Ä‘Æ¡n hÃ ng ?\n\nLÆ°u Ã½: Dá»¯ liá»‡u hiá»‡n táº¡i sáº½ Bá»Š GHI ÄÃˆ!`)) {
              orderHistory = data;
              orderHistory.sort((a, b) => (Date.parse(a?.date) || 0) - (Date.parse(b?.date) || 0));
              localStorage.setItem('orderHistory', JSON.stringify(orderHistory));

              // Reconcile VIP ledger after import
              console.log('[Import] Running VIP ledger reconciliation...');
              const reconcileResult = reconcileVipLedgerFromOrders(orderHistory, vipTransactions);
              if (reconcileResult.changed) {
                console.log('[Import] VIP ledger updated:', reconcileResult.stats);
                vipTransactions = reconcileResult.vipTransactions;
                localStorage.setItem(VIP_TX_KEY, JSON.stringify(vipTransactions));
                localStorage.setItem('orderHistory', JSON.stringify(orderHistory));
              }

              hydrateVipAreaFromData({ forceHistory: true });
              // REMOVED: syncVipListFromLatestSnapshot() - prevents overwriting VIP balances
              refreshQuickOrderList();
              loadHistory();

              const statsMsg = reconcileResult.changed
                ? `\n\nÄá»“ng bá»™ VIP: \n - Táº¡o má»›i: ${reconcileResult.stats.created} \n - Cáº­p nháº­t: ${reconcileResult.stats.updated} \n - XÃ³a trÃ¹ng: ${reconcileResult.stats.deduped} `
                : '';
              alert(`âœ… Import thÃ nh cÃ´ng!${statsMsg} `);
            }
          } catch (err) {
            alert('âŒ File khÃ´ng há»£p lá»‡! Vui lÃ²ng chá»n file JSON Ä‘Ãºng Ä‘á»‹nh dáº¡ng.');
          }
        };

        reader.readAsText(file);
      };

      input.click();
    }

    // Close modal when clicking outside
    document.getElementById('orderModal').addEventListener('click', (e) => {
      if (e.target.id === 'orderModal') {
        closeModal();
      }
    });

    // Dev-only debug helpers
    window.debugUnpaidByName = (name) => {
      const target = (name || '').trim();
      if (!target) return [];
      const out = [];
      (orderHistory || []).forEach(order => {
        (order?.details || []).forEach((d, detailIndex) => {
          if ((d?.name || '').trim() !== target) return;
          if (d?.paid === true) return;
          out.push({
            orderId: order?.id,
            date: order?.date,
            itemName: order?.itemName,
            detailIndex,
            due: d?.due,
            paid: d?.paid
          });
        });
      });
      return out;
    };

    window.debugVipHistory = (name) => {
      const selectedName = (name || '').trim();
      if (!selectedName) return { currentBalance: 0, rows: [] };
      const vipArea = document.getElementById('vipArea');
      const vipMap = vipArea ? parseVip(vipArea.value) : new Map();
      const currentBalance = Number(vipMap.get(selectedName) || 0);

      const orderKeyOf = ({ orderId, detailIndex, name }) => {
        if (orderId === undefined || orderId === null) return null;
        if (detailIndex === undefined || detailIndex === null) return null;
        if (!name) return null;
        return `${String(orderId)}| ${detailIndex}| ${name} `;
      };

      const vipOrderKeysFromTx = new Set();
      (vipTransactions || []).forEach(tx => {
        if (tx.orphan) return;
        if (!tx || tx.type !== 'order') return;
        if (tx.name !== selectedName) return;
        const key = orderKeyOf({ orderId: tx.orderId, detailIndex: tx.detailIndex, name: tx.name });
        if (key) vipOrderKeysFromTx.add(key);
      });

      const orderRows = [];
      const orderKeys = new Set();
      (orderHistory || []).forEach(order => {
        const orderId = order?.id;
        const tsRaw = order?.date || order?.id;
        const date = tsRaw ? new Date(tsRaw) : null;
        if (!date || isNaN(date.getTime())) return;
        (order?.details || []).forEach((detail, detailIndex) => {
          const detailName = (detail?.name || '').trim();
          if (detailName !== selectedName) return;
          if (!detail?.due) return;
          const key = orderKeyOf({ orderId, detailIndex, name: detailName });
          if (key && orderKeys.has(key)) return;
          const isVipPayment =
            detail?.isVipPayment === true ||
            detail?.paymentMethod === 'vip' ||
            (key && vipOrderKeysFromTx.has(key));
          orderRows.push({
            type: 'order',
            ts: date.toISOString(),
            amount: -Math.abs(Number(detail?.due) || 0),
            orderId,
            detailIndex,
            orderKey: key,
            isVipPayment: isVipPayment === true
          });
          if (key) orderKeys.add(key);
        });
      });

      const txRows = [];
      (vipTransactions || []).forEach(tx => {
        if (!tx || tx.name !== selectedName) return;
        if (tx.type === 'topup' || tx.type === 'cashout') {
          txRows.push({ ...tx, orderKey: null, isVipPayment: tx.isVipPayment === true });
          return;
        }
        if (tx.type === 'order') {
          const key = orderKeyOf({ orderId: tx.orderId, detailIndex: tx.detailIndex, name: tx.name });
          if (!key || orderKeys.has(key)) return;
          txRows.push({ ...tx, orderKey: key, isVipPayment: true });
        }
      });

      const all = [...orderRows, ...txRows].sort((a, b) => new Date(a.ts) - new Date(b.ts));
      let runningBalance = currentBalance - all.reduce((sum, tx) => {
        const impactsVip = tx.type === 'topup' || tx.type === 'cashout' || (tx.type === 'order' && tx.isVipPayment === true);
        return impactsVip ? (sum + Number(tx.amount || 0)) : sum;
      }, 0);

      const rows = all.map(tx => {
        const impactsVip = tx.type === 'topup' || tx.type === 'cashout' || (tx.type === 'order' && tx.isVipPayment === true);
        if (impactsVip) runningBalance += Number(tx.amount || 0);
        return { ...tx, impactsVip, balance: runningBalance };
      });

      return { currentBalance, rows };
    };

    // ========== VIP REPORT FUNCTIONS ==========

    /**
     * Build VIP Statement (Ledger Report)
     * @param {string} memberName - VIP member name
     * @param {object} options - { from: dateString, to: dateString }
     * @returns {object} { rows, summary }
     */
    function buildVipStatementRows(memberName, options = {}) {
      if (!memberName) return { rows: [], summary: {} };

      const { from, to } = options;

      // Filter transactions for this member
      let txs = vipTransactions.filter(tx => {
        const name = tx.member || tx.name || '';
        return name.trim() === memberName.trim();
      });

      // Apply date filter if provided
      if (from || to) {
        const fromDate = from ? new Date(from) : null;
        const toDate = to ? new Date(to) : null;

        txs = txs.filter(tx => {
          const txDate = new Date(tx.ts || tx.date || 0);
          if (fromDate && txDate < fromDate) return false;
          if (toDate && txDate > toDate) return false;
          return true;
        });
      }

      // Sort by time ascending
      txs.sort((a, b) => {
        const dateA = new Date(a.ts || a.date || 0);
        const dateB = new Date(b.ts || b.date || 0);
        return dateA - dateB;
      });

      // Build rows with running balance
      const rows = [];
      let running = 0;

      // Summary counters
      let opening = 0;
      let totalTopup = 0;
      let totalOrder = 0;
      let totalCashout = 0;
      let totalAdjustment = 0;

      txs.forEach(tx => {
        const delta = Number(tx.amount) || 0;
        running += delta;

        // Type label mapping
        const typeMap = {
          'opening': 'Opening',
          'topup': 'Náº¡p',
          'order': 'Trá»« Ä‘Æ¡n',
          'cashout': 'RÃºt',
          'adjustment': 'Äiá»u chá»‰nh'
        };
        const typeLabel = typeMap[tx.type] || tx.type || 'KhÃ¡c';

        // Description
        let description = '';
        if (tx.type === 'order') {
          description = `ÄÆ¡n: ${tx.itemName || tx.note || ''} `;
        } else if (tx.type === 'topup') {
          description = tx.note || 'Náº¡p';
        } else if (tx.type === 'cashout') {
          description = tx.note || 'RÃºt';
        } else if (tx.type === 'opening') {
          description = 'Sá»‘ dÆ° Ä‘áº§u ká»³';
        } else if (tx.type === 'adjustment') {
          description = tx.note || 'Äiá»u chá»‰nh';
        } else {
          description = tx.note || tx.itemName || '';
        }

        // Ref
        let ref = '';
        if (tx.refId) {
          ref = tx.refId;
        } else if (tx.orderId && tx.detailIndex != null) {
          ref = `${tx.orderId} -${tx.detailIndex} `;
        } else if (tx.orderId) {
          ref = String(tx.orderId);
        }

        // Date formatting
        const txDate = new Date(tx.ts || tx.date || 0);
        const dateISO = txDate.toISOString();
        const dateLocal = formatDate(txDate.toISOString()).replace(/(\d{2}\/\d{2}\/\d{4})/, '$1') + ' ' +
          txDate.toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit' });

        rows.push({
          dateISO,
          dateLocal,
          typeLabel,
          description: description.trim(),
          delta,
          balanceAfter: running,
          ref,
          txnId: tx.id
        });

        // Update summary
        if (tx.type === 'opening') opening += delta;
        else if (tx.type === 'topup') totalTopup += delta;
        else if (tx.type === 'order') totalOrder += Math.abs(delta);
        else if (tx.type === 'cashout') totalCashout += Math.abs(delta);
        else if (tx.type === 'adjustment') totalAdjustment += delta;
      });

      const summary = {
        opening,
        totalTopup,
        totalOrder,
        totalCashout,
        totalAdjustment,
        ending: running
      };

      return { rows, summary };
    }

    /**
     * Render VIP Report
     */
    function renderVipReport() {
      const memberSelect = document.getElementById('vipReportMember');
      const memberName = memberSelect.value;

      const summaryDiv = document.getElementById('vipReportSummary');
      const table = document.getElementById('vipReportTable');
      const tbody = document.getElementById('vipReportTableBody');
      const emptyDiv = document.getElementById('vipReportEmpty');

      if (!memberName) {
        summaryDiv.style.display = 'none';
        table.style.display = 'none';
        emptyDiv.style.display = 'block';
        return;
      }

      // Get date filters
      const fromDate = document.getElementById('vipReportFromDate').value;
      const toDate = document.getElementById('vipReportToDate').value;

      // Build statement
      const statement = buildVipStatementRows(memberName, { from: fromDate, to: toDate });

      if (statement.rows.length === 0) {
        summaryDiv.style.display = 'none';
        table.style.display = 'none';
        emptyDiv.innerHTML = `< div style = "text-align: center; padding: 40px; color: #999;" > KhÃ´ng cÃ³ giao dá»‹ch nÃ o cho ${memberName}</div > `;
        emptyDiv.style.display = 'block';
        return;
      }

      emptyDiv.style.display = 'none';

      // Render Summary
      const s = statement.summary;
      let summaryHTML = `
        < div style = "font-size: 18px; font-weight: 600; margin-bottom: 16px;" >ğŸ“Š Tá»•ng káº¿t: ${memberName}</div >
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 12px;">
            <div>
              <div style="opacity: 0.9; font-size: 13px;">Opening</div>
              <div style="font-size: 20px; font-weight: 700;">${formatMoney(s.opening)}</div>
            </div>
            <div>
              <div style="opacity: 0.9; font-size: 13px;">Tá»•ng náº¡p</div>
              <div style="font-size: 20px; font-weight: 700; color: #4ade80;">+${formatMoney(s.totalTopup)}</div>
            </div>
            <div>
              <div style="opacity: 0.9; font-size: 13px;">Tá»•ng chi</div>
              <div style="font-size: 20px; font-weight: 700; color: #f87171;">-${formatMoney(s.totalOrder)}</div>
            </div>
            <div>
              <div style="opacity: 0.9; font-size: 13px;">Tá»•ng rÃºt</div>
              <div style="font-size: 20px; font-weight: 700; color: #fbbf24;">-${formatMoney(s.totalCashout)}</div>
            </div>
            `;

      if (s.totalAdjustment !== 0) {
        summaryHTML += `
          <div>
            <div style="opacity: 0.9; font-size: 13px;">Äiá»u chá»‰nh</div>
            <div style="font-size: 20px; font-weight: 700;">${formatMoney(s.totalAdjustment)}</div>
          </div>
        `;
      }

      summaryHTML += `
            <div>
              <div style="opacity: 0.9; font-size: 13px;">Ending Balance</div>
              <div style="font-size: 24px; font-weight: 700;">${formatMoney(s.ending)}</div>
            </div>
          </div>
      `;

      summaryDiv.innerHTML = summaryHTML;
      summaryDiv.style.display = 'block';

      // Sort rows based on current sort order
      // buildVipStatementRows returns data in ASCENDING order (oldest first)
      // We need to reverse it for DESCENDING display (newest first)
      let sortedRows = [...statement.rows];

      console.log('[VIP Report] Sort order:', vipReportSortDesc ? 'DESC (newest first)' : 'ASC (oldest first)');
      console.log('[VIP Report] Original first date:', sortedRows[0]?.dateLocal);
      console.log('[VIP Report] Original last date:', sortedRows[sortedRows.length - 1]?.dateLocal);

      if (vipReportSortDesc) {
        // Descending (newest first) - reverse the array
        sortedRows = sortedRows.reverse();
        console.log('[VIP Report] After reverse - first date:', sortedRows[0]?.dateLocal);
      }


      // Render Table
      const rowsHTML = sortedRows.map((row, idx) => {
        const deltaColor = row.delta >= 0 ? '#4ade80' : '#f87171';
        const deltaSign = row.delta >= 0 ? '+' : '';
        const rowBg = idx % 2 === 0 ? 'rgba(0,0,0,0.02)' : 'transparent';

        return `
        < tr style = "background: ${rowBg}; border-bottom: 1px solid rgba(0,0,0,0.05);" >
            <td style="padding: 10px 8px; font-size: 13px;">${row.dateLocal}</td>
            <td style="padding: 10px 8px;">
              <span style="background: rgba(102, 126, 234, 0.1); padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: 500;">
                ${row.typeLabel}
              </span>
            </td>
            <td style="padding: 10px 8px; font-size: 13px;">${row.description}</td>
            <td style="padding: 10px 8px; text-align: right; font-weight: 600; color: ${deltaColor};">
              ${deltaSign}${formatMoney(row.delta)}
            </td>
            <td style="padding: 10px 8px; text-align: right; font-weight: 700; font-size: 14px;">
              ${formatMoney(row.balanceAfter)}
            </td>
          </tr >
        `;
      }).join('');

      tbody.innerHTML = rowsHTML;
      table.style.display = 'table';
    }

    /**
     * Toggle VIP Report Sort Order (Ascending/Descending by date)
     */
    function toggleVipReportSort() {
      vipReportSortDesc = !vipReportSortDesc;

      // Update icon
      const sortIcon = document.getElementById('sortIcon');
      if (sortIcon) {
        sortIcon.textContent = vipReportSortDesc ? 'ğŸ”½' : 'ğŸ”¼';
      }

      // Re-render the report
      renderVipReport();
    }



    /**
     * Populate VIP Member dropdown for report
     */
    function populateVipReportMembers() {
      const select = document.getElementById('vipReportMember');
      if (!select) return;

      // Get unique members from vipTransactions
      const members = new Set();
      vipTransactions.forEach(tx => {
        const name = (tx.member || tx.name || '').trim();
        if (name) members.add(name);
      });

      const sorted = Array.from(members).sort();

      select.innerHTML = '<option value="">-- Chá»n ngÆ°á»i --</option>' +
        sorted.map(name => `< option value = "${name.replace(/" / g, '&quot;')
          } ">${name}</option>`).join('');
    }

    // ========== VIP REPORT FUNCTIONS ==========

    // ========== VIP REPORT FUNCTIONS ==========

    /**
     * UNIFIED BUILDER: Build VIP Statement from FULL DB
     * Merges orderHistory and vipTransactions to create a complete ledger.
     */
    function buildVipStatementFromDB(memberName, options = {}) {
      const { from, to, includeCashOrders = true, includeOrphans = true } = options;
      const rows = [];
      const meta = { orphans: [] };
      // Helper for compact date if not globally available
      const _compactDate = (d) => {
        const D = new Date(d);
        return [D.getDate(), D.getMonth() + 1, D.getFullYear()].map(n => String(n).padStart(2, '0')).join('/') + ' ' +
          [D.getHours(), D.getMinutes()].map(n => String(n).padStart(2, '0')).join(':');
      };

      const targetName = (memberName || '').trim();
      if (!targetName) return { rows: [], summary: {}, meta };

      const fromDate = from ? new Date(from) : null;
      const toDate = to ? new Date(to) : null;

      // 1. Process Order History (Canonical Orders)
      if (Array.isArray(orderHistory)) {
        orderHistory.forEach(order => {
          if (!order.details || !Array.isArray(order.details)) return;

          order.details.forEach((detail, idx) => {
            const dName = (detail.name || '').trim();
            if (dName !== targetName) return;

            // Extract data
            let ts = order.date ? new Date(order.date) : new Date(Number(order.id));
            if (isNaN(ts.getTime())) ts = new Date(0);

            const itemName = detail.itemName || order.itemName || "";
            const due = Number(detail.due) || 0;
            const paid = !!detail.paid;

            // Payment Method Logic
            let pm = detail.paymentMethod || (detail.isVipPayment ? 'vip' : 'cash');
            if (!pm || !paid) pm = 'cash'; // Default if not paid or unknown

            const isVip = (pm === 'vip' && paid);
            const paymentType = isVip ? 'VIP' : 'Cash';

            // Filter options
            if (!includeCashOrders && !isVip) return;

            const displayAmount = -due;
            const deltaVip = isVip ? -due : 0;
            const ref = `${order.id}-${idx}`;

            rows.push({
              ts: ts,
              tsISO: ts.toISOString(),
              dateLocal: _compactDate(ts),
              name: dName,
              rowType: 'order',
              paymentType: paymentType,
              description: `ÄÆ¡n: ${itemName} (${paymentType} ${formatMoney(displayAmount)})`,
              displayAmount: displayAmount,
              deltaVip: deltaVip,
              balanceAfter: 0,
              ref: ref,
              orderId: order.id,
              detailIndex: idx,
              original: detail
            });
          });
        });
      }

      // 2. Process VIP Transactions (Ledger)
      if (Array.isArray(vipTransactions)) {
        vipTransactions.forEach(tx => {
          if (tx.isDeleted) return; // Skip deleted
          const txName = (tx.member || tx.name || '').trim();
          if (txName !== targetName) return;

          const type = tx.type || 'unknown';

          // Helper to check linkage
          const hasLink = tx.refId || (tx.orderId && tx.detailIndex !== undefined && tx.detailIndex !== null);

          // SKIP Linked Orders (already covered by orderHistory)
          if (type === 'order' && hasLink) {
            return;
          }

          // Handle Orphans (Order tx without link)
          if (type === 'order' && !hasLink) {
            // Orphan logic
            if (!includeOrphans) return;

            const ts = new Date(tx.ts || tx.date || 0);
            rows.push({
              ts: ts,
              tsISO: ts.toISOString(),
              dateLocal: _compactDate(ts),
              name: txName,
              rowType: 'orphan',
              paymentType: 'ORPHAN',
              description: `(Orphan) ${tx.note || 'Missing Link'}`,
              displayAmount: Number(tx.amount) || 0,
              deltaVip: 0, // Requirement: deltaVip = 0
              balanceAfter: 0,
              ref: tx.id,
              txId: tx.id,
              note: 'ORPHAN: missing orderId/detailIndex/refId',
              isOrphan: true
            });
            meta.orphans.push(tx);
            return;
          }

          // Handle Other Types: topup, cashout, opening, adjustment...
          const ts = new Date(tx.ts || tx.date || 0);
          const amount = Number(tx.amount) || 0;
          let deltaVip = amount;

          if (type === 'cashout') {
            // Prompt says: "Cashout: deltaVip = -amount"
            // Assuming DB 'amount' is signed. If user inputs positive, we handle sign elsewhere.
            // If existing data has negative for cashout, we trust it.
            deltaVip = amount;
          }

          let desc = tx.note || tx.type;
          if (type === 'topup') desc = tx.note || 'Náº¡p tiá»n';
          if (type === 'cashout') desc = tx.note || 'RÃºt tiá»n';
          if (type === 'opening') desc = 'Sá»‘ dÆ° Ä‘áº§u ká»³';
          if (type === 'adjustment') desc = tx.note || 'Äiá»u chá»‰nh';

          rows.push({
            ts: ts,
            tsISO: ts.toISOString(),
            dateLocal: _compactDate(ts),
            name: txName,
            rowType: type,
            paymentType: type.toUpperCase(),
            description: desc,
            displayAmount: amount,
            deltaVip: deltaVip,
            balanceAfter: 0,
            ref: tx.id,
            txId: tx.id
          });
        });
      }

      // 3. Filter Date Range (Apply before sort or after? Usually after)
      // Done during generation? No, let's filter now.
      // But Opening should always be included? 
      // Prompt says: "XÃ¢y rows full-history rá»“i sort...".
      // Date filter usually applies to VIEW, but running balance logic needs precise start.
      // IF filtering view, running balance might be wrong if we don't calculate from absolute zero.
      // Prompt requirement: "running = openingAmount (sum tx.type="opening")... For each row: running += deltaVip".
      // This implies the calculation starts from 0 (plus 'opening' tx).
      // If we filter, we must calculate the "balance at 'from' date" first.

      // Let's Sort first
      rows.sort((a, b) => a.ts - b.ts);

      // Calculate Running Balance for ALL rows
      let running = 0;
      let openingBalanceForView = 0;
      let isFirstInView = true;

      // Stats for Summary (only within View?)
      // Usually summary reflects the View Range. But "Ending" is usually absolute Ending.
      // Let's assume standard bank statement logic:
      // Opening Balance (at start of period)
      // + Credits
      // - Debits
      // = Closing Balance (at end of period)

      const viewRows = [];

      // Totals for View
      let viewOpening = 0;
      let viewTopup = 0;
      let viewOrder = 0;
      let viewCashout = 0;
      let viewAdjustment = 0;

      rows.forEach((row, index) => {
        const delta = row.deltaVip;

        // Before applying current delta?
        // running start = 0.
        // row.balanceAfter = running + delta.
        running += delta;
        row.balanceAfter = running;

        // Check Date Filter
        let inRange = true;
        if (fromDate && row.ts < fromDate) inRange = false;
        if (toDate && row.ts > toDate) inRange = false;

        if (inRange) {
          viewRows.push(row);

          // Accumulate stats based on row type
          if (row.rowType === 'opening') {
            // Opening balance transactions contribute to the opening stat
            viewOpening += delta;
          }
          else if (row.rowType === 'topup') viewTopup += delta;
          else if (row.rowType === 'order' && row.paymentType === 'VIP') viewOrder += Math.abs(delta);
          else if (row.rowType === 'cashout') viewCashout += Math.abs(delta);
          else if (row.rowType === 'adjustment') viewAdjustment += delta;
        }
      });

      return {
        rows: viewRows,
        summary: {
          opening: viewOpening, // Sum of all 'opening' type transactions in view
          totalTopup: viewTopup,
          totalOrder: viewOrder, // Spending
          totalCashout: viewCashout,
          totalAdjustment: viewAdjustment,
          ending: running // Absolute Ending Balance (current)
        },
        meta
      };
    }

    // Alias for backward compatibility if needed (but we updated callers)
    // window.buildVipStatementRows = buildVipStatementFromDB; 

    /**
     * Render VIP Report
     */

    /**
     * Self Test: VIP Report from DB
     * Verifies that the report ending balance matches the VIP list balance
     */
    window.selfTest_vipReportFromDB = function () {
      console.log("ğŸ§ª Starting Self-Test: VIP Report From DB...");
      const vipArea = document.getElementById('vipArea');
      if (!vipArea) { console.error("VIP Area not found"); return; }

      const vipList = parseVip(vipArea.value);
      const report = [];
      let failCount = 0;

      vipList.forEach((expected, member) => {
        const statement = buildVipStatementFromDB(member, { includeCashOrders: true });
        const diff = statement.summary.ending - expected;
        const orphanCount = statement.meta.orphans.length;

        const status = Math.abs(diff) < 1 ? "âœ… PASS" : "âŒ FAIL";
        if (status === "âŒ FAIL") failCount++;

        report.push({
          member,
          expected,
          ending: statement.summary.ending,
          diff: parseFloat(diff.toFixed(2)),
          orphans: orphanCount,
          status
        });
      });

      console.table(report);
      if (failCount === 0) console.log("âœ… All VIP balances match report verification!");
      else console.warn(`âš ï¸ Found ${failCount} mismatches using new DB builder.`);
    }

    function exportVipReportCSV() {
      const memberName = document.getElementById('vipReportMember').value;
      if (!memberName) { alert('Vui lÃ²ng chá»n VIP member trÆ°á»›c!'); return; }

      const fromDate = document.getElementById('vipReportFromDate').value;
      const toDate = document.getElementById('vipReportToDate').value;

      const statement = buildVipStatementFromDB(memberName, {
        from: fromDate,
        to: toDate,
        includeCashOrders: true
      });

      if (statement.rows.length === 0) { alert('KhÃ´ng cÃ³ dá»¯ liá»‡u Ä‘á»ƒ xuáº¥t!'); return; }

      // Clean header with only essential columns
      const header = 'NgÃ y giá»,Loáº¡i,MÃ´ táº£,Sá»‘ tiá»n,Sá»‘ dÆ°\n';
      const rows = statement.rows.map(row => {
        // Use dateLocal for readable format
        const date = row.dateLocal || row.dateISO;

        // Clean description - remove redundant amount info
        let desc = (row.description || '');
        // Remove "(VIP -XXÄ‘)" or "(Cash -XXÄ‘)" pattern from description
        desc = desc.replace(/\s*\((VIP|Cash|TOPUP)\s*[+-]?\d+Ä‘?\)/gi, '');
        desc = desc.replace(/"/g, '""'); // Escape quotes
        desc = desc.trim();

        // Format amounts with thousand separators and currency
        const formatAmount = (num) => {
          const val = Number(num || 0);
          const formatted = Math.abs(val).toLocaleString('vi-VN');
          // Format negative numbers with parentheses and minus sign
          return val < 0 ? `-${formatted}Ä‘` : `${formatted}Ä‘`;
        };

        // Use displayAmount (shows actual transaction amount)
        const amount = formatAmount(row.displayAmount || row.deltaVip || 0);
        const balance = formatAmount(row.balanceAfter || 0);

        return `"${date}","${row.paymentType || row.typeLabel}","${desc}","${amount}","${balance}"`;
      }).join('\n');

      const csv = header + rows;

      // Add BOM for Excel UTF-8 support
      const blob = new Blob(['\uFEFF' + csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `vip-report-${memberName.replace(/\s+/g, '_')}-${new Date().toISOString().split('T')[0]}.csv`;
      link.click();
      URL.revokeObjectURL(url);
      alert(`âœ… ÄÃ£ xuáº¥t CSV: ${statement.rows.length} giao dá»‹ch`);
    }

    /**
     * Export VIP Report to HTML with beautiful styling
     */
    function exportVipReportHTML() {
      const memberName = document.getElementById('vipReportMember').value;
      if (!memberName) { alert('Vui lÃ²ng chá»n VIP member trÆ°á»›c!'); return; }

      const fromDate = document.getElementById('vipReportFromDate').value;
      const toDate = document.getElementById('vipReportToDate').value;

      const statement = buildVipStatementFromDB(memberName, {
        from: fromDate,
        to: toDate,
        includeCashOrders: true
      });

      if (statement.rows.length === 0) { alert('KhÃ´ng cÃ³ dá»¯ liá»‡u Ä‘á»ƒ xuáº¥t!'); return; }

      // Calculate summary
      const opening = statement.rows[0]?.balanceAfter - (statement.rows[0]?.displayAmount || 0) || 0;
      let totalTopup = 0, totalSpent = 0, totalCashout = 0;

      statement.rows.forEach(row => {
        const amt = row.displayAmount || 0;
        if (row.paymentType === 'TOPUP') totalTopup += amt;
        else if (row.paymentType === 'VIP' && amt < 0) totalSpent += Math.abs(amt);
        else if (row.typeLabel === 'RÃºt') totalCashout += Math.abs(amt);
      });

      const ending = statement.rows[statement.rows.length - 1]?.balanceAfter || 0;

      // Build HTML with beautiful dark theme
      const html = `<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tá»•ng káº¿t: ${memberName}</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
      color: #e2e8f0;
      padding: 20px;
      min-height: 100vh;
    }
    .container { max-width: 1200px; margin: 0 auto; }
    
    /* Header Card */
    .header-card {
      background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
      border-radius: 16px;
      padding: 24px;
      margin-bottom: 24px;
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3);
    }
    .header-card h1 {
      font-size: 24px;
      font-weight: 600;
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    /* Summary Grid */
    .summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 16px;
    }
    .summary-item {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .summary-label {
      font-size: 13px;
      opacity: 0.9;
      font-weight: 500;
    }
    .summary-value {
      font-size: 20px;
      font-weight: 700;
    }
    .positive { color: #34d399; }
    .negative { color: #f87171; }
    .neutral { color: #fbbf24; }
    
    /* Table */
    .table-container {
      background: rgba(30, 41, 59, 0.8);
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3);
    }
    table {
      width: 100%;
      border-collapse: collapse;
    }
    thead {
      background: rgba(51, 65, 85, 0.8);
    }
    th {
      padding: 16px;
      text-align: left;
      font-weight: 600;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: #cbd5e1;
    }
    tbody tr {
      border-bottom: 1px solid rgba(51, 65, 85, 0.5);
      transition: background 0.2s;
    }
    tbody tr:hover {
      background: rgba(51, 65, 85, 0.3);
    }
    td {
      padding: 14px 16px;
      font-size: 14px;
    }
    .date-col { color: #94a3b8; }
    .type-badge {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 600;
    }
    .type-vip { background: rgba(139, 92, 246, 0.2); color: #a78bfa; }
    .type-cash { background: rgba(34, 197, 94, 0.2); color: #4ade80; }
    .type-topup { background: rgba(59, 130, 246, 0.2); color: #60a5fa; }
    .amount-positive { color: #34d399; font-weight: 600; }
    .amount-negative { color: #f87171; font-weight: 600; }
    @media print {
      body { background: white; color: black; }
      .header-card { background: #6366f1; color: white; }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header-card">
      <h1>ğŸ“Š Tá»•ng káº¿t: ${memberName}</h1>
      <div class="summary-grid">
        <div class="summary-item">
          <div class="summary-label">Opening</div>
          <div class="summary-value">${opening.toLocaleString('vi-VN')}Ä‘</div>
        </div>
        <div class="summary-item">
          <div class="summary-label">Tá»•ng náº¡p</div>
          <div class="summary-value positive">+${totalTopup.toLocaleString('vi-VN')}Ä‘</div>
        </div>
        <div class="summary-item">
          <div class="summary-label">Tá»•ng chi</div>
          <div class="summary-value negative">-${totalSpent.toLocaleString('vi-VN')}Ä‘</div>
        </div>
        <div class="summary-item">
          <div class="summary-label">Tá»•ng rÃºt</div>
          <div class="summary-value neutral">-${totalCashout.toLocaleString('vi-VN')}Ä‘</div>
        </div>
        <div class="summary-item">
          <div class="summary-label">Ending Balance</div>
          <div class="summary-value">${ending.toLocaleString('vi-VN')}Ä‘</div>
        </div>
      </div>
    </div>
    
    <div class="table-container">
      <table>
        <thead>
          <tr>
            <th>NgÃ y giá» ğŸ“…</th>
            <th>Loáº¡i</th>
            <th>Ná»™i dung</th>
            <th style="text-align: right;">+/-</th>
            <th style="text-align: right;">Sá»‘ dÆ°</th>
          </tr>
        </thead>
        <tbody>
          ${statement.rows.map(row => {
        const date = row.dateLocal || row.dateISO;
        const type = row.paymentType || row.typeLabel;
        const typeClass = type === 'VIP' ? 'type-vip' : type === 'Cash' ? 'type-cash' : 'type-topup';

        let desc = row.description || '';
        desc = desc.replace(/\s*\((VIP|Cash|TOPUP)\s*[+-]?\d+Ä‘?\)/gi, '').trim();

        const amt = row.displayAmount || 0;
        const amtClass = amt >= 0 ? 'amount-positive' : 'amount-negative';
        const amtText = amt >= 0 ? `+${amt.toLocaleString('vi-VN')}Ä‘` : `${amt.toLocaleString('vi-VN')}Ä‘`;

        const balance = (row.balanceAfter || 0).toLocaleString('vi-VN') + 'Ä‘';

        return `
            <tr>
              <td class="date-col">${date}</td>
              <td><span class="type-badge ${typeClass}">${type}</span></td>
              <td>${desc}</td>
              <td style="text-align: right;" class="${amtClass}">${amtText}</td>
              <td style="text-align: right;">${balance}</td>
            </tr>`;
      }).join('')}
        </tbody>
      </table>
    </div>
  </div>
</body>
</html>`;

      // Download HTML
      const blob = new Blob([html], { type: 'text/html;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `vip-report-${memberName.replace(/\s+/g, '_')}-${new Date().toISOString().split('T')[0]}.html`;
      link.click();
      URL.revokeObjectURL(url);
      alert(`âœ… ÄÃ£ xuáº¥t HTML: ${statement.rows.length} giao dá»‹ch`);
    }

    function populateVipReportMembers() {
      const select = document.getElementById('vipReportMember');
      if (!select) return;
      const members = new Set();
      vipTransactions.forEach(tx => {
        const name = (tx.member || tx.name || '').trim();
        if (name) members.add(name);
      });
      const sorted = Array.from(members).sort();
      select.innerHTML = '<option value="">-- Chá»n ngÆ°á»i --</option>' +
        sorted.map(name => `<option value="${name.replace(/"/g, '&quot;')}">${name}</option>`).join('');
    }


    // ========== RECONCILE FUNCTIONS ==========

    function toggleReconcile() {
      const analysisPanel = document.getElementById('vipReportAnalysis');
      const btn = document.getElementById('btnReconcile');

      if (analysisPanel) {
        // If panel is visible -> Turn OFF (render normal)
        renderVipReport(false);
        if (btn) btn.style.background = 'rgba(245, 158, 11, 0.2)'; // Reset style
        if (btn) btn.style.color = '#fbbf24';
      } else {
        // If panel is NOT visible -> OPEN MODAL (Logic: User wants to start reconcile process)
        openReconcileModal();
        // Note: The modal will lead to 'selectReconcileMember' which calls renderVipReport(true)
      }
    }



    function openReconcileModal() {
      const modal = document.getElementById('reconcileModal');
      const content = document.getElementById('reconcileContent');
      const loading = document.getElementById('reconcileLoading');
      const tbody = document.getElementById('reconcileTableBody');
      const emptyMsg = document.getElementById('reconcileEmpty');

      modal.style.display = 'flex';
      loading.style.display = 'block';
      content.style.display = 'none';
      tbody.innerHTML = '';

      // Use setTimeout to allow UI to render loading state
      setTimeout(() => {
        const vipArea = document.getElementById('vipArea');
        const vipList = parseVip(vipArea ? vipArea.value : '');
        const mismatches = [];

        const allMembers = new Set([...vipList.keys()]);
        // Also add members from transactions who might not be in vipList??? 
        // For now, iterate known VIP list as "expected" source.

        vipList.forEach((expected, member) => {
          const statement = buildVipStatementFromDB(member, { includeCashOrders: true });
          const computed = statement.summary.ending;
          const diff = computed - expected;
          const orphans = statement.meta.orphans.length;

          // Criteria: Diff > 1 OR Orphans > 0 (orphans might not cause diff if cancelled out, but worth showing?)
          // Prompt says: "ending(report) != vipListBalance (mismatch)". So strictly Diff.
          if (Math.abs(diff) > 1) {
            mismatches.push({
              member, expected, computed, diff, orphans
            });
          }
        });

        // Sort by Abs(Diff) Descending
        mismatches.sort((a, b) => Math.abs(b.diff) - Math.abs(a.diff));

        if (mismatches.length === 0) {
          emptyMsg.style.display = 'block';
        } else {
          emptyMsg.style.display = 'none';
          tbody.innerHTML = mismatches.map(m => `
               <tr style="border-bottom: 1px solid rgba(255,255,255,0.05); hover:background:rgba(255,255,255,0.05);">
                 <td style="padding: 10px; font-weight: 600;">${m.member}</td>
                 <td style="padding: 10px; text-align: right;">${formatMoney(m.expected)}</td>
                 <td style="padding: 10px; text-align: right;">${formatMoney(m.computed)}</td>
                 <td style="padding: 10px; text-align: right; color: #f87171; font-weight: bold;">${m.diff > 0 ? '+' : ''}${formatMoney(m.diff)}</td>
                 <td style="padding: 10px; text-align: center;">${m.orphans > 0 ? `<span style="background:#f59e0b; color:black; padding:2px 6px; border-radius:4px; font-weight:bold;">${m.orphans}</span>` : '-'}</td>
                 <td style="padding: 10px;">
                    <button class="btn btn-sm btn-primary" onclick="selectReconcileMember('${m.member.replace(/'/g, "\\'")}')">
                       Kiá»ƒm tra
                    </button>
                 </td>
               </tr>
            `).join('');
        }

        loading.style.display = 'none';
        content.style.display = 'block';
      }, 50);
    }

    function closeReconcileModal() {
      document.getElementById('reconcileModal').style.display = 'none';
    }

    function selectReconcileMember(memberName) {
      closeReconcileModal();
      const select = document.getElementById('vipReportMember');
      select.value = memberName;
      // Trigger render with Highlight Mode
      renderVipReport(true);
    }

    /**
     * Auto Test: Reconcile UI
     */
    window.selfTest_reconcileUI = function () {
      console.log("ğŸ§ª Starting Self-Test: Reconcile UI...");

      // 1. Calculate mismatches internally
      const vipArea = document.getElementById('vipArea');
      const vipList = parseVip(vipArea ? vipArea.value : '');
      const realMismatches = [];
      vipList.forEach((expected, member) => {
        const s = buildVipStatementFromDB(member);
        if (Math.abs(s.summary.ending - expected) > 1) {
          realMismatches.push(member);
        }
      });

      console.log(`â„¹ï¸ Found ${realMismatches.length} real mismatches in DB:`, realMismatches);

      // 2. Open Modal Programmatically
      openReconcileModal();

      // Wait for async rendering
      setTimeout(() => {
        const tbody = document.getElementById('reconcileTableBody');
        const rows = tbody.querySelectorAll('tr');
        const renderedCount = rows.length;

        if (renderedCount === realMismatches.length) {
          console.log("âœ… Reconcile Modal rendered correct number of rows.");
        } else {
          console.error(`âŒ Reconcile Modal rendered ${renderedCount} rows, expected ${realMismatches.length}.`);
        }

        // 3. If mismatches exist, test selection
        if (renderedCount > 0) {
          const firstRowBtn = rows[0].querySelector('button');
          if (firstRowBtn) {
            console.log("ğŸ‘‰ Clicking first verify button...");
            firstRowBtn.click();

            // Assert Dropdown
            const select = document.getElementById('vipReportMember');
            console.log(`â„¹ï¸ Selected member: ${select.value}`);

            // Assert Analysis Panel Visibility
            const analysis = document.getElementById('vipReportAnalysis');
            if (analysis) console.log("âœ… Analysis Panel is visible.");
            else console.error("âŒ Analysis Panel NOT visible after selection.");

          }
        } else {
          console.log("â„¹ï¸ No mismatches to test interaction.");
        }

        console.log("âœ… selfTest_reconcileUI Completed.");

      }, 500);
    }

    // ========== AUDIT UTILS (Exported to Window) ==========

    /**
     * Audit VIP Ledger against Order History
     * Checks consistency between orders and transactions
     */
    window.auditVipLedgerAgainstOrders = function () {
      console.log("ğŸ” Starting Audit VIP Ledger...");
      const missingVipTx = [];
      const cashButHasVipTx = [];
      const orphanTx = [];

      // 1. Build map of existing VIP Order Transactions
      // Key: `${orderId}-${detailIndex}`
      const txMap = new Map();

      vipTransactions.forEach(tx => {
        if (tx.type === 'order') {
          // Check for malformed/orphan transactions
          if (!tx.orderId || tx.detailIndex === undefined || tx.detailIndex === null) {
            orphanTx.push({
              txId: tx.id,
              name: tx.name,
              amount: tx.amount,
              orderId: tx.orderId,
              detailIndex: tx.detailIndex,
              reason: "Missing orderId or detailIndex"
            });
          } else {
            // Valid-looking transaction, map it
            const key = `${tx.orderId}-${tx.detailIndex}`;
            if (!txMap.has(key)) txMap.set(key, []);
            txMap.get(key).push(tx);
          }
        }
      });

      // 2. Scan Order History
      if (!orderHistory || !Array.isArray(orderHistory)) {
        console.error("âŒ orderHistory is missing or invalid");
        return;
      }

      orderHistory.forEach(order => {
        if (!order.details || !Array.isArray(order.details)) return;

        order.details.forEach((detail, idx) => {
          const key = `${order.id}-${idx}`;
          const txList = txMap.get(key);
          const hasTx = txList && txList.length > 0;

          // Case 1: Record says VIP Paid => MUST have transaction
          if (detail.paid === true && detail.paymentMethod === 'vip') {
            if (!hasTx) {
              missingVipTx.push({
                orderId: order.id,
                orderDate: order.date,
                itemName: order.itemName,
                detailName: detail.name,
                detailIndex: idx,
                amount: detail.due,
                reason: "Paid VIP but missing transaction"
              });
            }
          }

          // Case 2: Record says Cash (or null) => MUST NOT have VIP transaction
          // Note: If paymentMethod is undefined/null but paid=true, it's ambiguous but usually implies cash if not marked VIP
          // If explicitly 'cash', definitely shouldn't be in VIP ledger
          else if (detail.paid === true && (detail.paymentMethod === 'cash' || !detail.paymentMethod)) {
            if (hasTx) {
              cashButHasVipTx.push({
                orderId: order.id,
                itemName: order.itemName,
                detailName: detail.name,
                detailIndex: idx,
                paymentMethod: detail.paymentMethod,
                txIds: txList.map(t => t.id).join(', '),
                reason: `Paid '${detail.paymentMethod}' but has VIP transaction`
              });
            }
          }
        });
      });

      // Output Results
      console.log("=== ğŸ“Š AUDIT RESULTS ===");

      if (missingVipTx.length > 0) {
        console.error(`âŒ Found ${missingVipTx.length} MISSING VIP transactions!`);
        console.table(missingVipTx);
      } else {
        console.log("âœ… No missing VIP transactions.");
      }

      if (cashButHasVipTx.length > 0) {
        console.error(`âŒ Found ${cashButHasVipTx.length} CASH orders with ghost VIP transactions!`);
        console.table(cashButHasVipTx);
      } else {
        console.log("âœ… No Cash orders with ghost VIP transactions.");
      }

      if (orphanTx.length > 0) {
        console.warn(`âš ï¸ Found ${orphanTx.length} ORPHAN transactions (missing link info)!`);
        console.table(orphanTx);
      } else {
        console.log("âœ… No Orphan transactions.");
      }

      console.log("=== END AUDIT ===");
    };


    /**
     * Clean Orphan VIP Transactions
     * Mark or remove transactions that are missing required order links
     */
    window.cleanupOrphanVipTransactions = function () {
      console.log("ğŸ§¹ Starting Orphan VIP Transaction Cleanup...");

      const orphanedTxs = [];
      const TIME_THRESHOLD_MS = 5000;

      // Identify orphans
      vipTransactions.forEach(tx => {
        if (tx.type === 'order' && !tx.isDeleted) {
          if (!tx.orderId || tx.detailIndex === undefined || tx.detailIndex === null) {
            // Also check for refId if system uses it (we do now)
            if (!tx.refId) {
              orphanedTxs.push(tx);
            }
          }
        }
      });

      console.log(`Found ${orphanedTxs.length} orphan transactions.`);

      const removedOrphans = [];
      const markedOrphans = [];

      orphanedTxs.forEach(orphan => {
        // Try to match with a canonical transaction (duplicate check)
        // Candidate: has refId (or orderId+detailIndex), same name, same amount, adjacent time
        const candidates = vipTransactions.filter(tx => {
          if (tx.id === orphan.id) return false; // Skip self
          if (tx.isDeleted || tx.orphan) return false; // Skip deleted/orphans

          const hasLink = tx.refId || (tx.orderId && tx.detailIndex !== undefined);
          if (!hasLink) return false;

          // Match criteria
          if ((tx.name || '') !== (orphan.name || '')) return false;
          if (Math.abs(Number(tx.amount) - Number(orphan.amount)) > 0.01) return false; // Float safe

          const t1 = new Date(orphan.ts || orphan.date || 0).getTime();
          const t2 = new Date(tx.ts || tx.date || 0).getTime();

          return Math.abs(t1 - t2) <= TIME_THRESHOLD_MS;
        });

        if (candidates.length === 1) {
          // Exact match found - it's a duplicate orphan -> DELETE
          const canonical = candidates[0];
          console.log(`ğŸ—‘ï¸ Removing orphan duplicate: ${orphan.name} ${orphan.amount} (matches ${canonical.id})`);

          // We don't actually delete from array to preserve history if needed, 
          // or we can splice. For safety, let's splice or mark deleted.
          // The prompt says "delete orphan". Let's splice.
          const idx = vipTransactions.findIndex(t => t.id === orphan.id);
          if (idx !== -1) {
            const removed = vipTransactions.splice(idx, 1)[0];
            removedOrphans.push(removed);
          }
        } else if (candidates.length > 1) {
          // Ambiguous - mark
          orphan.orphan = true;
          orphan.orphanReason = "Ambiguous duplicate";
          markedOrphans.push(orphan);
        } else {
          // No match - true orphan -> MARK
          orphan.orphan = true;
          orphan.orphanReason = "Missing link info";
          markedOrphans.push(orphan);
        }
      });

      // Save changes
      if (removedOrphans.length > 0 || markedOrphans.length > 0) {
        localStorage.setItem(VIP_TX_KEY, JSON.stringify(vipTransactions));
      }

      console.table(removedOrphans.map(t => ({ id: t.id, name: t.name, amount: t.amount, status: 'REMOVED' })));
      console.table(markedOrphans.map(t => ({ id: t.id, name: t.name, amount: t.amount, reason: t.orphanReason, status: 'MARKED' })));
      console.log("ğŸ§¹ Cleanup Complete.");

      return { removed: removedOrphans.length, marked: markedOrphans.length };
    };

    /**
     * Self Test: Orphan Cleanup
     * Automates the verification of orphan cleanup logic
     */
    window.selfTest_orphanCleanup = function () {
      console.log("ğŸ§ª Starting Self-Test: Orphan Cleanup...");

      // 1. Snapshot before
      // Capture detailed audit stats
      const getAuditStats = () => {
        let missing = 0;
        let ghosts = 0;
        let orphans = 0;

        // Use logic similar to auditVipLedger
        // (Simplified for count)
        const txMap = new Map();
        vipTransactions.filter(t => !t.orphan).forEach(tx => {
          if (tx.type === 'order' && (tx.orderId && tx.detailIndex != null)) {
            txMap.set(`${tx.orderId}-${tx.detailIndex}`, true);
          }
          if (tx.type === 'order' && (!tx.orderId || tx.detailIndex == null)) orphans++;
        });

        // Scan orders
        orderHistory.forEach(o => {
          (o.details || []).forEach((d, i) => {
            const key = `${o.id}-${i}`;
            const hasTx = txMap.has(key);
            if (d.paid && d.paymentMethod === 'vip' && !hasTx) missing++;
            else if (d.paid && (d.paymentMethod === 'cash' || !d.paymentMethod) && hasTx) ghosts++;
          });
        });
        return { missing, ghosts, orphans };
      };

      const before = getAuditStats();
      console.log("Before:", before);

      // 2. Run Cleanup
      const result = window.cleanupOrphanVipTransactions();

      // 3. Snapshot after
      const after = getAuditStats();
      console.log("After:", after);

      // 4. Assertions
      const passed =
        (after.missing === 0) &&
        (after.ghosts === 0) &&
        (after.orphans <= before.orphans || result.removed > 0 || result.marked > 0);

      console.log(passed ? "âœ… PASS" : "âŒ FAIL");
      console.table({
        Removed: result.removed,
        Marked: result.marked
      });
    };


  </script>

  <!-- Modular Architecture Bootstrap (PROMPT 1 - Gradual Migration) -->
  <script type="module" src="js/app.js"></script>
  <!-- 
    NOTE: The above module runs alongside existing inline code.
    This is a gradual migration approach - both systems coexist safely.
    As we migrate functions, the inline code will be progressively removed.
  -->

</body>


</body>

</html>