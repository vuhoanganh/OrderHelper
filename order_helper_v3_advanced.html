<!DOCTYPE html>
<html lang="vi">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Order Helper Pro - Advanced Edition</title>
  <style>
    :root {
      --bg-start: #1a1a2e;
      --bg-end: #16213e;
      --glass-bg: rgba(255, 255, 255, 0.05);
      --glass-border: rgba(255, 255, 255, 0.1);
      --text-primary: #eee;
      --text-secondary: #bbb;
      --text-muted: #888;
      --accent: #00d4ff;
      --accent-hover: #00b8e6;
      --accent-green: #10b981;
      --accent-green-light: #34d399;
      --accent-red: #ef4444;
      --accent-yellow: #f59e0b;
      --accent-blue: #3b82f6;
      --accent-purple: #8b5cf6;

      /* Status colors */
      --color-paid: #10b981;
      --color-unpaid: #ef4444;
      --color-partial: #f59e0b;

      /* VIP balance colors */
      --color-credit: #10b981;
      --color-debit: #ef4444;
      --color-inactive: #6b7280;

      /* Transaction types */
      --color-topup: #3b82f6;
      --color-cashout: #8b5cf6;
      --color-order: #f59e0b;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', 'SF Pro Display', -apple-system, sans-serif;
      background: linear-gradient(135deg, var(--bg-start) 0%, var(--bg-end) 100%);
      color: var(--text-primary);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
    }

    .header h1 {
      font-size: 2.5rem;
      background: linear-gradient(135deg, var(--accent) 0%, #b06ab3 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 10px;
    }

    .badge {
      display: inline-block;
      padding: 6px 16px;
      background: var(--glass-bg);
      backdrop-filter: blur(10px);
      border: 1px solid var(--glass-border);
      border-radius: 20px;
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    /* Status badges */
    .status-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 0.75rem;
      font-weight: 600;
      border: 1px solid;
    }

    .status-badge.paid {
      background: rgba(16, 185, 129, 0.1);
      color: var(--color-paid);
      border-color: var(--color-paid);
    }

    .status-badge.unpaid {
      background: rgba(239, 68, 68, 0.1);
      color: var(--color-unpaid);
      border-color: var(--color-unpaid);
    }

    /* Balance badges */
    .balance-badge {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 0.85rem;
      font-weight: 700;
    }

    .balance-badge.positive {
      background: rgba(16, 185, 129, 0.15);
      color: var(--color-credit);
    }

    .balance-badge.negative {
      background: rgba(239, 68, 68, 0.15);
      color: var(--color-debit);
    }

    /* Count badges */
    .count-badge {
      display: inline-block;
      padding: 2px 8px;
      background: rgba(59, 130, 246, 0.15);
      color: var(--accent-blue);
      border-radius: 10px;
      font-size: 0.7rem;
      font-weight: 600;
    }

    .header h1 {
      font-size: 42px;
      font-weight: 700;
      background: linear-gradient(135deg, #a78bfa 0%, #60a5fa 50%, #34d399 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 12px;
      letter-spacing: -0.02em;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 20px;
      background: rgba(16, 185, 129, 0.15);
      border: 1px solid rgba(16, 185, 129, 0.3);
      border-radius: 100px;
      font-size: 14px;
      color: #6ee7b7;
      backdrop-filter: blur(10px);
    }

    .badge::before {
      content: '‚ú®';
      font-size: 16px;
    }

    /* Tabs */
    .tabs {
      display: flex;
      gap: 12px;
      margin-bottom: 32px;
      overflow-x: auto;
      padding-bottom: 8px;
    }

    .tab {
      padding: 12px 24px;
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      border-radius: 12px;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.2s ease;
      white-space: nowrap;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .tab:hover {
      background: var(--glass-bg-hover);
      color: var(--text-primary);
    }

    .tab.active {
      background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
      color: white;
      border-color: transparent;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
      animation: fadeIn 0.3s ease-out;
    }

    /* Glass Card */
    .glass-card {
      background: var(--glass-bg);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      border: 1px solid var(--glass-border);
      border-radius: 24px;
      padding: 28px;
      box-shadow:
        0 8px 32px var(--glass-shadow),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .glass-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    }

    .glass-card:hover {
      background: var(--glass-bg-hover);
      border-color: rgba(255, 255, 255, 0.2);
      transform: translateY(-2px);
      box-shadow:
        0 12px 40px var(--glass-shadow),
        inset 0 1px 0 rgba(255, 255, 255, 0.15);
    }

    /* Grid Layout */
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 24px;
      margin-bottom: 24px;
    }

    .grid-2 {
      grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
    }

    .grid-3 {
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    }

    /* Global Search */
    .global-search-container {
      position: sticky;
      top: 20px;
      z-index: 1000;
      margin-bottom: 24px;
    }

    .global-search-wrapper {
      position: relative;
      display: flex;
      align-items: center;
      background: var(--glass-bg);
      backdrop-filter: blur(20px);
      border: 2px solid var(--glass-border);
      border-radius: 16px;
      padding: 4px;
      transition: all 0.3s ease;
    }

    .global-search-wrapper:focus-within {
      border-color: var(--accent-blue);
      box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.1), 0 8px 24px rgba(0, 0, 0, 0.3);
    }

    .search-icon {
      padding: 0 12px;
      font-size: 1.2rem;
      opacity: 0.5;
    }

    .global-search-input {
      flex: 1;
      padding: 14px 8px;
      background: transparent;
      border: none;
      color: var(--text-primary);
      font-size: 16px;
      outline: none;
    }

    .global-search-input::placeholder {
      color: var(--text-muted);
    }

    .search-clear {
      padding: 8px 12px;
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 1.2rem;
      border-radius: 8px;
      transition: all 0.2s;
    }

    .search-clear:hover {
      background: rgba(255, 255, 255, 0.1);
      color: var(--text-primary);
    }

    .search-results-dropdown {
      position: absolute;
      top: calc(100% + 8px);
      left: 0;
      right: 0;
      background: var(--glass-bg);
      backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      border-radius: 16px;
      max-height: 400px;
      overflow-y: auto;
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
      display: none;
    }

    .search-results-dropdown.show {
      display: block;
      animation: slideDown 0.2s ease-out;
    }

    .search-result-section {
      padding: 12px 16px;
      border-bottom: 1px solid var(--glass-border);
    }

    .search-result-section:last-child {
      border-bottom: none;
    }

    .search-section-title {
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 8px;
    }

    .search-result-item {
      padding: 10px 12px;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .search-result-item:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .search-result-icon {
      font-size: 1.2rem;
    }

    .search-result-content {
      flex: 1;
    }

    .search-result-title {
      color: var(--text-primary);
      font-weight: 500;
      font-size: 0.95rem;
    }

    .search-result-subtitle {
      color: var(--text-muted);
      font-size: 0.8rem;
      margin-top: 2px;
    }

    .search-no-results {
      padding: 24px;
      text-align: center;
      color: var(--text-muted);
      font-size: 0.9rem;
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Form Elements */
    .form-group {
      margin-bottom: 20px;
    }

    .form-label {
      display: block;
      font-size: 13px;
      font-weight: 500;
      color: var(--text-secondary);
      margin-bottom: 8px;
      letter-spacing: 0.01em;
    }

    .form-input,
    .form-textarea,
    .form-select {
      width: 100%;
      padding: 12px 16px;
      background: var(--input-bg);
      border: 1px solid var(--input-border);
      border-radius: 12px;
      color: var(--text-primary);
      font-size: 15px;
      transition: all 0.2s ease;
      font-family: inherit;
    }

    .form-input:focus,
    .form-textarea:focus,
    .form-select:focus {
      outline: none;
      border-color: var(--accent-blue);
      background: rgba(15, 23, 42, 0.8);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }

    .form-textarea {
      resize: vertical;
      min-height: 100px;
      line-height: 1.5;
    }

    .form-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 16px;
    }

    /* Checkbox */
    .checkbox-wrapper {
      display: flex;
      align-items: flex-start;
      gap: 12px;
      padding: 16px;
      background: rgba(59, 130, 246, 0.05);
      border: 1px solid rgba(59, 130, 246, 0.2);
      border-radius: 12px;
      margin-top: 12px;
    }

    .checkbox-wrapper input[type="checkbox"] {
      width: 20px;
      height: 20px;
      cursor: pointer;
      accent-color: var(--accent-blue);
      flex-shrink: 0;
      margin-top: 2px;
    }

    .checkbox-label {
      font-size: 13px;
      color: var(--text-secondary);
      line-height: 1.5;
    }

    .checkbox-label strong {
      color: var(--accent-blue);
    }

    /* Buttons */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 12px 24px;
      border: none;
      border-radius: 12px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      text-decoration: none;
      font-family: inherit;
      position: relative;
      overflow: hidden;
    }

    .btn::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.2);
      transform: translate(-50%, -50%);
      transition: width 0.4s ease, height 0.4s ease;
    }

    .btn:hover::before {
      width: 300px;
      height: 300px;
    }

    .btn:active {
      transform: scale(0.98);
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--accent-green) 0%, var(--accent-green-light) 100%);
      color: white;
      box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
    }

    .btn-secondary {
      background: linear-gradient(135deg, var(--accent-blue) 0%, var(--accent-purple) 100%);
      color: white;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
    }

    .btn-secondary:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4);
    }

    .btn-warning {
      background: linear-gradient(135deg, var(--accent-yellow) 0%, #f59e0b 100%);
      color: #78350f;
      box-shadow: 0 4px 12px rgba(251, 191, 36, 0.3);
    }

    .btn-ghost {
      background: rgba(255, 255, 255, 0.05);
      color: var(--text-secondary);
      border: 1px dashed var(--glass-border);
    }

    .btn-ghost:hover {
      background: rgba(255, 255, 255, 0.1);
      color: var(--text-primary);
    }

    .btn-danger {
      background: rgba(239, 68, 68, 0.1);
      color: #fca5a5;
      border: 1px solid rgba(239, 68, 68, 0.3);
    }

    .btn-danger:hover {
      background: rgba(239, 68, 68, 0.2);
    }

    .btn-info {
      background: rgba(59, 130, 246, 0.1);
      color: #93c5fd;
      border: 1px solid rgba(59, 130, 246, 0.3);
    }

    /* Draft Save */
    .draft-save-card {
      display: flex;
      gap: 16px;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
    }

    .draft-status {
      display: flex;
      gap: 12px;
      align-items: flex-start;
      flex: 1;
      min-width: 280px;
    }

    .draft-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-top: 4px;
      box-shadow: 0 0 0 6px rgba(255, 255, 255, 0.06);
      flex-shrink: 0;
    }

    .draft-dot.saved {
      background: var(--accent-green);
      box-shadow: 0 0 0 6px rgba(16, 185, 129, 0.18);
    }

    .draft-dot.unsaved {
      background: var(--accent-orange);
      box-shadow: 0 0 0 6px rgba(249, 115, 22, 0.18);
    }

    .draft-status-text {
      font-size: 15px;
      font-weight: 600;
      color: var(--text-primary);
      line-height: 1.4;
    }

    .draft-meta {
      color: var(--text-muted);
      font-size: 13px;
      margin-top: 4px;
    }

    .draft-banner {
      color: var(--text-secondary);
      font-size: 13px;
      margin-top: 6px;
    }

    .draft-actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-end;
      min-width: 260px;
    }

    @media (max-width: 768px) {
      .draft-save-card {
        flex-direction: column;
        align-items: flex-start;
      }

      .draft-actions {
        width: 100%;
        justify-content: flex-start;
      }
    }

    .btn-group {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    .btn-full {
      width: 100%;
    }

    /* Table */
    .table-wrapper {
      overflow-x: auto;
      margin-top: 16px;
      border-radius: 12px;
      background: rgba(15, 23, 42, 0.4);
    }

    .table {
      width: 100%;
      border-collapse: collapse;
    }

    .table thead {
      background: rgba(255, 255, 255, 0.03);
    }

    .table th {
      padding: 14px 16px;
      text-align: left;
      font-size: 12px;
      font-weight: 600;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .table td {
      padding: 12px 16px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      color: var(--text-primary);
    }

    .table tbody tr {
      transition: background 0.2s ease;
    }

    .table tbody tr:hover {
      background: rgba(255, 255, 255, 0.03);
    }

    .table input {
      width: 100%;
      text-align: right;
      background: var(--input-bg);
      border: 1px solid var(--input-border);
      border-radius: 8px;
      padding: 8px 12px;
      color: var(--text-primary);
      font-size: 14px;
    }

    .table input:focus {
      outline: none;
      border-color: var(--accent-blue);
    }

    .table .name-input {
      text-align: left;
    }

    .table input[type="checkbox"] {
      width: 20px;
      height: 20px;
      cursor: pointer;
      accent-color: var(--accent-green);
    }

    /* Summary Section */
    .summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }

    .summary-item {
      padding: 16px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    .summary-item h3 {
      font-size: 14px;
      color: var(--text-secondary);
      margin-bottom: 12px;
      font-weight: 500;
    }

    .summary-value {
      font-size: 24px;
      font-weight: 700;
      color: var(--text-primary);
    }

    .summary-detail {
      font-size: 13px;
      color: var(--text-muted);
      margin-top: 6px;
    }

    .profit-positive {
      color: var(--accent-green);
    }

    .profit-negative {
      color: var(--accent-red);
    }

    /* Lists */
    .info-list {
      list-style: none;
      padding: 0;
    }

    .info-list li {
      padding: 10px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .info-list li:last-child {
      border-bottom: none;
    }

    .info-list .name {
      color: var(--text-primary);
    }

    .info-list .value {
      font-weight: 600;
      color: var(--accent-green);
    }

    .info-list .note {
      font-size: 12px;
      color: var(--text-muted);
      margin-left: 8px;
    }

    /* Helper Text */
    .helper-text {
      font-size: 12px;
      color: var(--text-muted);
      margin-top: 8px;
      line-height: 1.5;
    }

    .helper-text strong {
      color: var(--text-secondary);
    }

    /* Alert Box */
    .alert {
      padding: 14px 18px;
      border-radius: 12px;
      margin-bottom: 20px;
      display: flex;
      align-items: flex-start;
      gap: 12px;
      font-size: 14px;
      line-height: 1.5;
    }

    .alert-info {
      background: rgba(59, 130, 246, 0.1);
      border: 1px solid rgba(59, 130, 246, 0.3);
      color: #93c5fd;
    }

    .alert-success {
      background: rgba(16, 185, 129, 0.1);
      border: 1px solid rgba(16, 185, 129, 0.3);
      color: #6ee7b7;
    }

    .alert-warning {
      background: rgba(251, 191, 36, 0.1);
      border: 1px solid rgba(251, 191, 36, 0.3);
      color: #fcd34d;
    }

    /* Price Suggestion */
    .price-suggestion {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
      margin-top: 16px;
    }

    .price-card {
      padding: 20px;
      background: rgba(255, 255, 255, 0.03);
      border: 2px solid rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .price-card:hover {
      background: rgba(255, 255, 255, 0.06);
      border-color: var(--accent-blue);
      transform: translateY(-2px);
    }

    .price-card.active {
      border-color: var(--accent-green);
      background: rgba(16, 185, 129, 0.1);
    }

    .price-card-label {
      font-size: 12px;
      color: var(--text-secondary);
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .price-card-value {
      font-size: 32px;
      font-weight: 700;
      color: var(--text-primary);
    }

    .price-card-desc {
      font-size: 12px;
      color: var(--text-muted);
      margin-top: 8px;
    }

    /* Section Title */
    .section-title {
      font-size: 18px;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .section-title::before {
      content: '';
      width: 4px;
      height: 20px;
      background: linear-gradient(180deg, var(--accent-blue), var(--accent-purple));
      border-radius: 4px;
    }

    /* Stats Cards */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      margin-bottom: 24px;
    }

    .stat-card {
      padding: 20px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 16px;
      text-align: center;
    }

    .stat-icon {
      font-size: 32px;
      margin-bottom: 12px;
    }

    .stat-value {
      font-size: 28px;
      font-weight: 700;
      color: var(--text-primary);
      margin-bottom: 4px;
    }

    .stat-label {
      font-size: 12px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    /* Badge Status */
    .status-badge {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 100px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .status-paid {
      background: rgba(16, 185, 129, 0.2);
      color: #6ee7b7;
    }

    .status-unpaid {
      background: rgba(239, 68, 68, 0.2);
      color: #fca5a5;
    }

    .status-partial {
      background: rgba(251, 191, 36, 0.2);
      color: #fcd34d;
    }

    /* Order History Item */
    .history-item {
      padding: 16px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      margin-bottom: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .history-item:hover {
      background: rgba(255, 255, 255, 0.06);
      transform: translateX(4px);
    }

    .history-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .history-title {
      font-weight: 600;
      color: var(--text-primary);
    }

    .history-date {
      font-size: 12px;
      color: var(--text-muted);
    }

    .history-details {
      font-size: 13px;
      color: var(--text-secondary);
    }

    /* Empty State */
    .empty-state {
      text-align: center;
      padding: 40px 20px;
      color: var(--text-muted);
      font-size: 14px;
    }

    .empty-state-icon {
      font-size: 48px;
      margin-bottom: 12px;
      opacity: 0.5;
    }

    .mini-list {
      list-style: none;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .mini-list li {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: var(--text-secondary);
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      padding-bottom: 6px;
    }

    .mini-list .note {
      color: var(--text-muted);
    }

    .amount-positive {
      color: var(--accent-green);
      font-weight: 600;
    }

    .amount-negative {
      color: var(--accent-red);
      font-weight: 600;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .header h1 {
        font-size: 32px;
      }

      .grid,
      .grid-2,
      .grid-3 {
        grid-template-columns: 1fr;
      }

      .price-suggestion {
        grid-template-columns: 1fr;
      }

      .form-row {
        grid-template-columns: 1fr;
      }

      .tabs {
        overflow-x: auto;
      }
    }

    /* Animation */
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(20px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .glass-card {
      animation: fadeIn 0.5s ease-out;
    }

    /* Modal */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(8px);
      z-index: 1000;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .modal.active {
      display: flex;
    }

    .modal-content {
      background: var(--bg-gradient-1);
      border: 1px solid var(--glass-border);
      border-radius: 24px;
      padding: 32px;
      max-width: 600px;
      width: 100%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
    }

    .modal-title {
      font-size: 24px;
      font-weight: 700;
      color: var(--text-primary);
    }

    .modal-close {
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: var(--text-primary);
      font-size: 24px;
      width: 36px;
      height: 36px;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    .modal-close:hover {
      background: rgba(255, 255, 255, 0.2);
    }
  </style>
</head>

<body>

  <div class="container">
    <!-- Header -->
    <div class="header">
      <h1>Order Helper Pro</h1>
      <div class="badge">Advanced Edition - Quick Parse + History + Debt Tracking</div>
    </div>

    <!-- Global Search Bar -->
    <div class="global-search-container">
      <div class="global-search-wrapper">
        <span class="search-icon">üîç</span>
        <input type="text" id="globalSearch" class="global-search-input"
          placeholder="T√¨m ki·∫øm order, VIP, m√≥n ƒÉn... (Ctrl+K)" oninput="handleGlobalSearch(this.value)"
          onfocus="this.select()">
        <button class="search-clear" onclick="clearGlobalSearch()" style="display: none;">‚úï</button>
      </div>
      <div id="searchResults" class="search-results-dropdown"></div>
    </div>

    <!-- Tabs -->
    <div class="tabs">
      <div class="tab active" onclick="switchTab(event, 'newOrder')">
        üÜï T·∫°o ƒë∆°n m·ªõi
      </div>
      <div class="tab" onclick="switchTab(event, 'history')">
        üìú L·ªãch s·ª≠ ƒë∆°n h√†ng
      </div>
      <div class="tab" onclick="switchTab(event, 'debt')">
        üí∞ Qu·∫£n l√Ω c√¥ng n·ª£
      </div>
      <div class="tab" onclick="switchTab(event, 'stats')">
        üìä Th·ªëng k√™
      </div>
      <div class="tab" onclick="switchTab(event, 'backup')">
        ‚òÅÔ∏è Backup
      </div>
    </div>

    <!-- Tab: New Order -->
    <div id="newOrder" class="tab-content active">
      <div class="grid">
        <!-- Quick Parse Input -->
        <div class="glass-card">
          <div class="section-title">‚ö° Nh·∫≠p nhanh</div>

          <div class="form-group">
            <label class="form-label">Paste danh s√°ch order</label>
            <textarea id="quickInput" class="form-textarea" rows="4"
              placeholder="VD: aDuck, aDave 8, Lucas, Alvis, Hunter, Harrison, Ryan 2, Daniel 2, Ben 2"></textarea>
            <div class="helper-text">
              <strong>Format:</strong> T√™n (s·ªë ph·∫ßn m·∫∑c ƒë·ªãnh = 1), T√™n 2 (2 ph·∫ßn), T√™n 3, ...
            </div>
          </div>

          <button class="btn btn-secondary btn-full" onclick="parseQuickInput()">
            üöÄ Parse & Fill v√†o b·∫£ng
          </button>
        </div>

        <!-- Item & Pricing -->
        <div class="glass-card">
          <div class="section-title">Th√¥ng tin m√≥n ƒÉn</div>

          <div class="form-group">
            <label class="form-label">T√™n m√≥n</label>
            <input id="itemName" class="form-input" list="dishNameHistory" value="Ph·ªü b√≤"
              placeholder="Nh·∫≠p ho·∫∑c ch·ªçn t√™n m√≥n..." autocomplete="off">
            <datalist id="dishNameHistory"></datalist>
            <div class="helper-text">C√≥ th·ªÉ ch·ªçn m√≥n t·ª´ l·ªãch s·ª≠ ho·∫∑c nh·∫≠p t√™n m·ªõi</div>
          </div>

          <div class="form-row">
            <div class="form-group">
              <label class="form-label">T·ªïng ph·∫ßn (n)</label>
              <input id="n" class="form-input" type="number" min="2" step="1" value="12">
              <div class="helper-text">ƒê√£ t√≠nh c·∫£ ph·∫ßn c·ªßa L√£o nh√¢n gia</div>
            </div>
          </div>

          <div class="checkbox-wrapper">
            <input id="alvinFree" type="checkbox" checked>
            <label class="checkbox-label">
              <strong>L√£o nh√¢n gia ƒÉn 1 ph·∫ßn</strong><br>

            </label>
          </div>

          <div class="form-row">
            <div class="form-group">
              <label class="form-label">T·ªïng ti·ªÅn m√≥n (T)</label>
              <input id="totalCost" class="form-input" type="number" min="0" step="1" value="0">
            </div>
            <div class="form-group">
              <label class="form-label">Chi ph√≠/ph·∫ßn (c)</label>
              <input id="costPerUnit" class="form-input" type="number" min="0" step="0.01" value="0">
              <div class="helper-text">ƒê·ªÉ 0 n·∫øu d√πng T</div>
            </div>
          </div>

          <div class="form-row">
            <div class="form-group">
              <label class="form-label">Ph√≠ ship (S)</label>
              <input id="shipFee" class="form-input" type="number" min="0" step="1" value="0">
            </div>
            <div class="form-group">
              <label class="form-label">L·ª£i nhu·∫≠n m·ª•c ti√™u</label>
              <input id="targetProfit" class="form-input" type="number" min="0" step="1" value="6">
            </div>
          </div>

          <div class="form-group">
            <label class="form-label">Gi√° b√°n mong mu·ªën</label>
            <input id="desiredPrice" class="form-input" type="number" min="0" step="1"
              placeholder="Nh·∫≠p gi√° mu·ªën b√°n...">
            <div class="helper-text">T·ª± nh·∫≠p gi√° n·∫øu kh√¥ng d√πng m·ª©c g·ª£i √Ω</div>
          </div>

          <button class="btn btn-secondary btn-full" onclick="suggestPrices()">
            üí° ƒê·ªÅ xu·∫•t 2 m·ª©c gi√°
          </button>

          <div id="priceSuggestion"></div>
        </div>

        <!-- VIP Management -->
        <div class="glass-card">
          <div class="section-title">Qu·∫£n l√Ω VIP</div>

          <div class="form-group">
            <label class="form-label">Danh s√°ch VIP (name=balance)</label>
            <textarea id="vipArea" class="form-textarea" rows="6">a Duck=145</textarea>
          </div>

          <div class="btn-group">
            <button class="btn btn-secondary" onclick="addNewVIP()">
              ‚ûï N·∫°p VIP
            </button>
            <button class="btn btn-warning" onclick="cashOutVIP()">
              üí∏ Cash Out
            </button>
          </div>

          <div class="alert alert-info" style="margin-top: 12px;">
            ‚ÑπÔ∏è Khi ch·ªët ƒë∆°n, VIP s·∫Ω t·ª± ƒë·ªông tr·ª´ ti·ªÅn. S·ªë d∆∞ hi·ªÉn th·ªã trong tin ch·ªët l√† s·ªë d∆∞ SAU KHI ƒê√É TR·ª™.
          </div>

          <div class="glass-card" style="margin-top: 16px; padding: 16px; background: rgba(255,255,255,0.03);">
            <div class="section-title" style="margin-bottom: 10px;">ü™ô L·ªãch s·ª≠ n·∫°p/r√∫t VIP</div>
            <div id="vipHistory"></div>
          </div>
        </div>
      </div>

      <div class="glass-card draft-save-card">
        <div class="draft-status">
          <span id="draftStatusDot" class="draft-dot unsaved" aria-label="Tr·∫°ng th√°i l∆∞u nh√°p"></span>
          <div>
            <div id="draftStatusText" class="draft-status-text">Nh√°p ch∆∞a l∆∞u</div>
            <div id="draftMetaText" class="draft-meta">T·ª± ƒë·ªông l∆∞u 30 ph√∫t/l·∫ßn | L∆∞u cu·ªëi: ‚Äî</div>
            <div id="draftBannerMessage" class="draft-banner"></div>
          </div>
        </div>
        <div class="draft-actions">
          <button class="btn btn-primary" onclick="manualSaveDraft()">üíæ L∆∞u nh√°p</button>
          <button class="btn btn-secondary" onclick="loadLatestDraftFromICloud()">üìÇ T·∫£i nh√°p</button>
          <button class="btn btn-danger" onclick="clearDraft()">üóëÔ∏è X√≥a nh√°p</button>
        </div>
      </div>

      <!-- Order Table -->
      <div class="glass-card" style="margin-top: 24px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
          <div class="section-title" style="margin: 0;">Danh s√°ch order</div>
          <button class="btn btn-ghost" onclick="addRow()">+ Th√™m ng∆∞·ªùi</button>
        </div>

        <div class="table-wrapper">
          <table class="table" id="orderTable">
            <thead>
              <tr>
                <th style="width: 36%">T√™n</th>
                <th style="width: 16%; text-align: right;">S·ªë ph·∫ßn</th>
                <th style="width: 16%; text-align: right;">Ph·∫ßn ship</th>
                <th style="width: 16%; text-align: center;">ƒê√£ tr·∫£?</th>
                <th style="width: 16%; text-align: center;">Xo√°</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><input class="name-input" value="Ben" placeholder="Nh·∫≠p t√™n..."></td>
                <td><input type="number" min="1" step="1" value="1"></td>
                <td><input type="number" min="0" step="1" value="0" class="ship-count-input" placeholder="0"></td>
                <td style="text-align: center;"><input type="checkbox" class="payment-check"></td>
                <td style="text-align: center;"><button class="btn btn-danger" onclick="delRow(this)">‚úï</button></td>
              </tr>
            </tbody>
          </table>
        </div>

        <div class="helper-text">
          <strong>L∆∞u √Ω:</strong> Tick "ƒê√£ tr·∫£" cho ng∆∞·ªùi ƒë√£ thanh to√°n ngay
        </div>
      </div>

      <!-- Compute Section -->
      <div class="glass-card" style="margin-top: 24px;">
        <div class="btn-group">
          <button class="btn btn-secondary" onclick="compute({ save: false })" style="flex: 1;">
            üßÆ T√≠nh ti·ªÅn
          </button>
          <button class="btn btn-primary" onclick="compute({ save: true })" style="flex: 1;">
            üíæ L∆∞u ƒë∆°n
          </button>
          <button class="btn btn-warning" onclick="resetOutput()" style="flex: 1;">
            üóëÔ∏è Xo√° k·∫øt qu·∫£
          </button>
        </div>

        <div id="summarySection"></div>
      </div>

      <!-- Message Output -->
      <div class="grid grid-2" style="margin-top: 24px;">
        <div class="glass-card">
          <div class="section-title">Tin nh·∫Øn ch·ªët ƒë∆°n</div>

          <div class="form-group">
            <textarea id="finalMsg" class="form-textarea" rows="6" readonly></textarea>
          </div>

          <button class="btn btn-primary btn-full" onclick="copyAndSaveFinalMsg(event)">
            üìã Copy tin ch·ªët
          </button>
        </div>

        <div class="glass-card">
          <div class="section-title">Tin m·ªü order</div>

          <div class="form-group">
            <label class="form-label">Ch·ªçn m√≥n nhanh (t·ª´ l·ªãch s·ª≠)</label>
            <select id="quickOrderSelect" class="form-input"></select>
            <div class="helper-text">Danh s√°ch t·ª± c·∫≠p nh·∫≠t m·ªói khi l∆∞u ƒë∆°n</div>
          </div>

          <div class="form-row">
            <div class="form-group">
              <label class="form-label">S·ªë l∆∞·ª£ng order</label>
              <input id="quickOrderQty" class="form-input" type="number" min="1" step="1" value="1">
            </div>
            <div class="form-group" style="display: flex; align-items: flex-end;">
              <button class="btn btn-secondary btn-full" onclick="generateOpenMsg()">T·∫°o tin</button>
            </div>
          </div>

          <div class="form-group">
            <textarea id="openMsg" class="form-textarea" rows="6" readonly></textarea>
          </div>

          <button class="btn btn-primary btn-full" onclick="copyMsg('openMsg', event)">
            üìã Copy tin m·ªü
          </button>
        </div>
      </div>
    </div>

    <!-- Tab: History -->
    <div id="history" class="tab-content">
      <div class="glass-card">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
          <div class="section-title" style="margin: 0;">L·ªãch s·ª≠ ƒë∆°n h√†ng</div>
          <div class="btn-group">
            <button class="btn btn-info" onclick="importHistory()">üì§ Import</button>
            <button class="btn btn-secondary" onclick="exportHistory()">üì• Export JSON</button>
            <button class="btn btn-warning" onclick="clearHistory()">üóëÔ∏è Xo√° t·∫•t c·∫£</button>
          </div>
        </div>

        <!-- Filter Controls -->
        <div class="history-filters" style="margin-bottom: 20px;">
          <div
            style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; margin-bottom: 12px;">
            <div>
              <label style="display: block; font-size: 0.75rem; color: var(--text-muted); margin-bottom: 4px;">üìÖ T·ª´
                ng√†y</label>
              <input type="date" id="filterFromDate" class="form-input" style="padding: 8px 12px;"
                onchange="applyHistoryFilters()">
            </div>
            <div>
              <label style="display: block; font-size: 0.75rem; color: var(--text-muted); margin-bottom: 4px;">üìÖ ƒê·∫øn
                ng√†y</label>
              <input type="date" id="filterToDate" class="form-input" style="padding: 8px 12px;"
                onchange="applyHistoryFilters()">
            </div>
            <div>
              <label style="display: block; font-size: 0.75rem; color: var(--text-muted); margin-bottom: 4px;">üë§
                VIP</label>
              <select id="filterVIP" class="form-select" style="padding: 8px 12px;" onchange="applyHistoryFilters()">
                <option value="">T·∫•t c·∫£</option>
              </select>
            </div>
            <div>
              <label style="display: block; font-size: 0.75rem; color: var(--text-muted); margin-bottom: 4px;">üçú M√≥n
                ƒÉn</label>
              <input type="text" id="filterItem" class="form-input" style="padding: 8px 12px;" placeholder="T√¨m m√≥n..."
                oninput="applyHistoryFilters()">
            </div>
          </div>
          <div style="display: flex; gap: 8px; align-items: center;">
            <button class="btn btn-primary" onclick="applyHistoryFilters()" style="padding: 8px 16px;">
              üîç L·ªçc
            </button>
            <button class="btn btn-secondary" onclick="clearHistoryFilters()" style="padding: 8px 16px;">
              ‚úï X√≥a b·ªô l·ªçc
            </button>
            <div id="filterSummary" style="flex: 1; font-size: 0.85rem; color: var(--text-muted);"></div>
          </div>
        </div>

        <div id="historyList"></div>
      </div>
    </div>

    <!-- Tab: Debt Management -->
    <div id="debt" class="tab-content">
      <div class="glass-card">
        <div class="section-title">üí∞ T·ªïng quan c√¥ng n·ª£</div>
        <div id="debtSummary"></div>
      </div>

      <div class="glass-card" style="margin-top: 24px;">
        <div class="section-title">üìã Chi ti·∫øt t·ª´ng ng∆∞·ªùi</div>
        <div id="debtDetails"></div>
      </div>

      <!-- VIP Transaction History -->
      <div class="glass-card" style="margin-top: 24px;">
        <div class="section-title">üìä L·ªãch s·ª≠ giao d·ªãch VIP</div>

        <div class="form-group">
          <label class="form-label">Ch·ªçn VIP member</label>
          <select id="vipMemberSelect" class="form-input" onchange="showVipMemberHistory()">
            <option value="">-- Ch·ªçn VIP --</option>
          </select>
        </div>

        <!-- Transaction Filters -->
        <div id="vipHistoryFilters"
          style="display: none; margin-top: 16px; padding: 16px; background: rgba(255,255,255,0.03); border-radius: 12px; border: 1px solid rgba(255,255,255,0.08);">
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px;">
            <div class="form-group" style="margin: 0;">
              <label class="form-label" style="font-size: 12px;">T·ª´ ng√†y</label>
              <input type="date" id="filterDateFrom" class="form-input" style="font-size: 13px; padding: 8px;"
                onchange="applyVipHistoryFilters()">
            </div>
            <div class="form-group" style="margin: 0;">
              <label class="form-label" style="font-size: 12px;">ƒê·∫øn ng√†y</label>
              <input type="date" id="filterDateTo" class="form-input" style="font-size: 13px; padding: 8px;"
                onchange="applyVipHistoryFilters()">
            </div>
            <div class="form-group" style="margin: 0;">
              <label class="form-label" style="font-size: 12px;">Lo·∫°i giao d·ªãch</label>
              <select id="filterTxType" class="form-input" style="font-size: 13px; padding: 8px;"
                onchange="applyVipHistoryFilters()">
                <option value="all">T·∫•t c·∫£</option>
                <option value="topup">üí∞ N·∫°p ti·ªÅn</option>
                <option value="cashout">üí∏ R√∫t ti·ªÅn</option>
                <option value="order">üçú Order</option>
              </select>
            </div>
            <div class="form-group" style="margin: 0;">
              <label class="form-label" style="font-size: 12px;">Tr·∫°ng th√°i thanh to√°n</label>
              <select id="filterPaymentStatus" class="form-input" style="font-size: 13px; padding: 8px;"
                onchange="applyVipHistoryFilters()">
                <option value="all">T·∫•t c·∫£</option>
                <option value="paid">‚úÖ ƒê√£ tr·∫£</option>
                <option value="unpaid">‚è≥ Ch∆∞a tr·∫£</option>
              </select>
            </div>
          </div>
          <div style="display: flex; gap: 8px; margin-top: 12px; flex-wrap: wrap;">
            <button onclick="clearVipHistoryFilters()" class="btn-secondary"
              style="padding: 8px 16px; font-size: 13px;">üîÑ ƒê·∫∑t l·∫°i</button>
            <button onclick="exportVipHistoryToCSV()" class="btn-primary"
              style="padding: 8px 16px; font-size: 13px; background: linear-gradient(135deg, var(--accent-green), var(--accent-blue));">üì•
              Xu·∫•t CSV</button>
            <div style="flex: 1;"></div>
            <span id="filterResultCount" style="font-size: 13px; color: var(--text-muted); line-height: 32px;"></span>
          </div>
        </div>

        <div id="vipMemberHistoryContainer"></div>
      </div>
    </div>

    <!-- Tab: Stats -->
    <div id="stats" class="tab-content">
      <div class="glass-card">
        <div class="section-title">üìä Th·ªëng k√™ t·ªïng quan</div>
        <div id="statsContent"></div>
      </div>
    </div>

    <!-- Tab: Backup -->
    <div id="backup" class="tab-content">
      <!-- GitHub Settings -->
      <div class="glass-card">
        <div class="section-title">‚öôÔ∏è C√†i ƒë·∫∑t GitHub</div>

        <div class="alert alert-info">
          <span>‚ÑπÔ∏è</span>
          <div>
            <strong>H∆∞·ªõng d·∫´n setup:</strong><br>
            1. T·∫°o GitHub Personal Access Token t·∫°i <a href="https://github.com/settings/tokens" target="_blank"
              style="color: #60a5fa;">github.com/settings/tokens</a><br>
            2. Ch·ªçn scope: <code>repo</code> (Full control of private repositories)<br>
            3. Copy token v√† paste v√†o √¥ b√™n d∆∞·ªõi<br>
            4. Nh·∫≠p t√™n repository (v√≠ d·ª•: vuhoanganh/OrderHelper)
          </div>
        </div>

        <div class="form-group">
          <label class="form-label">GitHub Personal Access Token</label>
          <input id="githubToken" class="form-input" type="password" placeholder="ghp_xxxxxxxxxxxx">
          <div class="helper-text">Token s·∫Ω ƒë∆∞·ª£c l∆∞u trong localStorage c·ªßa tr√¨nh duy·ªát</div>
        </div>

        <div class="form-row">
          <div class="form-group">
            <label class="form-label">Repository (owner/repo)</label>
            <input id="githubRepo" class="form-input" placeholder="vuhoanganh/OrderHelper">
          </div>
          <div class="form-group">
            <label class="form-label">Branch</label>
            <input id="githubBranch" class="form-input" value="main" placeholder="main">
          </div>
        </div>

        <div class="checkbox-wrapper">
          <input id="githubAutoBackupEnabled" type="checkbox">
          <label class="checkbox-label">
            <strong>B·∫≠t auto-backup</strong><br>
            T·ª± ƒë·ªông backup data l√™n GitHub theo interval ƒë√£ c√†i ƒë·∫∑t
          </label>
        </div>

        <div class="form-group">
          <label class="form-label">Auto-backup Interval (ph√∫t)</label>
          <input id="githubBackupInterval" class="form-input" type="number" min="5" step="5" value="30"
            placeholder="30">
          <div class="helper-text">Th·ªùi gian gi·ªØa c√°c l·∫ßn auto-backup (t·ªëi thi·ªÉu 5 ph√∫t)</div>
        </div>

        <button class="btn btn-primary btn-full" onclick="saveGithubSettings()">
          üíæ L∆∞u c√†i ƒë·∫∑t
        </button>
      </div>

      <!-- Backup Controls -->
      <div class="glass-card">
        <div class="section-title">üîÑ Backup & Restore</div>

        <div id="githubBackupStatus" class="alert alert-info" style="display: none;">
          <span>‚ÑπÔ∏è</span>
          <div id="githubBackupStatusText">Ch∆∞a c√≥ backup n√†o</div>
        </div>

        <div class="summary-grid">
          <div class="summary-item">
            <h3>L·∫ßn backup cu·ªëi</h3>
            <div class="summary-value" id="lastBackupTime">--</div>
            <div class="summary-detail" id="lastBackupCommit">--</div>
          </div>
          <div class="summary-item">
            <h3>Tr·∫°ng th√°i</h3>
            <div class="summary-value" id="backupStatusIndicator">--</div>
            <div class="summary-detail" id="backupStatusDetail">--</div>
          </div>
        </div>

        <div class="btn-group">
          <button class="btn btn-primary" onclick="backupToGithub()" style="flex: 1;">
            üíæ Backup ngay
          </button>
          <button class="btn btn-secondary" onclick="restoreFromGithub()" style="flex: 1;">
            üì• Restore
          </button>
        </div>

        <div class="helper-text" style="margin-top: 16px;">
          <strong>Data s·∫Ω backup:</strong> Order History, VIP List, VIP Transactions
        </div>
      </div>

      <!-- Backup Log -->
      <div class="glass-card">
        <div class="section-title">üìù Backup Log</div>
        <div id="backupLog"
          style="max-height: 300px; overflow-y: auto; font-family: monospace; font-size: 12px; color: var(--text-secondary);">
          Ch∆∞a c√≥ log...
        </div>
      </div>
    </div>

  </div>

  <!-- Modal for Order Details -->
  <div id="orderModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">Chi ti·∫øt ƒë∆°n h√†ng</div>
        <button class="modal-close" onclick="closeModal()">√ó</button>
      </div>
      <div id="modalBody"></div>
    </div>
  </div>

  <script>
    // Global State
    let orderHistory = JSON.parse(localStorage.getItem('orderHistory') || '[]');
    let selectedPrice = null;
    const autoBackupMode = new URLSearchParams(window.location.search).get('autobackup') === 'true';
    const DRAFT_STORAGE_KEY = 'draftOrder';
    const DRAFT_META_KEY = 'draftBackupMeta';
    const DRAFT_DIR = '/Users/alvin/Library/Mobile Documents/com~apple~CloudDocs/Kitchen/drafts';
    const DRAFT_BACKUP_INTERVAL_MS = 30 * 60 * 1000;
    const DRAFT_RETRY_INTERVAL_MS = 5 * 60 * 1000;
    let draftDirty = false;
    let draftBackupIntervalId = null;
    let draftBackupRetryTimeout = null;
    let lastDraftBackupPath = null;
    let debouncedLocalDraftSave;
    let draftBackupInFlight = false;
    let suppressDraftChange = false;
    let lastDebtorPaidSnapshot = null;
    let lastComputedSignature = null;
    let lastSavedSignature = null;
    let lastComputedOrder = null;
    let editingOrderId = null;
    let editingOrderDate = null;
    const VIP_TX_KEY = 'vipTransactions';
    let vipTransactions = [];

    // GitHub Backup Variables
    let githubAutoBackupInterval = null;
    const GITHUB_TOKEN_KEY = 'github_token';
    const GITHUB_REPO_KEY = 'github_repo';
    const GITHUB_BRANCH_KEY = 'github_branch';
    const GITHUB_BACKUP_FOLDER_KEY = 'github_backup_folder';
    const GITHUB_AUTO_BACKUP_ENABLED_KEY = 'github_auto_backup_enabled';
    const GITHUB_BACKUP_INTERVAL_KEY = 'github_backup_interval';
    const GITHUB_LAST_BACKUP_KEY = 'github_last_backup';
    const GITHUB_LAST_COMMIT_SHA_KEY = 'github_last_commit_sha';

    // Smart Name Matcher Class
    class SmartNameMatcher {
      constructor() {
        this.nameMap = new Map(); // normalized ‚Üí {original, data}
      }

      normalize(name) {
        if (!name) return '';
        return name
          .trim()
          .toLowerCase()
          .replace(/\s+/g, '')
          .normalize('NFD')
          .replace(/[\u0300-\u036f]/g, '');
      }

      add(name, data) {
        if (!name || !name.trim()) return;

        const normalized = this.normalize(name);
        const trimmedName = name.trim();

        // Check if already exists
        if (this.nameMap.has(normalized)) {
          const existing = this.nameMap.get(normalized);
          // Update data but keep original name if it's more "complete"
          if (trimmedName.length >= existing.original.length) {
            existing.original = trimmedName;
          }
          existing.data = data;
        } else {
          this.nameMap.set(normalized, {
            original: trimmedName,
            data: data
          });
        }
      }

      find(name) {
        const normalized = this.normalize(name);
        return this.nameMap.get(normalized);
      }

      getOriginalName(name) {
        const found = this.find(name);
        return found ? found.original : name.trim();
      }

      getData(name) {
        const found = this.find(name);
        return found ? found.data : null;
      }

      has(name) {
        const normalized = this.normalize(name);
        return this.nameMap.has(normalized);
      }

      getAllEntries() {
        return Array.from(this.nameMap.values()).map(v => ({
          name: v.original,
          data: v.data
        }));
      }

      clear() {
        this.nameMap.clear();
      }

      // Calculate similarity for fuzzy matching
      calculateSimilarity(str1, str2) {
        const longer = str1.length > str2.length ? str1 : str2;
        const shorter = str1.length > str2.length ? str2 : str1;

        if (longer.includes(shorter)) return 1.0;

        let matches = 0;
        for (let char of shorter) {
          if (longer.includes(char)) matches++;
        }
        return matches / longer.length;
      }

      // Find similar names (for suggestions)
      findSimilar(name, threshold = 0.7) {
        const normalized = this.normalize(name);
        const results = [];

        for (let [key, value] of this.nameMap) {
          const similarity = this.calculateSimilarity(normalized, key);
          if (similarity >= threshold && similarity < 1.0) {
            results.push({
              name: value.original,
              similarity: similarity
            });
          }
        }

        return results.sort((a, b) => b.similarity - a.similarity);
      }
    }

    // Utility Functions
    function formatMoney(x) {
      const neg = x < 0;
      const v = Math.round(Math.abs(x) * 100) / 100;
      return (neg ? '-' : '') + (Number.isInteger(v) ? v.toString() : v.toFixed(2)) + 'ƒë';
    }

    function ceilInt(x) {
      return Math.ceil(x);
    }

    function parseVip(text) {
      const matcher = new SmartNameMatcher();

      text.split(/\n+/).forEach(line => {
        line = line.trim();
        if (!line) return;

        const [name, bal] = line.split('=');
        if (!name) return;

        const v = parseFloat((bal || '0').replace(/[^0-9.\-]/g, ''));
        const balance = isNaN(v) ? 0 : v;

        matcher.add(name, balance);
      });

      // Convert to Map for backward compatibility
      const map = new Map();
      matcher.getAllEntries().forEach(entry => {
        map.set(entry.name, entry.data);
      });

      // Attach matcher for later use
      map._matcher = matcher;

      return map;
    }

    function vipToText(map) {
      return Array.from(map.entries())
        .map(([k, v]) => `${k}=${formatMoney(v)}`)
        .join('\n');
    }

    function persistVipList(text, timestamp = Date.now()) {
      localStorage.setItem('vipList', text);
      localStorage.setItem('vipUpdatedAt', String(timestamp));
    }

    // Update dish name suggestions from order history
    function updateDishNameSuggestions() {
      const datalist = document.getElementById('dishNameHistory');
      if (!datalist) return;

      const seen = new Set();
      const items = [];

      orderHistory.forEach(order => {
        const name = (order?.itemName || '').trim();
        if (!name || seen.has(name)) return;
        seen.add(name);
        const ts = new Date(order?.date || order?.id || 0).getTime() || 0;
        items.push({ name, ts });
      });

      if (items.length === 0) {
        datalist.innerHTML = '';
        return;
      }

      items.sort((a, b) => b.ts - a.ts);
      datalist.innerHTML = items.map(i => `<option value="${i.name.replace(/"/g, '&quot;')}">`).join('');
    }

    function getLatestVipFromHistory() {
      if (!Array.isArray(orderHistory) || orderHistory.length === 0) return null;

      const latest = orderHistory.reduce((acc, order) => {
        const time = new Date(order?.date || order?.id || 0).getTime();
        if (!isFinite(time) || !Array.isArray(order?.vipSnapshot) || order.vipSnapshot.length === 0) return acc;
        if (time > acc.time) {
          return { time, snapshot: order.vipSnapshot };
        }
        return acc;
      }, { time: -Infinity, snapshot: null });

      return latest.snapshot ? latest : null;
    }

    function hydrateVipAreaFromData(options = {}) {
      const vipArea = document.getElementById('vipArea');
      if (!vipArea) return;

      const savedVipText = (localStorage.getItem('vipList') || '').trim();
      const savedUpdatedAt = Number(localStorage.getItem('vipUpdatedAt') || 0);
      const hasSavedTimestamp = Number.isFinite(savedUpdatedAt) && savedUpdatedAt > 0;

      let chosenText = savedVipText;
      let chosenUpdatedAt = hasSavedTimestamp ? savedUpdatedAt : null;

      const latestHistoryVip = getLatestVipFromHistory();
      const shouldUseHistory = latestHistoryVip && (
        options.forceHistory ||
        !chosenText ||
        !hasSavedTimestamp || // n·∫øu ch∆∞a t·ª´ng ghi timestamp th√¨ l·∫•y d·ªØ li·ªáu m·ªõi nh·∫•t t·ª´ history
        latestHistoryVip.time > savedUpdatedAt
      );

      if (shouldUseHistory) {
        const map = new Map(latestHistoryVip.snapshot);
        chosenText = vipToText(map);
        chosenUpdatedAt = latestHistoryVip.time;
      }

      if (chosenText) {
        vipArea.value = chosenText;
        persistVipList(chosenText, chosenUpdatedAt || Date.now());
      }
    }

    function formatDate(date) {
      const d = new Date(date);
      return d.toLocaleDateString('vi-VN', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      });
    }

    function debounce(fn, wait) {
      let t;
      return (...args) => {
        clearTimeout(t);
        t = setTimeout(() => fn.apply(null, args), wait);
      };
    }

    // ========== GitHub Backup Functions ==========

    function addBackupLog(message) {
      const logDiv = document.getElementById('backupLog');
      if (!logDiv) return;
      const timestamp = new Date().toLocaleTimeString('vi-VN');
      const line = `[${timestamp}] ${message}`;
      if (logDiv.textContent === 'Ch∆∞a c√≥ log...') {
        logDiv.textContent = line;
      } else {
        logDiv.textContent = line + '\n' + logDiv.textContent;
      }
      // Keep only last 50 lines
      const lines = logDiv.textContent.split('\n');
      if (lines.length > 50) {
        logDiv.textContent = lines.slice(0, 50).join('\n');
      }
    }

    function showBackupStatus(message, type = 'info') {
      const statusDiv = document.getElementById('githubBackupStatus');
      const textDiv = document.getElementById('githubBackupStatusText');
      if (!statusDiv || !textDiv) return;

      textDiv.textContent = message;
      statusDiv.style.display = 'flex';
      statusDiv.className = `alert alert-${type}`;

      // Auto-hide after 5 seconds for success/info messages
      if (type === 'success' || type === 'info') {
        setTimeout(() => {
          statusDiv.style.display = 'none';
        }, 5000);
      }
    }

    async function githubApiRequest(endpoint, method = 'GET', body = null) {
      const token = localStorage.getItem(GITHUB_TOKEN_KEY);
      if (!token) {
        throw new Error('GitHub token kh√¥ng t√¨m th·∫•y. Vui l√≤ng c√†i ƒë·∫∑t token trong tab Backup.');
      }

      const url = `https://api.github.com${endpoint}`;
      const headers = {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/vnd.github.v3+json',
        'Content-Type': 'application/json'
      };

      const options = {
        method,
        headers
      };

      if (body) {
        options.body = JSON.stringify(body);
      }

      const response = await fetch(url, options);

      if (!response.ok) {
        const error = await response.json().catch(() => ({ message: response.statusText }));
        throw new Error(`GitHub API Error: ${error.message || response.statusText}`);
      }

      // Handle 204 No Content
      if (response.status === 204) {
        return null;
      }

      return await response.json();
    }

    async function getGithubFile(owner, repo, path, branch = 'main') {
      try {
        const data = await githubApiRequest(`/repos/${owner}/${repo}/contents/${path}?ref=${branch}`);
        if (data && data.content) {
          // Decode base64 content
          const content = atob(data.content.replace(/\n/g, ''));
          return {
            content,
            sha: data.sha
          };
        }
        return null;
      } catch (err) {
        // File not found is not an error in this case
        if (err.message.includes('Not Found') || err.message.includes('404')) {
          return null;
        }
        throw err;
      }
    }

    async function createOrUpdateGithubFile(owner, repo, path, content, message, sha = null) {
      const body = {
        message,
        content: btoa(unescape(encodeURIComponent(content))), // Encode to base64 with UTF-8 support
        branch: localStorage.getItem(GITHUB_BRANCH_KEY) || 'main'
      };

      if (sha) {
        body.sha = sha; // Required when updating existing file
      }

      return await githubApiRequest(`/repos/${owner}/${repo}/contents/${path}`, 'PUT', body);
    }

    function formatDraftTime(ts) {
      if (!ts) return '‚Äî';
      return new Date(ts).toLocaleString('vi-VN', { hour12: false });
    }

    function normalizeVipTransactions(data = []) {
      if (!Array.isArray(data)) return [];
      const normalized = data.map((tx, idx) => {
        const amount = Number(tx?.amount);
        const idTs = Number(tx?.id);
        const parsedIdDate = isFinite(idTs) ? new Date(idTs) : null;
        const hasValidIdDate = parsedIdDate && isFinite(parsedIdDate.getTime());
        const tsSource = tx?.ts || (hasValidIdDate ? parsedIdDate.toISOString() : null);
        const parsedTs = tsSource ? new Date(tsSource) : null;
        const hasValidTs = parsedTs && isFinite(parsedTs.getTime());

        return {
          id: hasValidIdDate ? idTs : Date.now() + idx,
          ts: hasValidTs ? parsedTs.toISOString() : (hasValidIdDate ? parsedIdDate.toISOString() : new Date().toISOString()),
          name: (tx?.name || '').trim(),
          amount: isFinite(amount) ? amount : 0,
          type: tx?.type || (amount >= 0 ? 'topup' : 'cashout')
        };
      }).filter(tx => tx.name);

      localStorage.setItem(VIP_TX_KEY, JSON.stringify(normalized.slice(0, 200)));
      return normalized;
    }

    function buildOrderSignature(data = {}) {
      const normalizedDetails = Array.isArray(data.details) ? data.details.map(d => ({
        name: d.name,
        qty: d.qty,
        shipQty: d.shipQty || d.shipParts || 0,
        paid: !!d.paid,
        due: Number(d.due || 0),
        unitPrice: d.unitPrice
      })) : [];

      return JSON.stringify({
        itemName: data.itemName || '',
        totalParts: data.totalParts || 0,
        alvinFree: !!data.alvinFree,
        totalCostInput: Number(data.totalCostInput || 0),
        costPerUnitInput: Number(data.costPerUnitInput || 0),
        shipFee: Number(data.shipFee || 0),
        targetProfit: Number(data.targetProfit || 0),
        priceNonShip: Number(data.priceNonShip || 0),
        priceShip: Number(data.priceShip || data.priceNonShip || 0),
        splitShipMode: !!data.splitShipMode,
        details: normalizedDetails
      });
    }

    function recordVipTransaction({ name, amount, type }) {
      if (!name || !Number.isFinite(amount)) return;
      const entry = {
        id: Date.now(),
        ts: new Date().toISOString(),
        name: name.trim(),
        amount,
        type: type || (amount >= 0 ? 'topup' : 'cashout')
      };
      vipTransactions.unshift(entry);
      vipTransactions = vipTransactions.slice(0, 200);
      localStorage.setItem(VIP_TX_KEY, JSON.stringify(vipTransactions));
      renderVipHistory();
      populateVipMemberSelect();
    }

    function renderVipHistory() {
      const container = document.getElementById('vipHistory');
      if (!container) return;

      if (!vipTransactions.length) {
        container.innerHTML = '<div class="empty-state" style="padding:12px 0;">Ch∆∞a c√≥ giao d·ªãch VIP</div>';
        return;
      }

      const html = `
    <ul class="mini-list">
      ${vipTransactions.slice(0, 20).map(tx => `
        <li>
          <div>
            <div><strong>${tx.name}</strong> ‚Ä¢ ${tx.type === 'cashout' ? 'R√∫t' : 'N·∫°p'}</div>
            <div class="note">${formatDate(tx.ts)}</div>
          </div>
          <div class="${tx.amount >= 0 ? 'amount-positive' : 'amount-negative'}">
            ${tx.amount >= 0 ? '+' : ''}${formatMoney(tx.amount)}
          </div>
        </li>
      `).join('')}
    </ul>
  `;
      container.innerHTML = html;
    }

    // Extract order transactions for a specific VIP member
    function getVipOrderTransactions(vipName) {
      const orderTxs = [];
      const normalizedVipName = vipName.trim().toLowerCase();

      console.log('=== DEBUG getVipOrderTransactions ===');
      console.log('Looking for VIP:', vipName, '(normalized:', normalizedVipName + ')');
      console.log('Total orders in history:', orderHistory.length);

      orderHistory.forEach((order, idx) => {
        // Debug first order structure
        if (idx === 0) {
          console.log('First order structure:', {
            id: order.id,
            ts: order.ts,
            itemName: order.itemName,
            hasDetails: !!order.details,
            detailsIsArray: Array.isArray(order.details),
            detailsLength: order.details?.length
          });
        }

        if (!order.details || !Array.isArray(order.details)) {
          if (idx < 3) console.log(`Order ${idx}: No details array`);
          return;
        }

        // Use order.id as timestamp (that's where it's stored)
        const timestamp = order.id;
        if (!timestamp || isNaN(parseInt(timestamp))) {
          if (idx < 3) console.log(`Order ${idx}: Invalid ID/timestamp`);
          return;
        }

        order.details.forEach((detail, detailIdx) => {
          const detailName = (detail.name || '').trim();
          const normalizedDetailName = detailName.toLowerCase();

          // Debug: log all detail names to see what we have
          if (idx < 3) {
            console.log(`Order ${idx}, Detail ${detailIdx}: name="${detailName}", due=${detail.due}, paid=${detail.paid}`);
          }

          if (normalizedDetailName === normalizedVipName && detail.due) {
            const date = new Date(parseInt(timestamp));
            if (isNaN(date.getTime())) return;

            console.log('‚úÖ MATCH FOUND:', detailName, 'due:', detail.due);

            orderTxs.push({
              id: timestamp + '_' + detailName,
              ts: date.toISOString(),
              name: vipName,
              amount: -Math.abs(detail.due),
              type: 'order',
              itemName: order.itemName || 'Order',
              paid: detail.paid || false
            });
          }
        });
      });

      console.log('Total order transactions found:', orderTxs.length);
      console.log('=== END DEBUG ===');

      return orderTxs;
    }

    // Get icon for transaction type
    function getTransactionIcon(type) {
      switch (type) {
        case 'topup': return 'üí∞';
        case 'cashout': return 'üí∏';
        case 'order': return 'üçú';
        default: return 'üìù';
      }
    }

    // Get label for transaction
    function getTransactionLabel(tx) {
      switch (tx.type) {
        case 'topup': return 'N·∫°p ti·ªÅn';
        case 'cashout': return 'R√∫t ti·ªÅn';
        case 'order': return 'Order m√≥n ƒÉn';
        default: return 'Giao d·ªãch';
      }
    }

    // VIP Member Transaction History Functions
    function populateVipMemberSelect() {
      const select = document.getElementById('vipMemberSelect');
      if (!select) return;

      // Get unique VIP names from transactions
      const vipNames = new Set();
      vipTransactions.forEach(tx => {
        if (tx.name) vipNames.add(tx.name);
      });

      // Also add VIP names from current VIP list
      const vipArea = document.getElementById('vipArea');
      if (vipArea) {
        const vipMap = parseVip(vipArea.value);
        vipMap.forEach((_, name) => vipNames.add(name));
      }

      // Sort and populate
      const sortedNames = Array.from(vipNames).sort();
      select.innerHTML = '<option value="">-- Ch·ªçn VIP --</option>' +
        sortedNames.map(name => `<option value="${name}">${name}</option>`).join('');
    }
    // Store all transactions globally for filtering
    let currentVipTransactions = [];

    // VIP History Functions
    function saveInitialBalance() {
      const vipName = document.getElementById('vipMemberSelect').value;
      const balance = document.getElementById('vipInitialBalance').value;

      if (!vipName) return;

      // Save to localStorage
      const key = `vipInitialBalance_${vipName}`;
      localStorage.setItem(key, balance || '0');

      // Recalculate history
      showVipMemberHistory();
    }

    function showVipMemberHistory() {
      const select = document.getElementById('vipMemberSelect');
      const container = document.getElementById('vipMemberHistoryContainer');
      const filtersDiv = document.getElementById('vipHistoryFilters');
      if (!select || !container) return;

      const selectedName = select.value;
      if (!selectedName) {
        container.innerHTML = '';
        if (filtersDiv) filtersDiv.style.display = 'none';
        return;
      }

      // Show filters
      if (filtersDiv) filtersDiv.style.display = 'block';

      // Get cash transactions (topup/cashout)
      const cashTxs = vipTransactions.filter(tx => tx.name === selectedName);

      // Get order transactions
      const orderTxs = getVipOrderTransactions(selectedName);

      // Combine all transactions
      const allTxs = [...cashTxs, ...orderTxs]
        .sort((a, b) => new Date(b.ts).getTime() - new Date(a.ts).getTime());

      if (allTxs.length === 0) {
        container.innerHTML = '<div class="empty-state" style="padding: 12px 0;">Ch∆∞a c√≥ giao d·ªãch n√†o</div>';
        return;
      }

      // Get current balance from VIP list
      const vipArea = document.getElementById('vipArea');
      const currentBalance = vipArea ? (parseVip(vipArea.value).get(selectedName) || 0) : 0;

      // Calculate running balance correctly
      // Start from initial balance
      const initialBalance = parseFloat(localStorage.getItem(`vipInitialBalance_${selectedName}`) || '0');
      let runningBalance = initialBalance;
      const sortedOldestFirst = [...allTxs].sort((a, b) =>
        new Date(a.ts).getTime() - new Date(b.ts).getTime()
      );

      // Calculate what initial balance should be to end up with currentBalance
      const totalChange = sortedOldestFirst.reduce((sum, tx) => sum + tx.amount, 0);

      // Now calculate balance AFTER each transaction (chronological order)
      const txsWithBalance = sortedOldestFirst.map(tx => {
        runningBalance += tx.amount;
        return { ...tx, balance: runningBalance };
      });

      // Store for filtering
      currentVipTransactions = txsWithBalance;

      // Render with current filters
      renderVipHistoryTable(selectedName, currentBalance, txsWithBalance);
    }

    function renderVipHistoryTable(selectedName, currentBalance, transactions) {
      const container = document.getElementById('vipMemberHistoryContainer');
      if (!container) return;

      // Count transaction types
      const topupCount = transactions.filter(tx => tx.type === 'topup').length;
      const cashoutCount = transactions.filter(tx => tx.type === 'cashout').length;
      const orderCount = transactions.filter(tx => tx.type === 'order').length;

      // Compact date format function
      const compactDate = (dateStr) => {
        const d = new Date(dateStr);
        const day = String(d.getDate()).padStart(2, '0');
        const month = String(d.getMonth() + 1).padStart(2, '0');
        const year = d.getFullYear();
        const hours = String(d.getHours()).padStart(2, '0');
        const minutes = String(d.getMinutes()).padStart(2, '0');
        return `${day}/${month}/${year} ${hours}:${minutes}`;
      };

      // Render compact table
      const html = `
        <div style="margin-top: 16px;">
          <!-- Header with summary -->
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; padding: 12px 16px; background: linear-gradient(135deg, rgba(99,102,241,0.1), rgba(168,85,247,0.1)); border-radius: 12px; border: 1px solid rgba(99,102,241,0.2);">
            <div>
              <div style="font-size: 14px; color: var(--text-muted); margin-bottom: 2px;">VIP Member</div>
              <div style="font-size: 18px; font-weight: 600; color: var(--text-primary);">${selectedName}</div>
            </div>
            <div style="text-align: right;">
              <div style="font-size: 14px; color: var(--text-muted); margin-bottom: 2px;">S·ªë d∆∞ hi·ªán t·∫°i</div>
              <div style="font-size: 22px; font-weight: 700; color: ${currentBalance >= 0 ? 'var(--accent-green)' : 'var(--accent-red)'};">
                ${formatMoney(currentBalance)}
              </div>
            </div>
          </div>

          <!-- Transaction table -->
          <div style="border-radius: 12px; overflow: hidden; border: 1px solid rgba(255,255,255,0.08);">
            <div style="max-height: 60vh; overflow-y: auto; overflow-x: auto; background: var(--glass-bg);">
              <table style="width: 100%; min-width: 700px; border-collapse: collapse; font-size: 13px;">
                <thead style="position: sticky; top: 0; background: rgba(30,30,50,0.95); backdrop-filter: blur(10px); z-index: 1;">
                  <tr>
                    <th style="padding: 10px 12px; text-align: left; font-weight: 600; color: var(--text-muted); border-bottom: 2px solid rgba(255,255,255,0.1); white-space: nowrap;">üìÖ Ng√†y gi·ªù</th>
                    <th style="padding: 10px 12px; text-align: left; font-weight: 600; color: var(--text-muted); border-bottom: 2px solid rgba(255,255,255,0.1); white-space: nowrap;">Lo·∫°i</th>
                    <th style="padding: 10px 12px; text-align: right; font-weight: 600; color: var(--text-muted); border-bottom: 2px solid rgba(255,255,255,0.1); white-space: nowrap;">S·ªë ti·ªÅn</th>
                    <th style="padding: 10px 12px; text-align: left; font-weight: 600; color: var(--text-muted); border-bottom: 2px solid rgba(255,255,255,0.1);">Chi ti·∫øt</th>
                    <th style="padding: 10px 12px; text-align: right; font-weight: 600; color: var(--text-muted); border-bottom: 2px solid rgba(255,255,255,0.1); white-space: nowrap;">S·ªë d∆∞</th>
                  </tr>
                </thead>
                <tbody>
                  ${transactions.map((tx, idx) => {
        const isEven = idx % 2 === 0;
        const bgColor = isEven ? 'rgba(255,255,255,0.02)' : 'transparent';
        const typeLabel = tx.type === 'topup' ? 'üí∞ N·∫°p' : tx.type === 'cashout' ? 'üí∏ R√∫t' : 'üçú Order';
        const amountColor = tx.amount >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';
        const balanceColor = tx.balance >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';

        return `
                      <tr style="background: ${bgColor}; transition: background 0.2s;" onmouseover="this.style.background='rgba(99,102,241,0.08)'" onmouseout="this.style.background='${bgColor}'">
                        <td style="padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,0.05); color: var(--text-secondary); white-space: nowrap;">${compactDate(tx.ts)}</td>
                        <td style="padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,0.05); white-space: nowrap;">${typeLabel}</td>
                        <td style="padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,0.05); text-align: right; font-weight: 600; color: ${amountColor}; white-space: nowrap;">
                          ${tx.amount >= 0 ? '+' : ''}${formatMoney(tx.amount)}
                        </td>
                        <td style="padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,0.05); color: var(--text-secondary);">
                          ${tx.type === 'order' ? `${tx.itemName} ${tx.paid ? '‚úÖ' : '‚è≥'}` : '-'}
                        </td>
                        <td style="padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,0.05); text-align: right; font-weight: 600; color: ${balanceColor}; white-space: nowrap;">
                          ${formatMoney(tx.balance)}
                        </td>
                      </tr>
                    `;
      }).join('')}
                </tbody>
              </table>
            </div>
          </div>

          <!-- Summary footer -->
          <div style="margin-top: 12px; padding: 12px 16px; background: rgba(255,255,255,0.03); border-radius: 12px; border: 1px solid rgba(255,255,255,0.08);">
            <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 8px;">
              <div style="font-size: 13px; color: var(--text-muted);">
                <strong style="color: var(--text-primary);">T·ªïng: ${transactions.length}</strong> giao d·ªãch
              </div>
              <div style="font-size: 13px; color: var(--text-muted); display: flex; gap: 16px;">
                <span>üí∞ N·∫°p: <strong style="color: var(--accent-green);">${topupCount}</strong></span>
                <span>üí∏ R√∫t: <strong style="color: var(--accent-yellow);">${cashoutCount}</strong></span>
                <span>üçú Order: <strong style="color: var(--accent-blue);">${orderCount}</strong></span>
              </div>
            </div>
          </div>
        </div>
      `;

      container.innerHTML = html;
    }

    // Apply filters to VIP history
    function applyVipHistoryFilters() {
      if (currentVipTransactions.length === 0) return;

      const select = document.getElementById('vipMemberSelect');
      const vipArea = document.getElementById('vipArea');
      const selectedName = select ? select.value : '';
      const currentBalance = vipArea ? (parseVip(vipArea.value).get(selectedName) || 0) : 0;

      // Get filter values
      const dateFrom = document.getElementById('filterDateFrom')?.value;
      const dateTo = document.getElementById('filterDateTo')?.value;
      const txType = document.getElementById('filterTxType')?.value || 'all';
      const paymentStatus = document.getElementById('filterPaymentStatus')?.value || 'all';

      // Apply filters
      let filtered = [...currentVipTransactions];

      // Date range filter
      if (dateFrom) {
        const fromDate = new Date(dateFrom);
        fromDate.setHours(0, 0, 0, 0);
        filtered = filtered.filter(tx => new Date(tx.ts) >= fromDate);
      }
      if (dateTo) {
        const toDate = new Date(dateTo);
        toDate.setHours(23, 59, 59, 999);
        filtered = filtered.filter(tx => new Date(tx.ts) <= toDate);
      }

      // Transaction type filter
      if (txType !== 'all') {
        filtered = filtered.filter(tx => tx.type === txType);
      }

      // Payment status filter (only for orders)
      if (paymentStatus !== 'all') {
        filtered = filtered.filter(tx => {
          if (tx.type !== 'order') return true; // Keep non-order transactions
          return paymentStatus === 'paid' ? tx.paid : !tx.paid;
        });
      }

      // Update result count
      const countSpan = document.getElementById('filterResultCount');
      if (countSpan) {
        countSpan.textContent = `Hi·ªÉn th·ªã ${filtered.length}/${currentVipTransactions.length} giao d·ªãch`;
      }

      // Render filtered results
      renderVipHistoryTable(selectedName, currentBalance, filtered);
    }

    // Clear all filters
    function clearVipHistoryFilters() {
      document.getElementById('filterDateFrom').value = '';
      document.getElementById('filterDateTo').value = '';
      document.getElementById('filterTxType').value = 'all';
      document.getElementById('filterPaymentStatus').value = 'all';

      const countSpan = document.getElementById('filterResultCount');
      if (countSpan) countSpan.textContent = '';

      // Re-render with all transactions
      const select = document.getElementById('vipMemberSelect');
      const vipArea = document.getElementById('vipArea');
      const selectedName = select ? select.value : '';
      const currentBalance = vipArea ? (parseVip(vipArea.value).get(selectedName) || 0) : 0;

      renderVipHistoryTable(selectedName, currentBalance, currentVipTransactions);
    }

    // Export VIP history to CSV
    function exportVipHistoryToCSV() {
      const select = document.getElementById('vipMemberSelect');
      if (!select || !select.value) {
        alert('‚ö†Ô∏è Vui l√≤ng ch·ªçn VIP member tr∆∞·ªõc khi xu·∫•t CSV');
        return;
      }

      const selectedName = select.value;

      // Get currently displayed transactions (respecting filters)
      const vipArea = document.getElementById('vipArea');
      const currentBalance = vipArea ? (parseVip(vipArea.value).get(selectedName) || 0) : 0;

      // Get filter values to determine which transactions to export
      const dateFrom = document.getElementById('filterDateFrom')?.value;
      const dateTo = document.getElementById('filterDateTo')?.value;
      const txType = document.getElementById('filterTxType')?.value || 'all';
      const paymentStatus = document.getElementById('filterPaymentStatus')?.value || 'all';

      // Apply same filters as display
      let transactions = [...currentVipTransactions];

      if (dateFrom) {
        const fromDate = new Date(dateFrom);
        fromDate.setHours(0, 0, 0, 0);
        transactions = transactions.filter(tx => new Date(tx.ts) >= fromDate);
      }
      if (dateTo) {
        const toDate = new Date(dateTo);
        toDate.setHours(23, 59, 59, 999);
        transactions = transactions.filter(tx => new Date(tx.ts) <= toDate);
      }
      if (txType !== 'all') {
        transactions = transactions.filter(tx => tx.type === txType);
      }
      if (paymentStatus !== 'all') {
        transactions = transactions.filter(tx => {
          if (tx.type !== 'order') return true;
          return paymentStatus === 'paid' ? tx.paid : !tx.paid;
        });
      }

      if (transactions.length === 0) {
        alert('‚ö†Ô∏è Kh√¥ng c√≥ giao d·ªãch n√†o ƒë·ªÉ xu·∫•t');
        return;
      }

      // Format date for CSV
      const formatDateCSV = (dateStr) => {
        const d = new Date(dateStr);
        const day = String(d.getDate()).padStart(2, '0');
        const month = String(d.getMonth() + 1).padStart(2, '0');
        const year = d.getFullYear();
        const hours = String(d.getHours()).padStart(2, '0');
        const minutes = String(d.getMinutes()).padStart(2, '0');
        return `${day}/${month}/${year} ${hours}:${minutes}`;
      };

      // Get transaction type label
      const getTypeLabel = (type) => {
        if (type === 'topup') return 'N·∫°p ti·ªÅn';
        if (type === 'cashout') return 'R√∫t ti·ªÅn';
        if (type === 'order') return 'Order';
        return 'Giao d·ªãch';
      };

      // Format amount for CSV (remove 'ƒë' suffix)
      const formatAmountCSV = (amount) => {
        return amount.toFixed(0);
      };

      // Build CSV content
      let csv = [];

      // Add UTF-8 BOM for Excel compatibility with Vietnamese characters
      csv.push('\uFEFF');

      // Add header info
      csv.push(`VIP Member: ${selectedName}\n`);
      csv.push(`S·ªë d∆∞ hi·ªán t·∫°i: ${formatAmountCSV(currentBalance)}ƒë\n`);
      csv.push(`Ng√†y xu·∫•t: ${formatDateCSV(new Date().toISOString())}\n`);
      csv.push(`T·ªïng s·ªë giao d·ªãch: ${transactions.length}\n`);
      csv.push('\n');

      // Add table header
      csv.push('Ng√†y gi·ªù,Lo·∫°i,S·ªë ti·ªÅn (ƒë),Chi ti·∫øt,S·ªë d∆∞ (ƒë)\n');

      // Add transaction rows
      transactions.forEach(tx => {
        const date = formatDateCSV(tx.ts);
        const type = getTypeLabel(tx.type);
        const amount = formatAmountCSV(tx.amount);
        const detail = tx.type === 'order'
          ? `${tx.itemName} ${tx.paid ? '[ƒê√£ tr·∫£]' : '[Ch∆∞a tr·∫£]'}`
          : '-';
        const balance = formatAmountCSV(tx.balance);

        // Escape commas and quotes in detail field
        const escapedDetail = detail.replace(/"/g, '""');
        const detailField = detail.includes(',') ? `"${escapedDetail}"` : detail;

        csv.push(`${date},${type},${amount},${detailField},${balance}\n`);
      });

      // Add summary footer
      csv.push('\n');
      const topupCount = transactions.filter(tx => tx.type === 'topup').length;
      const cashoutCount = transactions.filter(tx => tx.type === 'cashout').length;
      const orderCount = transactions.filter(tx => tx.type === 'order').length;
      csv.push(`T·ªïng h·ª£p:,N·∫°p: ${topupCount} l·∫ßn,R√∫t: ${cashoutCount} l·∫ßn,Order: ${orderCount} l·∫ßn,\n`);

      // Create blob and download
      const csvContent = csv.join('');
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');

      // Generate filename with date
      const now = new Date();
      const dateStr = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}`;
      const filename = `vip_transactions_${selectedName.replace(/\s+/g, '_')}_${dateStr}.csv`;

      link.href = URL.createObjectURL(blob);
      link.download = filename;
      link.style.display = 'none';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);

      // Show success message
      const filterCount = document.getElementById('filterResultCount');
      if (filterCount) {
        const originalText = filterCount.textContent;
        filterCount.innerHTML = `<span style="color: var(--accent-green);">‚úÖ ƒê√£ xu·∫•t ${transactions.length} giao d·ªãch</span>`;
        setTimeout(() => {
          filterCount.textContent = originalText;
        }, 3000);
      }
    }

    // ========== Global Search Functions ==========

    let searchTimeout = null;

    function handleGlobalSearch(query) {
      const resultsContainer = document.getElementById('searchResults');
      const clearBtn = document.querySelector('.search-clear');

      // Show/hide clear button
      clearBtn.style.display = query ? 'block' : 'none';

      if (!query || query.trim().length < 2) {
        resultsContainer.classList.remove('show');
        return;
      }

      // Debounce search
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(() => {
        const results = searchAllData(query.trim());
        renderSearchResults(results);
      }, 200);
    }

    function searchAllData(query) {
      const lowerQuery = query.toLowerCase();
      const results = {
        vips: [],
        orders: [],
        items: []
      };

      // Search VIPs
      const vipArea = document.getElementById('vipArea');
      if (vipArea) {
        const vipMap = parseVip(vipArea.value);
        vipMap.forEach((balance, name) => {
          if (name.toLowerCase().includes(lowerQuery)) {
            results.vips.push({ name, balance });
          }
        });
      }

      // Search Orders
      orderHistory.forEach(order => {
        const itemMatch = order.itemName && order.itemName.toLowerCase().includes(lowerQuery);
        const dateStr = formatDate(order.date || order.id);
        const dateMatch = dateStr.toLowerCase().includes(lowerQuery);

        // Search in order details (VIP names)
        let detailMatch = false;
        if (order.details && Array.isArray(order.details)) {
          detailMatch = order.details.some(d =>
            d.name && d.name.toLowerCase().includes(lowerQuery)
          );
        }

        if (itemMatch || dateMatch || detailMatch) {
          results.orders.push(order);
        }
      });

      // Search unique item names
      const itemCounts = new Map();
      orderHistory.forEach(order => {
        if (order.itemName) {
          const itemLower = order.itemName.toLowerCase();
          if (itemLower.includes(lowerQuery)) {
            itemCounts.set(order.itemName, (itemCounts.get(order.itemName) || 0) + 1);
          }
        }
      });

      itemCounts.forEach((count, item) => {
        results.items.push({ name: item, count });
      });

      // Limit results
      results.vips = results.vips.slice(0, 5);
      results.orders = results.orders.slice(0, 5);
      results.items = results.items.slice(0, 5);

      return results;
    }

    function renderSearchResults(results) {
      const container = document.getElementById('searchResults');
      const hasResults = results.vips.length > 0 || results.orders.length > 0 || results.items.length > 0;

      if (!hasResults) {
        container.innerHTML = '<div class="search-no-results">‚ùå Kh√¥ng t√¨m th·∫•y k·∫øt qu·∫£</div>';
        container.classList.add('show');
        return;
      }

      let html = '';

      // VIP Results
      if (results.vips.length > 0) {
        html += '<div class="search-result-section">';
        html += '<div class="search-section-title">üë• VIP Members</div>';
        results.vips.forEach(vip => {
          const balanceClass = vip.balance >= 0 ? 'positive' : 'negative';
          html += `
            <div class="search-result-item" onclick="goToVip('${vip.name}')">
              <span class="search-result-icon">üë§</span>
              <div class="search-result-content">
                <div class="search-result-title">${vip.name}</div>
                <div class="search-result-subtitle">
                  <span class="balance-badge ${balanceClass}">${formatMoney(vip.balance)}</span>
                </div>
              </div>
            </div>
          `;
        });
        html += '</div>';
      }

      // Order Results
      if (results.orders.length > 0) {
        html += '<div class="search-result-section">';
        html += '<div class="search-section-title">üìã Orders</div>';
        results.orders.forEach(order => {
          const dateStr = formatDate(order.date || order.id);
          html += `
            <div class="search-result-item" onclick="goToOrder(${order.id})">
              <span class="search-result-icon">üçú</span>
              <div class="search-result-content">
                <div class="search-result-title">${order.itemName}</div>
                <div class="search-result-subtitle">${dateStr}</div>
              </div>
            </div>
          `;
        });
        html += '</div>';
      }

      // Item Results
      if (results.items.length > 0) {
        html += '<div class="search-result-section">';
        html += '<div class="search-section-title">üçΩÔ∏è Items</div>';
        results.items.forEach(item => {
          html += `
            <div class="search-result-item" onclick="searchOrdersByItem('${item.name}')">
              <span class="search-result-icon">üîç</span>
              <div class="search-result-content">
                <div class="search-result-title">${item.name}</div>
                <div class="search-result-subtitle">
                  <span class="count-badge">${item.count} ƒë∆°n</span>
                </div>
              </div>
            </div>
          `;
        });
        html += '</div>';
      }

      container.innerHTML = html;
      container.classList.add('show');
    }

    function clearGlobalSearch() {
      document.getElementById('globalSearch').value = '';
      document.getElementById('searchResults').classList.remove('show');
      document.querySelector('.search-clear').style.display = 'none';
    }

    function goToVip(vipName) {
      clearGlobalSearch();
      switchTab(null, 'debt');

      // Select VIP in dropdown
      setTimeout(() => {
        const select = document.getElementById('vipMemberSelect');
        if (select) {
          select.value = vipName;
          showVipMemberHistory();
          select.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
      }, 100);
    }

    function goToOrder(orderId) {
      clearGlobalSearch();
      switchTab(null, 'history');

      // Highlight and scroll to order
      setTimeout(() => {
        viewOrderDetails(orderId);
      }, 100);
    }

    function searchOrdersByItem(itemName) {
      clearGlobalSearch();
      switchTab(null, 'history');

      // TODO: Could add filter functionality here
      console.log('Search orders for item:', itemName);
    }

    // Keyboard shortcut: Ctrl+K to focus search
    document.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
        e.preventDefault();
        document.getElementById('globalSearch').focus();
      }

      // ESC to close search results
      if (e.key === 'Escape') {
        clearGlobalSearch();
      }
    });

    // ========== GitHub Settings & Main Functions ==========

    function saveGithubSettings() {
      const token = document.getElementById('githubToken').value.trim();
      const repo = document.getElementById('githubRepo').value.trim();
      const branch = document.getElementById('githubBranch').value.trim();
      const autoBackupEnabled = document.getElementById('githubAutoBackupEnabled').checked;
      const interval = parseInt(document.getElementById('githubBackupInterval').value) || 30;

      if (!token || !repo) {
        alert('‚ö†Ô∏è Vui l√≤ng nh·∫≠p GitHub Token v√† Repository!');
        return;
      }

      // Validate repo format
      if (!repo.includes('/')) {
        alert('‚ö†Ô∏è Repository ph·∫£i c√≥ format: owner/repo (v√≠ d·ª•: vuhoanganh/OrderHelper)');
        return;
      }

      // Save to localStorage
      localStorage.setItem(GITHUB_TOKEN_KEY, token);
      localStorage.setItem(GITHUB_REPO_KEY, repo);
      localStorage.setItem(GITHUB_BRANCH_KEY, branch || 'main');
      localStorage.setItem(GITHUB_AUTO_BACKUP_ENABLED_KEY, autoBackupEnabled);
      localStorage.setItem(GITHUB_BACKUP_INTERVAL_KEY, interval);

      addBackupLog('‚úÖ ƒê√£ l∆∞u c√†i ƒë·∫∑t GitHub');
      showBackupStatus('‚úÖ ƒê√£ l∆∞u c√†i ƒë·∫∑t th√†nh c√¥ng!', 'success');

      // Restart auto-backup if enabled
      if (autoBackupEnabled) {
        initGithubAutoBackup();
        addBackupLog(`üîÑ ƒê√£ b·∫≠t auto-backup (m·ªói ${interval} ph√∫t)`);
      } else {
        if (githubAutoBackupInterval) {
          clearInterval(githubAutoBackupInterval);
          githubAutoBackupInterval = null;
          addBackupLog('‚è∏Ô∏è ƒê√£ t·∫Øt auto-backup');
        }
      }

      alert('‚úÖ ƒê√£ l∆∞u c√†i ƒë·∫∑t GitHub!');
    }

    function loadGithubSettings() {
      const token = localStorage.getItem(GITHUB_TOKEN_KEY) || '';
      const repo = localStorage.getItem(GITHUB_REPO_KEY) || '';
      const branch = localStorage.getItem(GITHUB_BRANCH_KEY) || 'main';
      const autoBackupEnabled = localStorage.getItem(GITHUB_AUTO_BACKUP_ENABLED_KEY) === 'true';
      const interval = parseInt(localStorage.getItem(GITHUB_BACKUP_INTERVAL_KEY)) || 30;

      document.getElementById('githubToken').value = token;
      document.getElementById('githubRepo').value = repo;
      document.getElementById('githubBranch').value = branch;
      document.getElementById('githubAutoBackupEnabled').checked = autoBackupEnabled;
      document.getElementById('githubBackupInterval').value = interval;

      // Update last backup display
      updateBackupStatusDisplay();

      // Start auto-backup if enabled
      if (autoBackupEnabled && token && repo) {
        initGithubAutoBackup();
      }
    }

    function updateBackupStatusDisplay() {
      const lastBackupTime = localStorage.getItem(GITHUB_LAST_BACKUP_KEY);
      const lastCommitSha = localStorage.getItem(GITHUB_LAST_COMMIT_SHA_KEY);

      const timeElem = document.getElementById('lastBackupTime');
      const commitElem = document.getElementById('lastBackupCommit');
      const statusElem = document.getElementById('backupStatusIndicator');
      const detailElem = document.getElementById('backupStatusDetail');

      if (timeElem) {
        if (lastBackupTime) {
          const date = new Date(parseInt(lastBackupTime));
          timeElem.textContent = formatDate(date);
        } else {
          timeElem.textContent = 'Ch∆∞a backup';
        }
      }

      if (commitElem) {
        if (lastCommitSha) {
          commitElem.textContent = `Commit: ${lastCommitSha.substring(0, 7)}`;
        } else {
          commitElem.textContent = '--';
        }
      }

      if (statusElem && detailElem) {
        const autoBackupEnabled = localStorage.getItem(GITHUB_AUTO_BACKUP_ENABLED_KEY) === 'true';
        if (autoBackupEnabled) {
          statusElem.textContent = 'üü¢ Active';
          const interval = parseInt(localStorage.getItem(GITHUB_BACKUP_INTERVAL_KEY)) || 30;
          detailElem.textContent = `Auto-backup: ${interval} ph√∫t`;
        } else {
          statusElem.textContent = '‚ö™ Inactive';
          detailElem.textContent = 'Auto-backup t·∫Øt';
        }
      }
    }

    async function backupToGithub() {
      try {
        addBackupLog('üöÄ B·∫Øt ƒë·∫ßu backup...');
        showBackupStatus('‚è≥ ƒêang backup l√™n GitHub...', 'info');

        const repo = localStorage.getItem(GITHUB_REPO_KEY);
        const branch = localStorage.getItem(GITHUB_BRANCH_KEY) || 'main';

        if (!repo) {
          throw new Error('Ch∆∞a c√†i ƒë·∫∑t repository');
        }

        const [owner, repoName] = repo.split('/');
        if (!owner || !repoName) {
          throw new Error('Repository format kh√¥ng h·ª£p l·ªá');
        }

        const timestamp = new Date().toISOString();

        // Prepare combined backup data in a single file
        const backupData = {
          version: '1.0',
          timestamp,
          backupTime: Date.now(),
          data: {
            orderHistory: orderHistory,
            vipList: localStorage.getItem('vipList') || '',
            vipTransactions: vipTransactions
          },
          metadata: {
            itemCount: {
              orders: orderHistory.length,
              vipTransactions: vipTransactions.length
            }
          }
        };

        // Upload single combined file
        addBackupLog('üì§ ƒêang upload kitchen_backup.json...');
        const backupFile = await getGithubFile(owner, repoName, 'kitchen_backup.json', branch);
        const result = await createOrUpdateGithubFile(
          owner,
          repoName,
          'kitchen_backup.json',
          JSON.stringify(backupData, null, 2),
          `Backup data - ${timestamp}`,
          backupFile?.sha
        );

        // Save backup info
        localStorage.setItem(GITHUB_LAST_BACKUP_KEY, Date.now());
        if (result?.commit?.sha) {
          localStorage.setItem(GITHUB_LAST_COMMIT_SHA_KEY, result.commit.sha);
        }

        updateBackupStatusDisplay();
        addBackupLog(`‚úÖ Backup th√†nh c√¥ng! (${orderHistory.length} orders, ${vipTransactions.length} VIP transactions)`);
        showBackupStatus('‚úÖ Backup th√†nh c√¥ng!', 'success');

      } catch (err) {
        const errorMsg = `‚ùå L·ªói backup: ${err.message}`;
        addBackupLog(errorMsg);
        showBackupStatus(errorMsg, 'warning');
        alert(errorMsg);
        console.error('Backup error:', err);
      }
    }

    async function restoreFromGithub() {
      if (!confirm('‚ö†Ô∏è Restore s·∫Ω ghi ƒë√® d·ªØ li·ªáu hi·ªán t·∫°i. B·∫°n c√≥ ch·∫Øc ch·∫Øn?')) {
        return;
      }

      try {
        addBackupLog('üì• B·∫Øt ƒë·∫ßu restore...');
        showBackupStatus('‚è≥ ƒêang restore t·ª´ GitHub...', 'info');

        const repo = localStorage.getItem(GITHUB_REPO_KEY);
        const branch = localStorage.getItem(GITHUB_BRANCH_KEY) || 'main';

        if (!repo) {
          throw new Error('Ch∆∞a c√†i ƒë·∫∑t repository');
        }

        const [owner, repoName] = repo.split('/');

        // Fetch combined backup file
        addBackupLog('üì• ƒêang t·∫£i kitchen_backup.json...');
        const backupFile = await getGithubFile(owner, repoName, 'kitchen_backup.json', branch);

        if (!backupFile) {
          throw new Error('Kh√¥ng t√¨m th·∫•y backup file tr√™n GitHub');
        }

        const backupData = JSON.parse(backupFile.content);

        // Restore order history
        if (backupData.data?.orderHistory && Array.isArray(backupData.data.orderHistory)) {
          orderHistory = backupData.data.orderHistory;
          localStorage.setItem('orderHistory', JSON.stringify(orderHistory));
          addBackupLog(`‚úÖ ƒê√£ restore ${orderHistory.length} orders`);
        }

        // Restore VIP list
        if (backupData.data?.vipList) {
          localStorage.setItem('vipList', backupData.data.vipList);
          document.getElementById('vipArea').value = backupData.data.vipList;
          addBackupLog('‚úÖ ƒê√£ restore VIP list');
        }

        // Restore VIP transactions
        if (backupData.data?.vipTransactions && Array.isArray(backupData.data.vipTransactions)) {
          vipTransactions = backupData.data.vipTransactions;
          localStorage.setItem(VIP_TX_KEY, JSON.stringify(vipTransactions));
          addBackupLog(`‚úÖ ƒê√£ restore ${vipTransactions.length} VIP transactions`);
        }

        // Refresh UI
        renderHistory();
        renderVipHistory();
        refreshQuickOrderList();
        updateDishNameSuggestions();

        addBackupLog('‚úÖ Restore ho√†n t·∫•t!');
        showBackupStatus('‚úÖ Restore th√†nh c√¥ng!', 'success');
        alert('‚úÖ ƒê√£ restore d·ªØ li·ªáu t·ª´ GitHub th√†nh c√¥ng!');

      } catch (err) {
        const errorMsg = `‚ùå L·ªói restore: ${err.message}`;
        addBackupLog(errorMsg);
        showBackupStatus(errorMsg, 'warning');
        alert(errorMsg);
        console.error('Restore error:', err);
      }
    }

    function initGithubAutoBackup() {
      // Clear existing interval
      if (githubAutoBackupInterval) {
        clearInterval(githubAutoBackupInterval);
      }

      const interval = parseInt(localStorage.getItem(GITHUB_BACKUP_INTERVAL_KEY)) || 30;
      const enabled = localStorage.getItem(GITHUB_AUTO_BACKUP_ENABLED_KEY) === 'true';

      if (!enabled) return;

      // Set up new interval (convert minutes to milliseconds)
      githubAutoBackupInterval = setInterval(async () => {
        addBackupLog('üîÑ Auto-backup triggered');
        await backupToGithub();
      }, interval * 60 * 1000);

      addBackupLog(`üîÑ Auto-backup scheduled (every ${interval} minutes)`);
    }

    function refreshQuickOrderList() {
      const select = document.getElementById('quickOrderSelect');
      if (!select) return;

      const seen = new Set();
      const items = [];

      orderHistory.forEach(order => {
        const name = (order?.itemName || '').trim();
        if (!name || seen.has(name)) return;
        seen.add(name);
        const ts = new Date(order?.date || order?.id || 0).getTime() || 0;
        items.push({ name, ts });
      });

      if (items.length === 0) {
        select.innerHTML = '<option value="">Ch∆∞a c√≥ m√≥n n√†o</option>';
        return;
      }

      items.sort((a, b) => b.ts - a.ts);
      select.innerHTML = items.map(i => `<option value="${i.name}">${i.name}</option>`).join('');
    }

    // Draft autosave helpers
    function getDraftPayload(hasChanges = draftDirty) {
      const people = Array.from(document.querySelectorAll('#orderTable tbody tr')).map(tr => {
        const nameInput = tr.children[0]?.querySelector('input');
        const qtyInput = tr.children[1]?.querySelector('input');
        const shipPartsInput = tr.children[2]?.querySelector('input');
        const paidCheck = tr.children[3]?.querySelector('input[type="checkbox"]');
        return {
          name: (nameInput?.value || '').trim(),
          qty: Number(qtyInput?.value || 0),
          shipParts: Number(shipPartsInput?.value || 0),
          paid: !!paidCheck?.checked
        };
      }).filter(p => p.name);

      return {
        draftOrder: {
          itemName: document.getElementById('itemName')?.value || '',
          totalParts: Number(document.getElementById('n')?.value || 0),
          alvinFree: !!document.getElementById('alvinFree')?.checked,
          desiredPrice: Number(document.getElementById('desiredPrice')?.value || 0),
          people,
          lastModified: Date.now(),
          hasChanges: hasChanges === true
        }
      };
    }

    function applyPeopleToTable(people = []) {
      const tbody = document.querySelector('#orderTable tbody');
      if (!tbody) return;
      suppressDraftChange = true;
      tbody.innerHTML = '';

      if (!Array.isArray(people) || people.length === 0) {
        addRow();
        suppressDraftChange = false;
        return;
      }

      people.forEach(p => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
      <td><input class="name-input" value="${p.name || ''}" placeholder="Nh·∫≠p t√™n..."></td>
      <td><input type="number" min="1" step="1" value="${p.qty || 1}"></td>
      <td><input type="number" min="0" step="1" value="${p.shipParts || 0}" class="ship-count-input" placeholder="0"></td>
      <td style="text-align: center;"><input type="checkbox" class="payment-check" ${p.paid ? 'checked' : ''}></td>
      <td style="text-align: center;"><button class="btn btn-danger" onclick="delRow(this)">‚úï</button></td>
    `;
        tbody.appendChild(tr);
      });

      suppressDraftChange = false;
    }

    function updateDraftStatusUI(draftOrder = {}) {
      const dot = document.getElementById('draftStatusDot');
      const statusText = document.getElementById('draftStatusText');
      const metaText = document.getElementById('draftMetaText');
      const hasChanges = draftOrder.hasChanges || draftDirty;
      const lastModified = draftOrder.lastModified || draftOrder.draftModified || Date.now();

      if (dot) {
        dot.classList.toggle('saved', !hasChanges);
        dot.classList.toggle('unsaved', hasChanges);
      }
      if (statusText) {
        statusText.textContent = hasChanges ? 'Nh√°p c√≥ thay ƒë·ªïi (ch∆∞a backup iCloud)' : 'Nh√°p ƒë√£ l∆∞u';
      }
      if (metaText) {
        metaText.textContent = `T·ª± ƒë·ªông l∆∞u 30 ph√∫t/l·∫ßn | L∆∞u cu·ªëi: ${formatDraftTime(lastModified)}`;
      }
    }

    function setDraftBanner(message) {
      const banner = document.getElementById('draftBannerMessage');
      if (banner) banner.textContent = message || '';
    }

    function saveDraftToLocalStorage() {
      const draft = getDraftPayload(true);
      localStorage.setItem(DRAFT_STORAGE_KEY, JSON.stringify(draft));
      draftDirty = true;
      updateDraftStatusUI(draft.draftOrder);
      return draft;
    }

    function loadDraftFromLocalStorage() {
      try {
        const raw = localStorage.getItem(DRAFT_STORAGE_KEY);
        return raw ? JSON.parse(raw) : null;
      } catch (_err) {
        return null;
      }
    }

    function restoreDraftToUI(draftData) {
      if (!draftData || !draftData.draftOrder) return;

      const data = draftData.draftOrder;
      document.getElementById('itemName').value = data.itemName || '';
      document.getElementById('n').value = data.totalParts || 0;
      document.getElementById('alvinFree').checked = !!data.alvinFree;
      const desiredPriceInput = document.getElementById('desiredPrice');
      if (desiredPriceInput) desiredPriceInput.value = data.desiredPrice || '';
      selectedPrice = data.desiredPrice ? Number(data.desiredPrice) : null;
      applyPeopleToTable(data.people || []);

      draftDirty = !!data.hasChanges;
      updateDraftStatusUI(data);
      setDraftBanner('üìã ƒê√£ kh√¥i ph·ª•c ƒë∆°n nh√°p');
    }

    function markDraftChanged() {
      if (suppressDraftChange) return;
      lastComputedSignature = null;
      lastComputedOrder = null;
      draftDirty = true;
      updateDraftStatusUI({ hasChanges: true, lastModified: Date.now() });
      if (debouncedLocalDraftSave) {
        debouncedLocalDraftSave();
      } else {
        saveDraftToLocalStorage();
      }
    }

    function recordDraftMeta(path, savedAt) {
      const meta = JSON.parse(localStorage.getItem(DRAFT_META_KEY) || '[]').filter(Boolean);
      meta.unshift({ path, savedAt });

      // Deduplicate by path
      const unique = [];
      const seen = new Set();
      meta.forEach(entry => {
        if (!entry.path || seen.has(entry.path)) return;
        seen.add(entry.path);
        unique.push(entry);
      });

      localStorage.setItem(DRAFT_META_KEY, JSON.stringify(unique.slice(0, 10)));
    }

    async function deleteDraftFile(path) {
      try {
        if (window.orderHelperNative?.deleteFile) {
          await window.orderHelperNative.deleteFile(path);
          return true;
        }
        if (window.webkit?.messageHandlers?.orderHelperNative) {
          window.webkit.messageHandlers.orderHelperNative.postMessage({ action: 'deleteFile', path });
          return true;
        }
      } catch (err) {
        console.error('Delete draft failed', err);
      }
      return false;
    }

    async function cleanupOldDraftBackups() {
      const entries = JSON.parse(localStorage.getItem(DRAFT_META_KEY) || '[]').filter(Boolean);
      const now = Date.now();

      const toKeep = entries
        .filter(e => e.path)
        .sort((a, b) => (b.savedAt || 0) - (a.savedAt || 0));

      const fresh = toKeep.filter(e => now - (e.savedAt || 0) <= 7 * 24 * 60 * 60 * 1000);
      const survivors = fresh.slice(0, 5);
      const survivorPaths = new Set(survivors.map(s => s.path));
      const toDelete = toKeep.filter(e => !survivorPaths.has(e.path));

      for (const entry of toDelete) {
        await deleteDraftFile(entry.path);
      }

      localStorage.setItem(DRAFT_META_KEY, JSON.stringify(survivors));
    }

    async function writeFileToICloud(path, content, { allowDownloadFallback = false } = {}) {
      try {
        if (window.orderHelperNative?.writeFile) {
          await window.orderHelperNative.writeFile({ path, content });
          return { ok: true };
        }
        if (window.orderHelperNative?.writeTextFile) {
          await window.orderHelperNative.writeTextFile(path, content);
          return { ok: true };
        }
        if (window.webkit?.messageHandlers?.orderHelperNative) {
          window.webkit.messageHandlers.orderHelperNative.postMessage({ action: 'writeFile', path, content });
          return { ok: true };
        }
      } catch (err) {
        return { ok: false, error: err?.message || 'Unknown write error' };
      }

      if (allowDownloadFallback) {
        const a = document.createElement('a');
        const blob = new Blob([content], { type: 'application/json' });
        a.href = URL.createObjectURL(blob);
        a.download = path.split('/').pop();
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
        return { ok: true, fallback: true };
      }

      return { ok: false, error: 'Kh√¥ng c√≥ bridge ƒë·ªÉ ghi iCloud' };
    }

    function appendLog(message) {
      const line = `[${new Date().toISOString()}] ${message}`;
      console.error(line);
      try {
        if (window.orderHelperNative?.appendLog) {
          window.orderHelperNative.appendLog(line);
          return;
        }
        if (window.webkit?.messageHandlers?.orderHelperNative) {
          window.webkit.messageHandlers.orderHelperNative.postMessage({ action: 'appendLog', message: line });
        }
      } catch (_err) {
        // ignore
      }
    }

    function getDraftFilename(ts) {
      const d = new Date(ts);
      const pad = (n) => String(n).padStart(2, '0');
      const yyyy = d.getFullYear();
      const mm = pad(d.getMonth() + 1);
      const dd = pad(d.getDate());
      const hh = pad(d.getHours());
      const min = pad(d.getMinutes());
      return `draft_order_${yyyy}-${mm}-${dd}_${hh}${min}.json`;
    }

    async function saveDraftToICloud({ force = false, allowDownloadFallback = false, reason = 'auto' } = {}) {
      if (!force && !draftDirty) return false;

      if (draftBackupInFlight) return false;
      draftBackupInFlight = true;

      const draft = getDraftPayload(force || draftDirty);
      const now = Date.now();
      const filename = getDraftFilename(now);
      const path = `${DRAFT_DIR}/${filename}`;
      const content = JSON.stringify(draft, null, 2);

      try {
        if (window.orderHelperNative?.ensureDir) {
          try {
            await window.orderHelperNative.ensureDir(DRAFT_DIR);
          } catch (_err) {
            // ignore dir creation errors, writer may still handle it
          }
        }

        const res = await writeFileToICloud(path, content, { allowDownloadFallback });

        if (res.ok) {
          draft.draftOrder.hasChanges = false;
          draft.draftOrder.lastModified = now;
          localStorage.setItem(DRAFT_STORAGE_KEY, JSON.stringify(draft));
          draftDirty = false;
          lastDraftBackupPath = path;
          updateDraftStatusUI(draft.draftOrder);
          setDraftBanner(`‚úÖ ƒê√£ backup iCloud (${filename})`);
          recordDraftMeta(path, now);
          cleanupOldDraftBackups();
          if (draftBackupRetryTimeout) {
            clearTimeout(draftBackupRetryTimeout);
            draftBackupRetryTimeout = null;
          }
          return true;
        }

        setDraftBanner('‚ö†Ô∏è L∆∞u iCloud th·∫•t b·∫°i, s·∫Ω th·ª≠ l·∫°i sau');
        appendLog(`Draft backup failed (${reason}): ${res.error || 'unknown error'}`);

        if (!draftBackupRetryTimeout) {
          draftBackupRetryTimeout = setTimeout(() => {
            draftBackupRetryTimeout = null;
            saveDraftToICloud({ force: true, reason: 'retry' });
          }, DRAFT_RETRY_INTERVAL_MS);
        }

        return false;
      } finally {
        draftBackupInFlight = false;
      }
    }

    async function readFileFromICloud(path) {
      try {
        if (window.orderHelperNative?.readFile) {
          return await window.orderHelperNative.readFile(path);
        }
        if (window.orderHelperNative?.readTextFile) {
          return await window.orderHelperNative.readTextFile(path);
        }
      } catch (err) {
        appendLog(`Read draft failed: ${err?.message || err}`);
      }

      try {
        const res = await fetch(`file://${encodeURI(path)}`);
        if (res.ok) {
          return await res.text();
        }
      } catch (_err) {
        // ignore fetch errors
      }

      return null;
    }

    async function loadLatestDraftFromICloud() {
      let entries = JSON.parse(localStorage.getItem(DRAFT_META_KEY) || '[]').filter(e => e && e.path);

      if (entries.length === 0 && window.orderHelperNative?.listFiles) {
        try {
          const files = await window.orderHelperNative.listFiles(DRAFT_DIR);
          if (Array.isArray(files)) {
            entries = files
              .filter(f => typeof f === 'string' && f.startsWith('draft_order_') && f.endsWith('.json'))
              .map(name => ({ path: `${DRAFT_DIR}/${name}`, savedAt: Date.now() }));
            localStorage.setItem(DRAFT_META_KEY, JSON.stringify(entries));
          }
        } catch (_err) {
          // ignore listing failures
        }
      }

      if (entries.length === 0) {
        setDraftBanner('‚ÑπÔ∏è Kh√¥ng t√¨m th·∫•y nh√°p iCloud n√†o ƒë·ªÉ t·∫£i');
        return;
      }

      const latest = entries.sort((a, b) => (b.savedAt || 0) - (a.savedAt || 0))[0];
      const content = await readFileFromICloud(latest.path);

      if (!content) {
        setDraftBanner('‚ùå Kh√¥ng th·ªÉ ƒë·ªçc nh√°p t·ª´ iCloud');
        appendLog('Load draft from iCloud failed: missing content');
        return;
      }

      try {
        const data = JSON.parse(content);
        const payload = data && data.draftOrder ? data.draftOrder : data;
        restoreDraftToUI({ draftOrder: { ...payload, hasChanges: false } });
        draftDirty = false;
        updateDraftStatusUI({ ...payload, hasChanges: false });
        setDraftBanner('üìÇ ƒê√£ t·∫£i nh√°p t·ª´ iCloud');
      } catch (err) {
        appendLog(`Parse draft failed: ${err?.message || err}`);
        setDraftBanner('‚ùå File nh√°p kh√¥ng h·ª£p l·ªá');
      }
    }

    function clearDraft() {
      localStorage.removeItem(DRAFT_STORAGE_KEY);
      draftDirty = false;
      document.getElementById('itemName').value = '';
      document.getElementById('n').value = '';
      document.getElementById('alvinFree').checked = true;
      applyPeopleToTable([]);
      updateDraftStatusUI({ hasChanges: false, lastModified: Date.now() });
      setDraftBanner('üóëÔ∏è ƒê√£ xo√° nh√°p c·ª•c b·ªô');
    }

    function setupDraftListeners() {
      const watchedSelectors = ['#quickInput', '#itemName', '#n', '#alvinFree', '#totalCost', '#costPerUnit', '#shipFee', '#targetProfit', '#desiredPrice', '#itemDesc', '#deadline'];
      watchedSelectors.forEach(sel => {
        const el = document.querySelector(sel);
        if (el) {
          el.addEventListener('input', markDraftChanged);
          el.addEventListener('change', markDraftChanged);
        }
      });

      const table = document.getElementById('orderTable');
      if (table) {
        table.addEventListener('input', markDraftChanged);
        table.addEventListener('change', markDraftChanged);
      }
    }

    function startDraftBackupInterval() {
      if (draftBackupIntervalId) clearInterval(draftBackupIntervalId);
      draftBackupIntervalId = setInterval(() => {
        saveDraftToICloud({ reason: 'interval' });
      }, DRAFT_BACKUP_INTERVAL_MS);
    }

    function handleBeforeUnload() {
      if (draftDirty) {
        saveDraftToLocalStorage();
        saveDraftToICloud({ force: true, reason: 'beforeunload' });
      }
    }

    function initDraftAutosave() {
      debouncedLocalDraftSave = debounce(() => saveDraftToLocalStorage(), 1000);

      const storedDraft = loadDraftFromLocalStorage();
      if (storedDraft) {
        restoreDraftToUI(storedDraft);
      } else {
        loadLatestDraftFromICloud();
      }

      updateDraftStatusUI(storedDraft?.draftOrder || { hasChanges: false, lastModified: null });

      setupDraftListeners();
      startDraftBackupInterval();
      window.addEventListener('beforeunload', handleBeforeUnload);
    }

    function manualSaveDraft() {
      saveDraftToLocalStorage();
      saveDraftToICloud({ force: true, allowDownloadFallback: true, reason: 'manual' });
    }

    // Tab Management
    function switchTab(evt, tabName) {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));

      const target = evt?.currentTarget || evt?.target;
      if (target) target.classList.add('active');
      document.getElementById(tabName).classList.add('active');

      // Load data for specific tabs
      if (tabName === 'history') loadHistory();
      if (tabName === 'debt') loadDebtManagement();
      if (tabName === 'stats') loadStats();
    }
    window.switchTab = switchTab;

    // Quick Parse Input
    function parseQuickInput() {
      const input = document.getElementById('quickInput').value.trim();
      if (!input) {
        alert('Vui l√≤ng nh·∫≠p danh s√°ch order');
        return;
      }

      // Parse VIP for smart matching
      const vipMap = parseVip(document.getElementById('vipArea').value);
      const vipMatcher = vipMap._matcher || new SmartNameMatcher();

      // Clear existing table
      const tbody = document.querySelector('#orderTable tbody');
      tbody.innerHTML = '';

      // Parse format: lines or commas, with optional qty via space/colon
      const items = input
        .split(/[\n,]+/)
        .map(s => s.trim())
        .filter(s => s);
      let totalParts = 0;
      const suggestions = [];

      items.forEach(item => {
        // Extract name and quantity
        const match = item.match(/^(.+?)[\s:]+(\d+)$/);
        const inputName = match ? match[1].trim() : item.trim();
        const qty = match ? parseInt(match[2]) : 1;

        totalParts += qty;

        // Smart match against VIP
        const matchedVIP = vipMatcher.find(inputName);
        let finalName = inputName;

        if (matchedVIP && matchedVIP.original !== inputName) {
          finalName = matchedVIP.original;
          suggestions.push({
            input: inputName,
            suggested: matchedVIP.original
          });
        }

        // Add row to table
        const tr = document.createElement('tr');
        tr.innerHTML = `
      <td><input class="name-input" value="${finalName}"></td>
      <td><input type="number" min="1" step="1" value="${qty}"></td>
      <td><input type="number" min="0" step="1" value="0" class="ship-count-input" placeholder="0"></td>
      <td style="text-align: center;"><input type="checkbox" class="payment-check"></td>
      <td style="text-align: center;"><button class="btn btn-danger" onclick="delRow(this)">‚úï</button></td>
    `;
        tbody.appendChild(tr);
      });

      // Update total parts (add 1 for L√£o nh√¢n gia)
      document.getElementById('n').value = totalParts + 1;

      // Clear quick input
      document.getElementById('quickInput').value = '';

      // Show success message with suggestions
      let msg = `‚úÖ ƒê√£ parse ${items.length} ng∆∞·ªùi, t·ªïng ${totalParts + 1} ph·∫ßn (bao g·ªìm L√£o nh√¢n gia)`;

      if (suggestions.length > 0) {
        msg += '\n\nüîÑ Smart matching ƒë√£ t·ª± ƒë·ªông s·ª≠a t√™n:';
        suggestions.forEach(s => {
          msg += `\n‚Ä¢ "${s.input}" ‚Üí "${s.suggested}"`;
        });
      }

      markDraftChanged();
      alert(msg);
    }

    // Table Management
    function addRow() {
      const tbody = document.querySelector('#orderTable tbody');
      const tr = document.createElement('tr');
      tr.innerHTML = `
    <td><input class="name-input" value="" placeholder="Nh·∫≠p t√™n..."></td>
    <td><input type="number" min="1" step="1" value="1"></td>
    <td><input type="number" min="0" step="1" value="0" class="ship-count-input" placeholder="0"></td>
    <td style="text-align: center;"><input type="checkbox" class="payment-check"></td>
    <td style="text-align: center;"><button class="btn btn-danger" onclick="delRow(this)">‚úï</button></td>
  `;
      tbody.appendChild(tr);
      markDraftChanged();
    }

    function delRow(btn) {
      btn.closest('tr').remove();
      markDraftChanged();
    }

    // Price Suggestion
    function suggestPrices() {
      const n = Number(document.getElementById('n').value || 0);
      const alvinFree = document.getElementById('alvinFree').checked;
      const totalCost = Number(document.getElementById('totalCost').value || 0);
      const costPerUnit = Number(document.getElementById('costPerUnit').value || 0);
      const shipFee = Number(document.getElementById('shipFee').value || 0);
      const targetProfit = Number(document.getElementById('targetProfit').value || 6);

      // Validation: Check minimum parts
      const minParts = alvinFree ? 2 : 1;
      if (n < minParts) {
        alert(`‚ö†Ô∏è L·ªói: Khi b·∫≠t "L√£o nh√¢n gia free", t·ªïng ph·∫ßn ph·∫£i ‚â• 2.\n\nHi·ªán t·∫°i: ${n} ph·∫ßn\nY√™u c·∫ßu t·ªëi thi·ªÉu: ${minParts} ph·∫ßn\n\nüí° G·ª£i √Ω: TƒÉng s·ªë ph·∫ßn l√™n ho·∫∑c t·∫Øt "L√£o nh√¢n gia free".`);
        return;
      }

      const denom = alvinFree ? (n - 1) : n;

      // Double check denom (safety guard)
      if (denom <= 0) {
        alert('‚ö†Ô∏è L·ªói h·ªá th·ªëng: M·∫´u s·ªë kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i t·ªïng ph·∫ßn.');
        return;
      }

      let T = 0;
      if (costPerUnit > 0) {
        T = n * costPerUnit + shipFee;
      } else if (totalCost > 0) {
        T = totalCost + shipFee;
      } else {
        alert('Vui l√≤ng nh·∫≠p T·ªïng ti·ªÅn m√≥n (T) ho·∫∑c Chi ph√≠/ph·∫ßn (c)');
        return;
      }

      const priceBreakEven = ceilInt(T / denom);
      const priceProfit = ceilInt((T + targetProfit) / denom);

      const suggestionHTML = `
    <div class="price-suggestion">
      <div class="price-card" onclick="selectPrice(${priceBreakEven}, event)">
        <div class="price-card-label">Ho√† v·ªën</div>
        <div class="price-card-value">${priceBreakEven}ƒë</div>
        <div class="price-card-desc">Thu = Chi</div>
      </div>
      <div class="price-card active" onclick="selectPrice(${priceProfit}, event)">
        <div class="price-card-label">L·ªùi ${targetProfit}ƒë</div>
        <div class="price-card-value">${priceProfit}ƒë</div>
        <div class="price-card-desc">L·ªùi t·ªëi thi·ªÉu ${targetProfit}ƒë</div>
      </div>
    </div>
  `;

      document.getElementById('priceSuggestion').innerHTML = suggestionHTML;
      selectPrice(priceProfit);
    }

    function handleDesiredPriceInput() {
      const input = document.getElementById('desiredPrice');
      if (!input) return;

      const manualPrice = Number(input.value || 0);
      document.querySelectorAll('.price-card').forEach(card => card.classList.remove('active'));

      if (manualPrice > 0) {
        selectedPrice = manualPrice;
      } else {
        selectedPrice = null;
      }
    }

    function selectPrice(price, evt) {
      document.querySelectorAll('.price-card').forEach(card => {
        card.classList.remove('active');
      });

      if (evt && evt.target) {
        evt.target.closest('.price-card').classList.add('active');
      }

      selectedPrice = price;
      const desiredPriceInput = document.getElementById('desiredPrice');
      if (desiredPriceInput) desiredPriceInput.value = price;
    }

    // Main Compute Function
    function compute(options = {}) {
      const saveHistory = !!options.save;
      const silent = !!options.silent;
      const skipIfUnchanged = !!options.skipIfUnchanged;
      const itemName = document.getElementById('itemName').value.trim() || 'M√≥n ƒÉn';
      const n = Number(document.getElementById('n').value || 0);
      const alvinFree = document.getElementById('alvinFree').checked;
      const totalCost = Number(document.getElementById('totalCost').value || 0);
      const costPerUnit = Number(document.getElementById('costPerUnit').value || 0);
      const shipFee = Number(document.getElementById('shipFee').value || 0);
      const targetProfitInput = Number(document.getElementById('targetProfit')?.value || 0);
      const desiredPriceInput = Number(document.getElementById('desiredPrice')?.value || 0);
      const itemDesc = document.getElementById('itemDesc')?.value || '';
      const deadline = document.getElementById('deadline')?.value || '';
      const isEditingExisting = !!editingOrderId;

      // Validation: Check minimum parts
      const minParts = alvinFree ? 2 : 1;
      if (n < minParts) {
        alert(`‚ö†Ô∏è L·ªói: Khi b·∫≠t "L√£o nh√¢n gia free", t·ªïng ph·∫ßn ph·∫£i ‚â• 2.\n\nHi·ªán t·∫°i: ${n} ph·∫ßn\nY√™u c·∫ßu t·ªëi thi·ªÉu: ${minParts} ph·∫ßn\n\nüí° G·ª£i √Ω: TƒÉng s·ªë ph·∫ßn l√™n ho·∫∑c t·∫Øt "L√£o nh√¢n gia free".`);
        return null;
      }

      const denom = alvinFree ? (n - 1) : n;
      if (denom <= 0) {
        alert('‚ö†Ô∏è L·ªói h·ªá th·ªëng: M·∫´u s·ªë kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i t·ªïng ph·∫ßn.');
        return null;
      }

      let T = 0;
      if (costPerUnit > 0) {
        T = n * costPerUnit + shipFee;
      } else if (totalCost > 0) {
        T = totalCost + shipFee;
      }

      // Parse Order Table
      const rows = Array.from(document.querySelectorAll('#orderTable tbody tr')).map(tr => {
        const nameInput = tr.children[0].querySelector('input');
        const qtyInput = tr.children[1].querySelector('input');
        const shipPartsInput = tr.children[2].querySelector('input');
        const paidCheck = tr.children[3].querySelector('input[type="checkbox"]');
        const name = (nameInput.value || '').trim();
        const qty = Number(qtyInput.value || 0);
        let shipParts = Number(shipPartsInput.value || 0);
        shipParts = Math.max(0, Math.min(shipParts, qty)); // clamp 0..qty
        const paid = paidCheck.checked;
        return { name, qty, paid, shipParts };
      }).filter(r => r.name && r.qty > 0);

      const shipCount = rows.reduce((sum, r) => sum + r.shipParts, 0);
      const nonShipCount = rows.reduce((sum, r) => sum + (r.qty - r.shipParts), 0);

      // Decide pricing mode
      let sellingPrice = selectedPrice;
      let priceNonShip = null;
      let priceShip = null;
      let revenue = 0;
      let profit = 0;
      const foodCostOnly = T - shipFee;

      const canSplitShip = shipFee > 0 && shipCount > 0;

      if (canSplitShip) {
        // Base gi√°: chia ƒë·ªÅu ti·ªÅn m√≥n; ship chia ri√™ng cho ph·∫ßn c√≥ ship
        const basePrice = foodCostOnly / denom;
        priceNonShip = ceilInt(basePrice);
        const surchargePerShip = shipFee / shipCount;
        priceShip = ceilInt(basePrice + surchargePerShip);
        sellingPrice = priceNonShip; // keep for backward compatibility fields

        const revenueNonShip = priceNonShip * nonShipCount;
        const revenueShip = priceShip * shipCount;
        revenue = revenueNonShip + revenueShip;
        profit = revenue - (foodCostOnly + shipFee);
      } else {
        if (!selectedPrice) {
          alert('Vui l√≤ng b·∫•m "ƒê·ªÅ xu·∫•t 2 m·ª©c gi√°" v√† ch·ªçn gi√° b√°n tr∆∞·ªõc.');
          return null;
        }
        sellingPrice = selectedPrice;
        priceNonShip = sellingPrice;
        priceShip = sellingPrice;
        revenue = denom * sellingPrice;
        profit = revenue - T;
      }

      // Parse VIP with smart matching
      const vipFromArea = parseVip(document.getElementById('vipArea').value);
      const vipPersisted = parseVip(localStorage.getItem('vipList') || '');
      let vipMap = new Map([...vipPersisted, ...vipFromArea]);

      // Get matcher from vipMap
      const vipMatcher = vipFromArea._matcher || new SmartNameMatcher();

      // Re-populate matcher with all VIP data
      vipMap.forEach((balance, name) => {
        vipMatcher.add(name, balance);
      });

      // Process payments with smart name matching
      const members = [];
      const vipChanged = new Set();
      const orderDetails = [];
      const nameCorrections = []; // Track name corrections

      rows.forEach(r => {
        const shipQty = r.shipParts;
        const nonShipQty = r.qty - shipQty;
        const due = shipQty * priceShip + nonShipQty * priceNonShip;

        // Smart match: check if this name matches any VIP
        const matchedVIP = vipMatcher.find(r.name);

        if (matchedVIP) {
          // Found VIP match!
          const originalName = matchedVIP.original;
          const currentBalance = matchedVIP.data;
          const newBalance = currentBalance - due;

          // Update VIP balance
          vipMap.set(originalName, newBalance);
          vipMatcher.add(originalName, newBalance);
          vipChanged.add(originalName);

          // Track if name was corrected
          if (r.name !== originalName) {
            nameCorrections.push({
              input: r.name,
              corrected: originalName
            });
          }

          orderDetails.push({
            name: originalName, // Use original VIP name
            qty: r.qty,
            shipQty,
            nonShipQty,
            due: due,
            paid: true, // VIP auto-paid
            unitPrice: shipQty > 0 && nonShipQty > 0 ? `${formatMoney(priceNonShip)} / ${formatMoney(priceShip)}` : (shipQty > 0 ? priceShip : priceNonShip)
          });
        } else {
          // Not VIP, add to members
          orderDetails.push({
            name: r.name,
            qty: r.qty,
            shipQty,
            nonShipQty,
            due: due,
            paid: r.paid,
            unitPrice: shipQty > 0 && nonShipQty > 0 ? `${formatMoney(priceNonShip)} / ${formatMoney(priceShip)}` : (shipQty > 0 ? priceShip : priceNonShip)
          });

          if (!r.paid) {
            members.push({ name: r.name, due: due, qty: r.qty });
          }
        }
      });

      // Save to history
      const order = {
        id: editingOrderId || Date.now(),
        date: editingOrderDate || new Date().toISOString(),
        itemName: itemName,
        totalParts: n,
        alvinFree,
        sellingPrice: sellingPrice,
        sellingPriceShip: priceShip,
        sellingPriceNonShip: priceNonShip,
        splitShipMode: canSplitShip,
        shipCount,
        nonShipCount,
        shipFee,
        totalCost: T,
        totalCostInput: totalCost,
        costPerUnitInput: costPerUnit,
        targetProfit: targetProfitInput,
        desiredPriceInput,
        itemDesc,
        deadline,
        revenue: revenue,
        profit: profit,
        details: orderDetails,
        vipSnapshot: Array.from(vipMap.entries())
      };

      const orderSignature = buildOrderSignature({
        itemName,
        totalParts: n,
        alvinFree,
        totalCostInput: totalCost,
        costPerUnitInput: costPerUnit,
        shipFee,
        targetProfit: targetProfitInput,
        priceNonShip,
        priceShip,
        splitShipMode: canSplitShip,
        details: orderDetails
      });
      order.signature = orderSignature;
      lastComputedSignature = orderSignature;
      lastComputedOrder = order;

      let savedToHistory = false;
      const skipSave = saveHistory && skipIfUnchanged && lastSavedSignature === orderSignature;

      if (saveHistory && !skipSave) {
        if (isEditingExisting) {
          const idx = orderHistory.findIndex(o => o.id === editingOrderId);
          if (idx >= 0) {
            orderHistory[idx] = order;
          } else {
            orderHistory.unshift(order);
          }
        } else {
          orderHistory.unshift(order);
        }
        localStorage.setItem('orderHistory', JSON.stringify(orderHistory));
        lastSavedSignature = orderSignature;
        savedToHistory = true;
      } else if (saveHistory && skipSave) {
        lastSavedSignature = orderSignature;
      }
      if (saveHistory && (savedToHistory || skipSave)) {
        refreshQuickOrderList();
        updateDishNameSuggestions();
      }
      if (saveHistory && (savedToHistory || skipSave)) {
        editingOrderId = null;
        editingOrderDate = null;
      }

      // Generate Summary HTML
      const priceDetailText = canSplitShip
        ? `Ko ship: ${formatMoney(priceNonShip)} | C√≥ ship: ${formatMoney(priceShip)}`
        : `${formatMoney(sellingPrice)}/ph·∫ßn`;

      const revenueDetail = canSplitShip
        ? `${nonShipCount} √ó ${formatMoney(priceNonShip)} + ${shipCount} √ó ${formatMoney(priceShip)}`
        : `${denom} √ó ${formatMoney(sellingPrice)}`;

      const summaryHTML = `
    <div class="summary-grid">
      <div class="summary-item">
        <h3>T·ªïng ph·∫ßn (n)</h3>
        <div class="summary-value">${n} ph·∫ßn</div>
        <div class="summary-detail">${alvinFree ? `Thu ${denom} ph·∫ßn (L√£o nh√¢n gia free)` : `Thu ${n} ph·∫ßn`}</div>
      </div>
      <div class="summary-item">
        <h3>T·ªïng chi (T)</h3>
        <div class="summary-value">${formatMoney(T)}</div>
        <div class="summary-detail">${costPerUnit > 0 ? `${n} √ó ${formatMoney(costPerUnit)}` : formatMoney(totalCost)} + ship ${formatMoney(shipFee)}</div>
      </div>
      <div class="summary-item">
        <h3>Thu</h3>
        <div class="summary-value">${formatMoney(revenue)}</div>
        <div class="summary-detail">${revenueDetail}</div>
      </div>
      <div class="summary-item">
        <h3>K·∫øt qu·∫£</h3>
        <div class="summary-value ${profit >= 0 ? 'profit-positive' : 'profit-negative'}">
          ${profit >= 0 ? 'L·ªùi' : 'L·ªó'} ${formatMoney(Math.abs(profit))}
        </div>
        <div class="summary-detail">Ho√† v·ªën: ${ceilInt(T / denom)}ƒë/ph·∫ßn</div>
      </div>
    </div>

    <div class="summary-grid" style="margin-top: 12px;">
      <div class="summary-item">
        <h3>ƒê∆°n gi√°</h3>
        <div class="summary-value">${priceDetailText}</div>
        <div class="summary-detail">${canSplitShip ? `Ship ${shipCount} ph·∫ßn | Kh√¥ng ship ${nonShipCount} ph·∫ßn` : '√Åp d·ª•ng chung cho t·∫•t c·∫£'}</div>
      </div>
      ${canSplitShip ? `
      <div class="summary-item">
        <h3>Chi ti·∫øt ship</h3>
        <div class="summary-value">${formatMoney(shipFee)}</div>
        <div class="summary-detail">${formatMoney(shipFee / shipCount)} m·ªói ph·∫ßn ship (l√†m tr√≤n khi t√≠nh ti·ªÅn)</div>
      </div>` : ''}
    </div>

    <div class="grid" style="margin-top: 20px;">
      <div class="glass-card" style="padding: 20px;">
        <h3 style="font-size: 16px; margin-bottom: 12px; color: var(--text-secondary);">üëë VIP (s·ªë d∆∞ sau khi tr·ª´)</h3>
        ${vipMap.size > 0 ? `
          <ul class="info-list">
            ${Array.from(vipMap.entries()).map(([name, bal]) => {
        const charged = vipChanged.has(name);
        const chargeAmount = charged
          ? orderDetails.filter(d => d.name === name).reduce((sum, d) => sum + d.due, 0)
          : 0;
        return `
              <li>
                <span class="name">${name}${charged ? ` (ƒë√£ tr·ª´ ${formatMoney(chargeAmount)})` : ''}</span>
                <span>
                  <span class="value">${formatMoney(bal)}</span>
                </span>
              </li>
            `;
      }).join('')}
          </ul>
        ` : '<div class="empty-state"><div class="empty-state-icon">ü´ô</div>Ch∆∞a c√≥ VIP</div>'}
      </div>

      <div class="glass-card" style="padding: 20px;">
        <h3 style="font-size: 16px; margin-bottom: 12px; color: var(--text-secondary);">üë• Member (ch∆∞a tr·∫£)</h3>
        ${members.length > 0 ? `
          <ul class="info-list">
            ${members.map(m => `
              <li>
                <span class="name">${m.name}${m.qty > 1 ? ` (${m.qty} ph·∫ßn)` : ''}</span>
                <span class="value" style="color: var(--accent-red);">-${formatMoney(m.due)}</span>
              </li>
            `).join('')}
          </ul>
        ` : '<div class="empty-state"><div class="empty-state-icon">‚úÖ</div>T·∫•t c·∫£ ƒë√£ thanh to√°n</div>'}
      </div>
    </div>
  `;

      document.getElementById('summarySection').innerHTML = summaryHTML;

      // Generate Final Message - Show VIP balance AFTER deduction
      const vipLine = vipMap.size > 0
        ? Array.from(vipMap.entries()).map(([name, bal]) => {
          // Check if this VIP was in the order
          const wasCharged = vipChanged.has(name);
          return `${name} (${formatMoney(bal)})`;
        }).join(', ')
        : '‚Äî';

      const memLine = members.length > 0
        ? members.map(m => `${m.name}${m.qty > 1 ? ` (${m.qty} ph·∫ßn)` : ''} (-${formatMoney(m.due)})`).join(', ')
        : '‚Äî';

      const priceLine = canSplitShip
        ? `${formatMoney(priceNonShip)} ko ship | ${formatMoney(priceShip)} c√≥ ship (ship ${shipCount} ph·∫ßn, ph√≠ ${formatMoney(shipFee)})`
        : `${formatMoney(sellingPrice)}/ph·∫ßn`;

      const finalMsg = `üçΩ ${itemName}: ${priceLine}\nüëë VIP: ${vipLine}\nüë• Member (ch∆∞a tr·∫£): ${memLine}`;

      document.getElementById('finalMsg').value = finalMsg;

      if (saveHistory) {
        // Update VIP storage
        const vipText = vipToText(vipMap);
        document.getElementById('vipArea').value = vipText;
        persistVipList(vipText);

        if (skipSave) {
          if (!silent) {
            alert('‚ÑπÔ∏è ƒê∆°n n√†y ƒë√£ ƒë∆∞·ª£c l∆∞u tr∆∞·ªõc ƒë√≥, kh√¥ng l∆∞u tr√πng.');
          } else {
            setDraftBanner('‚ÑπÔ∏è ƒê∆°n n√†y ƒë√£ ƒë∆∞·ª£c l∆∞u tr∆∞·ªõc ƒë√≥');
          }
        } else if (nameCorrections.length > 0) {
          const correctionMsg = nameCorrections
            .map(c => `‚Ä¢ "${c.input}" ‚Üí "${c.corrected}"`)
            .join('\n');
          if (!silent) {
            alert(`‚úÖ ƒê√£ l∆∞u ƒë∆°n!\n\nüîÑ Smart matching ƒë√£ t·ª± ƒë·ªông s·ª≠a t√™n:\n${correctionMsg}`);
          } else {
            setDraftBanner('‚úÖ ƒê√£ l∆∞u ƒë∆°n (ƒë√£ s·ª≠a t√™n smart matching)');
          }
        } else if (!silent) {
          alert('‚úÖ ƒê√£ l∆∞u ƒë∆°n v√†o l·ªãch s·ª≠!');
        } else {
          setDraftBanner('‚úÖ ƒê√£ l∆∞u ƒë∆°n v√†o l·ªãch s·ª≠');
        }
      } else {
        setDraftBanner('‚ÑπÔ∏è ƒê√£ t√≠nh t·∫°m, b·∫•m "L∆∞u ƒë∆°n" ƒë·ªÉ ghi v√†o l·ªãch s·ª≠');
      }

      return { order, saved: savedToHistory || skipSave, signature: orderSignature };
    }

    // Generate Open Order Message
    function generateOpenMsg() {
      const select = document.getElementById('quickOrderSelect');
      const qtyInput = document.getElementById('quickOrderQty');
      const fallbackName = document.getElementById('itemName')?.value.trim() || 'M√≥n ƒÉn';
      const itemName = select && select.value ? select.value : fallbackName;
      const qty = Math.max(1, Number(qtyInput?.value || 1));

      document.getElementById('openMsg').value = `${itemName} +${qty} order`;
    }

    // Reset Output
    function resetOutput() {
      document.getElementById('summarySection').innerHTML = '';
      document.getElementById('finalMsg').value = '';
      document.getElementById('openMsg').value = '';
      document.getElementById('priceSuggestion').innerHTML = '';
      const desiredPriceInput = document.getElementById('desiredPrice');
      if (desiredPriceInput) desiredPriceInput.value = '';
      selectedPrice = null;
    }

    // Copy Message
    function copyMsg(id, event) {
      const ta = document.getElementById(id);
      ta.select();
      ta.setSelectionRange(0, 99999);

      try {
        document.execCommand('copy');

        if (event && event.target) {
          const btn = event.target;
          const originalText = btn.textContent;
          btn.textContent = '‚úì ƒê√£ copy!';
          setTimeout(() => {
            btn.textContent = originalText;
          }, 2000);
        } else {
          alert('‚úÖ ƒê√£ copy!');
        }
      } catch (err) {
        alert('Vui l√≤ng copy th·ªß c√¥ng b·∫±ng Ctrl+C');
      }
    }

    function copyAndSaveFinalMsg(event) {
      const finalMsgArea = document.getElementById('finalMsg');
      const hasMessage = finalMsgArea.value.trim().length > 0;
      const isUnsaved = lastComputedSignature !== lastSavedSignature;

      if (!hasMessage || isUnsaved) {
        const res = compute({ save: true, silent: true, skipIfUnchanged: true });
        if (!res) return;
      }

      copyMsg('finalMsg', event);
      updateData('orderValue', formatMoney(totalPayable));
    }

    // ========== Order History Filters ==========

    let historyFilters = {
      fromDate: null,
      toDate: null,
      vip: '',
      itemName: ''
    };

    function populateVIPFilterDropdown() {
      const select = document.getElementById('filterVIP');
      if (!select) return;

      // Get unique VIP names from orders
      const vipNames = new Set();
      orderHistory.forEach(order => {
        if (order.details && Array.isArray(order.details)) {
          order.details.forEach(detail => {
            if (detail.name) vipNames.add(detail.name);
          });
        }
      });

      // Also add from VIP list
      const vipArea = document.getElementById('vipArea');
      if (vipArea) {
        const vipMap = parseVip(vipArea.value);
        vipMap.forEach((_, name) => vipNames.add(name));
      }

      // Populate dropdown
      const options = '<option value="">T·∫•t c·∫£</option>' +
        Array.from(vipNames).sort().map(name =>
          `<option value="${name}">${name}</option>`
        ).join('');
      select.innerHTML = options;
    }

    function applyHistoryFilters() {
      // Get filter values
      historyFilters.fromDate = document.getElementById('filterFromDate').value;
      historyFilters.toDate = document.getElementById('filterToDate').value;
      historyFilters.vip = document.getElementById('filterVIP').value;
      historyFilters.itemName = document.getElementById('filterItem').value.toLowerCase();

      // Re-render with filters
      renderHistory();

      // Update summary
      updateFilterSummary();
    }

    function clearHistoryFilters() {
      document.getElementById('filterFromDate').value = '';
      document.getElementById('filterToDate').value = '';
      document.getElementById('filterVIP').value = '';
      document.getElementById('filterItem').value = '';

      historyFilters = {
        fromDate: null,
        toDate: null,
        vip: '',
        itemName: ''
      };

      renderHistory();
      updateFilterSummary();
    }

    function updateFilterSummary() {
      const summary = document.getElementById('filterSummary');
      if (!summary) return;

      const activeFilters = [];
      if (historyFilters.fromDate) activeFilters.push(`T·ª´ ${historyFilters.fromDate}`);
      if (historyFilters.toDate) activeFilters.push(`ƒë·∫øn ${historyFilters.toDate}`);
      if (historyFilters.vip) activeFilters.push(`VIP: ${historyFilters.vip}`);
      if (historyFilters.itemName) activeFilters.push(`M√≥n: ${historyFilters.itemName}`);

      if (activeFilters.length > 0) {
        summary.textContent = 'üîç ' + activeFilters.join(' ‚Ä¢ ');
      } else {
        summary.textContent = '';
      }
    }

    function filterOrderHistory(orders) {
      return orders.filter(order => {
        // Date filter
        if (historyFilters.fromDate || historyFilters.toDate) {
          const orderDate = new Date(order.date || order.id);
          const orderDateStr = orderDate.toISOString().split('T')[0];

          if (historyFilters.fromDate && orderDateStr < historyFilters.fromDate) {
            return false;
          }
          if (historyFilters.toDate && orderDateStr > historyFilters.toDate) {
            return false;
          }
        }

        // VIP filter
        if (historyFilters.vip) {
          const hasVIP = order.details && order.details.some(d => d.name === historyFilters.vip);
          if (!hasVIP) return false;
        }

        // Item name filter
        if (historyFilters.itemName) {
          const itemMatch = order.itemName && order.itemName.toLowerCase().includes(historyFilters.itemName);
          if (!itemMatch) return false;
        }

        return true;
      });
    }

    // Render History
    function renderHistory() {
      const historyList = document.getElementById('historyList');

      if (orderHistory.length === 0) {
        historyList.innerHTML = '<div class="empty-state"><div class="empty-state-icon">üì≠</div>Ch∆∞a c√≥ ƒë∆°n h√†ng n√†o</div>';
        refreshQuickOrderList();
        return;
      }

      // Apply filters
      const filteredOrders = filterOrderHistory(orderHistory);

      if (filteredOrders.length === 0) {
        historyList.innerHTML = '<div class="empty-state">‚ùå Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng n√†o ph√π h·ª£p v·ªõi b·ªô l·ªçc</div>';
        refreshQuickOrderList();
        return;
      }

      historyList.innerHTML = filteredOrders.map(order => {
        const paidCount = order.details.filter(d => d.paid).length;
        const totalCount = order.details.length;
        const statusClass = paidCount === totalCount ? 'status-paid' : (paidCount > 0 ? 'status-partial' : 'status-unpaid');
        const statusText = paidCount === totalCount ? 'ƒê√£ thanh to√°n' : `${paidCount}/${totalCount} ƒë√£ tr·∫£`;
        const historyPriceLine = order.splitShipMode
          ? `${order.nonShipCount || 0}√ó${formatMoney(order.sellingPriceNonShip || order.sellingPrice)} + ${order.shipCount || 0}√ó${formatMoney(order.sellingPriceShip || order.sellingPrice)}`
          : `${order.totalParts} ph·∫ßn √ó ${formatMoney(order.sellingPrice)}`;

        return `
      <div class="history-item" onclick="showOrderDetail(${order.id})">
        <div class="history-header">
          <div class="history-title">${order.itemName}</div>
          <div class="history-date">${formatDate(order.date)}</div>
        </div>
        <div class="history-details">
          ${historyPriceLine} = ${formatMoney(order.revenue)} 
          <span class="${order.profit >= 0 ? 'profit-positive' : 'profit-negative'}">
            (${order.profit >= 0 ? 'L·ªùi' : 'L·ªó'} ${formatMoney(Math.abs(order.profit))})
          </span>
          <span class="status-badge ${statusClass}">${statusText}</span>
        </div>
      </div>
    `;
      }).join('');
      refreshQuickOrderList();
    }

    function showOrderDetail(orderId) {
      const order = orderHistory.find(o => o.id === orderId);
      if (!order) return;

      const modalBody = document.getElementById('modalBody');
      const modalPriceLabel = order.splitShipMode
        ? `Ko ship ${formatMoney(order.sellingPriceNonShip || order.sellingPrice)} | Ship ${formatMoney(order.sellingPriceShip || order.sellingPrice)}`
        : `${formatMoney(order.sellingPrice)}/ph·∫ßn`;

      modalBody.innerHTML = `
    <div class="form-group">
      <label class="form-label">T√™n m√≥n</label>
      <div style="font-size: 18px; font-weight: 600; color: var(--text-primary);">${order.itemName}</div>
    </div>

    <div class="form-row">
      <div class="form-group">
        <label class="form-label">Ng√†y gi·ªù</label>
        <div style="color: var(--text-primary);">${formatDate(order.date)}</div>
      </div>
      <div class="form-group">
        <label class="form-label">Gi√° b√°n</label>
        <div style="color: var(--text-primary);">${modalPriceLabel}</div>
      </div>
    </div>

    <div class="summary-grid" style="margin: 20px 0;">
      <div class="summary-item">
        <h3>T·ªïng chi</h3>
        <div class="summary-value">${formatMoney(order.totalCost)}</div>
      </div>
      <div class="summary-item">
        <h3>Thu v·ªÅ</h3>
        <div class="summary-value">${formatMoney(order.revenue)}</div>
      </div>
      <div class="summary-item">
        <h3>K·∫øt qu·∫£</h3>
        <div class="summary-value ${order.profit >= 0 ? 'profit-positive' : 'profit-negative'}">
          ${order.profit >= 0 ? 'L·ªùi' : 'L·ªó'} ${formatMoney(Math.abs(order.profit))}
        </div>
      </div>
    </div>

    <div class="form-group">
      <label class="form-label">Danh s√°ch order</label>
      <div class="table-wrapper">
        <table class="table">
          <thead>
              <tr>
                <th>T√™n</th>
                <th style="text-align: right;">S·ªë ph·∫ßn</th>
                <th style="text-align: right;">ƒê∆°n gi√°</th>
                <th style="text-align: right;">Ship</th>
                <th style="text-align: right;">Th√†nh ti·ªÅn</th>
                <th style="text-align: center;">Tr·∫°ng th√°i</th>
              </tr>
            </thead>
            <tbody>
              ${order.details.map(d => `
              <tr>
                <td>${d.name}</td>
                <td style="text-align: right;">${d.qty}</td>
                <td style="text-align: right;">${typeof d.unitPrice === 'string' ? d.unitPrice : formatMoney(d.unitPrice || order.sellingPrice)}</td>
                <td style="text-align: right;">${d.shipQty ? `${d.shipQty} üöö` : '0'}</td>
                <td style="text-align: right;">${formatMoney(d.due)}</td>
                <td style="text-align: center;">
                  <span class="status-badge ${d.paid ? 'status-paid' : 'status-unpaid'}">
                    ${d.paid ? 'ƒê√£ tr·∫£' : 'Ch∆∞a tr·∫£'}
                  </span>
                </td>
              </tr>
            `).join('')}
          </tbody>
        </table>
      </div>
    </div>

    <div class="btn-group" style="margin-top: 20px;">
      <button class="btn btn-secondary" onclick="editOrder(${order.id})">‚úèÔ∏è Ch·ªânh s·ª≠a ƒë∆°n</button>
      <button class="btn btn-info" onclick="markAllPaid(${order.id})">‚úì ƒê√°nh d·∫•u t·∫•t c·∫£ ƒë√£ tr·∫£</button>
      <button class="btn btn-danger" onclick="deleteOrder(${order.id})">üóëÔ∏è Xo√° ƒë∆°n n√†y</button>
    </div>
  `;

      document.getElementById('orderModal').classList.add('active');
    }

    function editOrder(orderId) {
      const order = orderHistory.find(o => o.id === orderId);
      if (!order) return;

      editingOrderId = orderId;
      editingOrderDate = order.date;
      closeModal();

      const newOrderTab = document.querySelector('.tab[onclick*="newOrder"]');
      switchTab({ currentTarget: newOrderTab }, 'newOrder');

      document.getElementById('itemName').value = order.itemName || '';
      const totalPartsValue = order.totalParts || order.nonShipCount + order.shipCount || '';
      document.getElementById('n').value = totalPartsValue;
      document.getElementById('alvinFree').checked = !!order.alvinFree;
      document.getElementById('shipFee').value = order.shipFee || 0;

      const totalCostInputValue = order.totalCostInput !== undefined
        ? order.totalCostInput
        : Math.max((order.totalCost || 0) - (order.shipFee || 0), 0);
      document.getElementById('totalCost').value = totalCostInputValue ?? 0;
      document.getElementById('costPerUnit').value = order.costPerUnitInput ?? 0;

      const targetProfitInputEl = document.getElementById('targetProfit');
      if (targetProfitInputEl) {
        targetProfitInputEl.value = order.targetProfit !== undefined ? order.targetProfit : (targetProfitInputEl.value || 0);
      }

      const desiredPriceInput = document.getElementById('desiredPrice');
      const desiredPriceValue = order.desiredPriceInput ?? order.sellingPriceNonShip ?? order.sellingPrice ?? '';
      if (desiredPriceInput) desiredPriceInput.value = desiredPriceValue;
      selectedPrice = desiredPriceValue ? Number(desiredPriceValue) : null;

      const itemDescInput = document.getElementById('itemDesc');
      if (itemDescInput) itemDescInput.value = order.itemDesc || '';
      const deadlineInput = document.getElementById('deadline');
      if (deadlineInput) deadlineInput.value = order.deadline || '';

      const people = (order.details || []).map(d => ({
        name: d.name,
        qty: d.qty,
        shipParts: d.shipQty || d.shipParts || 0,
        paid: d.paid
      }));
      applyPeopleToTable(people);

      markDraftChanged();
      setDraftBanner('‚úèÔ∏è ƒêang ch·ªânh s·ª≠a ƒë∆°n t·ª´ l·ªãch s·ª≠. B·∫•m "L∆∞u ƒë∆°n" ƒë·ªÉ c·∫≠p nh·∫≠t.');
    }

    function closeModal() {
      document.getElementById('orderModal').classList.remove('active');
    }

    function deleteOrder(orderId) {
      if (!confirm('X√°c nh·∫≠n xo√° ƒë∆°n h√†ng n√†y?')) return;

      orderHistory = orderHistory.filter(o => o.id !== orderId);
      localStorage.setItem('orderHistory', JSON.stringify(orderHistory));

      closeModal();
      loadHistory();
      alert('‚úÖ ƒê√£ xo√° ƒë∆°n h√†ng');
    }

    function markAllPaid(orderId) {
      const order = orderHistory.find(o => o.id === orderId);
      if (!order) return;

      order.details.forEach(d => d.paid = true);
      localStorage.setItem('orderHistory', JSON.stringify(orderHistory));

      showOrderDetail(orderId);
      alert('‚úÖ ƒê√£ ƒë√°nh d·∫•u t·∫•t c·∫£ ƒë√£ thanh to√°n');
    }

    function markDebtorPaid(name) {
      if (!name) return;
      const target = name.trim();
      const changes = [];
      let totalCleared = 0;

      orderHistory.forEach(order => {
        order.details.forEach((d, idx) => {
          if (!d.paid && d.name === target) {
            changes.push({ orderId: order.id, detailIndex: idx, due: d.due });
            totalCleared += d.due;
          }
        });
      });

      if (changes.length === 0) {
        alert('‚ÑπÔ∏è Kh√¥ng th·∫•y c√¥ng n·ª£ c·∫ßn c·∫≠p nh·∫≠t cho ng∆∞·ªùi n√†y');
        return;
      }

      const confirmMsg = `ƒê√°nh d·∫•u ƒë√£ tr·∫£ cho ${target}?\n${changes.length} m·ª•c, t·ªïng ${formatMoney(totalCleared)}`;
      if (!confirm(confirmMsg)) return;

      changes.forEach(change => {
        const order = orderHistory.find(o => o.id === change.orderId);
        if (order && order.details[change.detailIndex]) {
          order.details[change.detailIndex].paid = true;
        }
      });

      lastDebtorPaidSnapshot = { name: target, changes };
      localStorage.setItem('orderHistory', JSON.stringify(orderHistory));
      loadDebtManagement();
      loadHistory();
      alert(`‚úÖ ƒê√£ ƒë√°nh d·∫•u ${target} ƒë√£ tr·∫£ h·∫øt n·ª£`);
    }

    function markSingleDebtPaid(orderId, detailIndex, name) {
      const order = orderHistory.find(o => o.id === orderId);
      if (!order || !order.details?.[detailIndex]) return;

      const detail = order.details[detailIndex];
      if (detail.paid) {
        alert('‚ÑπÔ∏è M·ª•c n√†y ƒë√£ ƒë∆∞·ª£c ƒë√°nh d·∫•u tr·∫£ r·ªìi');
        return;
      }

      const confirmMsg = `ƒê√°nh d·∫•u ƒë√£ tr·∫£ cho ${name || detail.name}?\n` +
        `${order.itemName} - ${formatMoney(detail.due)} (${detail.qty} ph·∫ßn)`;
      if (!confirm(confirmMsg)) return;

      detail.paid = true;
      lastDebtorPaidSnapshot = {
        name: name || detail.name,
        changes: [{ orderId, detailIndex }]
      };

      localStorage.setItem('orderHistory', JSON.stringify(orderHistory));
      loadDebtManagement();
      loadHistory();
      alert('‚úÖ ƒê√£ ƒë√°nh d·∫•u ƒë√£ tr·∫£');
    }

    function undoLastDebtorPaid() {
      if (!lastDebtorPaidSnapshot || !lastDebtorPaidSnapshot.changes?.length) {
        alert('‚ÑπÔ∏è Kh√¥ng c√≥ thao t√°c n√†o ƒë·ªÉ ho√†n t√°c');
        return;
      }

      const { name, changes } = lastDebtorPaidSnapshot;
      changes.forEach(change => {
        const order = orderHistory.find(o => o.id === change.orderId);
        if (order && order.details[change.detailIndex]) {
          order.details[change.detailIndex].paid = false;
        }
      });

      localStorage.setItem('orderHistory', JSON.stringify(orderHistory));
      loadDebtManagement();
      loadHistory();
      alert(`‚Ü©Ô∏è ƒê√£ ho√†n t√°c ƒë√°nh d·∫•u ƒë√£ tr·∫£ cho ${name}`);
      lastDebtorPaidSnapshot = null;
    }

    // Export helper for manual use and automation
    function exportForAutomation(options = {}) {
      const { download = true, silent = false } = options;

      try {
        const stored = localStorage.getItem('orderHistory');
        const parsed = stored ? JSON.parse(stored) : [];
        const filename = `order_history_${new Date().toISOString().split('T')[0]}.json`;
        const content = JSON.stringify(parsed, null, 2);

        if (download) {
          const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(content);
          const linkElement = document.createElement('a');
          linkElement.setAttribute('href', dataUri);
          linkElement.setAttribute('download', filename);
          document.body.appendChild(linkElement);
          linkElement.click();
          document.body.removeChild(linkElement);
        }

        const result = { success: true, filename, count: parsed.length, content };
        window.__autobackupResult = result;
        return result;
      } catch (error) {
        const result = { success: false, error: error.message };
        window.__autobackupResult = result;
        if (!silent) {
          alert('‚ùå L·ªói export: ' + error.message);
        }
        return result;
      }
    }

    function exportHistory() {
      const res = exportForAutomation({ download: true, silent: true });
      if (!res.success) {
        alert('‚ùå Kh√¥ng th·ªÉ export: ' + res.error);
      }
    }

    function clearHistory() {
      if (!confirm('X√°c nh·∫≠n xo√° to√†n b·ªô l·ªãch s·ª≠ ƒë∆°n h√†ng?')) return;

      orderHistory = [];
      localStorage.setItem('orderHistory', JSON.stringify(orderHistory));
      refreshQuickOrderList();
      loadHistory();
      alert('‚úÖ ƒê√£ xo√° to√†n b·ªô l·ªãch s·ª≠');
    }

    // Debt Management
    function loadDebtManagement() {
      const debtMap = new Map();

      orderHistory.forEach(order => {
        order.details.forEach((d, detailIndex) => {
          if (!d.paid) {
            const current = debtMap.get(d.name) || { total: 0, orders: [] };
            current.total += d.due;
            current.orders.push({
              orderId: order.id,
              itemName: order.itemName,
              date: order.date,
              detailIndex,
              qty: d.qty,
              due: d.due
            });
            debtMap.set(d.name, current);
          }
        });
      });

      // Summary
      const totalDebt = Array.from(debtMap.values()).reduce((sum, d) => sum + d.total, 0);
      const debtorCount = debtMap.size;

      const summaryHTML = `
    <div class="stats-grid">
      <div class="stat-card">
        <div class="stat-icon">üí∞</div>
        <div class="stat-value">${formatMoney(totalDebt)}</div>
        <div class="stat-label">T·ªïng c√¥ng n·ª£</div>
      </div>
      <div class="stat-card">
        <div class="stat-icon">üë•</div>
        <div class="stat-value">${debtorCount}</div>
        <div class="stat-label">Ng∆∞·ªùi ƒëang n·ª£</div>
      </div>
    </div>
  `;

      document.getElementById('debtSummary').innerHTML = summaryHTML;

      // Details
      if (debtMap.size === 0) {
        document.getElementById('debtDetails').innerHTML = '<div class="empty-state"><div class="empty-state-icon">‚úÖ</div>Kh√¥ng c√≥ c√¥ng n·ª£</div>';
        return;
      }

      const undoBtn = `
    <div class="btn-group" style="margin-bottom: 12px;">
      <button class="btn btn-info" onclick="undoLastDebtorPaid()">‚Ü©Ô∏è Ho√†n t√°c l·∫ßn cu·ªëi</button>
    </div>
  `;

      const detailsHTML = undoBtn + Array.from(debtMap.entries())
        .sort((a, b) => b[1].total - a[1].total)
        .map(([name, data]) => `
      <div class="glass-card" style="margin-bottom: 16px; padding: 20px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
          <div>
            <div style="font-size: 20px; font-weight: 700; color: var(--text-primary);">${name}</div>
            <div style="font-size: 14px; color: var(--text-muted);">${data.orders.length} ƒë∆°n ch∆∞a thanh to√°n</div>
          </div>
          <div style="text-align: right;">
            <div style="font-size: 24px; font-weight: 700; color: var(--accent-red);">${formatMoney(data.total)}</div>
            <button class="btn btn-primary" style="margin-top: 8px;" onclick='markDebtorPaid(${JSON.stringify(name)})'>ƒê√£ tr·∫£</button>
          </div>
        </div>

        <div class="table-wrapper">
          <table class="table">
            <thead>
              <tr>
                <th>Ng√†y</th>
                <th>M√≥n</th>
                <th style="text-align: right;">S·ªë ph·∫ßn</th>
                <th style="text-align: right;">Ti·ªÅn</th>
                <th style="text-align: center;">H√†nh ƒë·ªông</th>
              </tr>
            </thead>
            <tbody>
              ${data.orders.map(o => `
                <tr>
                  <td onclick="showOrderDetail(${o.orderId})" style="cursor: pointer;">${formatDate(o.date).split(' ')[0]}</td>
                  <td onclick="showOrderDetail(${o.orderId})" style="cursor: pointer;">${o.itemName}</td>
                  <td style="text-align: right;" onclick="showOrderDetail(${o.orderId})" style="cursor: pointer;">${o.qty}</td>
                  <td style="text-align: right;" onclick="showOrderDetail(${o.orderId})" style="cursor: pointer;">${formatMoney(o.due)}</td>
                  <td style="text-align: center;">
                    <button class="btn btn-primary" style="padding: 6px 10px; font-size: 12px;"
                      onclick='markSingleDebtPaid(${o.orderId}, ${o.detailIndex}, ${JSON.stringify(name)});'>
                      ƒê√£ tr·∫£
                    </button>
                  </td>
                </tr>
              `).join('')}
            </tbody>
          </table>
        </div>
      </div>
    `).join('');

      document.getElementById('debtDetails').innerHTML = detailsHTML;
    }

    // Stats
    function loadStats() {
      if (orderHistory.length === 0) {
        document.getElementById('statsContent').innerHTML = '<div class="empty-state"><div class="empty-state-icon">üìä</div>Ch∆∞a c√≥ d·ªØ li·ªáu ƒë·ªÉ th·ªëng k√™</div>';
        return;
      }

      const totalOrders = orderHistory.length;
      const totalRevenue = orderHistory.reduce((sum, o) => sum + o.revenue, 0);
      const totalCost = orderHistory.reduce((sum, o) => sum + o.totalCost, 0);
      const totalProfit = totalRevenue - totalCost;

      const statsHTML = `
    <div class="stats-grid">
      <div class="stat-card">
        <div class="stat-icon">üì¶</div>
        <div class="stat-value">${totalOrders}</div>
        <div class="stat-label">T·ªïng ƒë∆°n h√†ng</div>
      </div>
      <div class="stat-card">
        <div class="stat-icon">üíµ</div>
        <div class="stat-value">${formatMoney(totalRevenue)}</div>
        <div class="stat-label">T·ªïng thu</div>
      </div>
      <div class="stat-card">
        <div class="stat-icon">üí∏</div>
        <div class="stat-value">${formatMoney(totalCost)}</div>
        <div class="stat-label">T·ªïng chi</div>
      </div>
      <div class="stat-card">
        <div class="stat-icon">${totalProfit >= 0 ? 'üìà' : 'üìâ'}</div>
        <div class="stat-value ${totalProfit >= 0 ? 'profit-positive' : 'profit-negative'}">
          ${formatMoney(Math.abs(totalProfit))}
        </div>
        <div class="stat-label">${totalProfit >= 0 ? 'L·ª£i nhu·∫≠n' : 'Thua l·ªó'}</div>
      </div>
    </div>

    <div class="glass-card" style="margin-top: 24px; padding: 20px;">
      <h3 style="font-size: 16px; margin-bottom: 16px; color: var(--text-secondary);">üçΩ Top m√≥n ƒë∆∞·ª£c order nhi·ªÅu nh·∫•t</h3>
      ${getTopItems()}
    </div>

    <div class="glass-card" style="margin-top: 24px; padding: 20px;">
      <h3 style="font-size: 16px; margin-bottom: 16px; color: var(--text-secondary);">üë• Top ng∆∞·ªùi order nhi·ªÅu nh·∫•t</h3>
      ${getTopPeople()}
    </div>

    <div class="glass-card" style="margin-top: 24px; padding: 20px;">
      <h3 style="font-size: 16px; margin-bottom: 16px; color: var(--text-secondary);">üìë B√°o c√°o VIP (n·∫°p/r√∫t)</h3>
      <div class="form-group">
        <label class="form-label">Ch·ªçn VIP</label>
        <select id="vipReportSelect" class="form-input"></select>
      </div>
      <div id="vipReportContent" class="info-list"></div>
    </div>
  `;

      document.getElementById('statsContent').innerHTML = statsHTML;
      initVipReportPanel();
    }

    function getTopItems() {
      const itemMap = new Map();

      orderHistory.forEach(order => {
        const current = itemMap.get(order.itemName) || { count: 0, revenue: 0 };
        current.count += 1;
        current.revenue += order.revenue;
        itemMap.set(order.itemName, current);
      });

      const sorted = Array.from(itemMap.entries())
        .sort((a, b) => b[1].count - a[1].count)
        .slice(0, 5);

      if (sorted.length === 0) return '<div class="empty-state-icon">‚Äî</div>';

      return `
    <ul class="info-list">
      ${sorted.map(([name, data]) => `
        <li>
          <span class="name">${name}</span>
          <span>
            <span class="value">${data.count} l·∫ßn</span>
            <span class="note">${formatMoney(data.revenue)}</span>
          </span>
        </li>
      `).join('')}
    </ul>
  `;
    }

    function getTopPeople() {
      const peopleMap = new Map();

      orderHistory.forEach(order => {
        order.details.forEach(d => {
          const current = peopleMap.get(d.name) || { count: 0, total: 0 };
          current.count += d.qty;
          current.total += d.due;
          peopleMap.set(d.name, current);
        });
      });

      const sorted = Array.from(peopleMap.entries())
        .sort((a, b) => b[1].count - a[1].count)
        .slice(0, 5);

      if (sorted.length === 0) return '<div class="empty-state-icon">‚Äî</div>';

      return `
    <ul class="info-list">
      ${sorted.map(([name, data]) => `
        <li>
          <span class="name">${name}</span>
          <span>
            <span class="value">${data.count} ph·∫ßn</span>
            <span class="note">${formatMoney(data.total)}</span>
          </span>
        </li>
      `).join('')}
    </ul>
  `;
    }

    function getVipNamesFromTransactions() {
      const names = new Set();
      vipTransactions.forEach(tx => {
        if (tx?.name) names.add(tx.name);
      });
      return Array.from(names).sort((a, b) => a.localeCompare(b, 'vi', { sensitivity: 'base' }));
    }

    function initVipReportPanel() {
      const select = document.getElementById('vipReportSelect');
      const content = document.getElementById('vipReportContent');
      if (!select || !content) return;

      const names = getVipNamesFromTransactions();
      if (names.length === 0) {
        select.innerHTML = '<option value="">Ch∆∞a c√≥ giao d·ªãch VIP</option>';
        content.innerHTML = '<div class="empty-state" style="padding:12px 0;">Ch∆∞a c√≥ giao d·ªãch VIP</div>';
        return;
      }

      select.innerHTML = ['<option value="">Ch·ªçn VIP...</option>'].concat(
        names.map(n => `<option value="${n}">${n}</option>`)
      ).join('');

      select.onchange = (e) => {
        renderVipReport(e.target.value);
      };

      renderVipReport(names[0]);
      select.value = names[0];
    }

    function renderVipReport(name) {
      const content = document.getElementById('vipReportContent');
      if (!content) return;
      const vipName = document.getElementById('vipMemberSelect').value;
      if (!vipName) {
        document.getElementById('vipHistoryContent').innerHTML = '<p style="text-align: center; color: var(--text-secondary);">Ch·ªçn VIP ƒë·ªÉ xem l·ªãch s·ª≠</p>';
        return;
      }

      // Load saved initial balance
      const savedBalance = localStorage.getItem(`vipInitialBalance_${vipName}`);
      const initialBalanceInput = document.getElementById('vipInitialBalance');
      if (initialBalanceInput) {
        initialBalanceInput.value = savedBalance || '0';
      }
      const initialBalance = Number(savedBalance || 0);

      if (!name) {
        content.innerHTML = '<div class="empty-state" style="padding:12px 0;">Ch·ªçn VIP ƒë·ªÉ xem l·ªãch s·ª≠</div>';
        return;
      }

      const records = vipTransactions.filter(tx => tx.name === name);
      if (records.length === 0) {
        content.innerHTML = '<div class="empty-state" style="padding:12px 0;">Kh√¥ng c√≥ giao d·ªãch cho VIP n√†y</div>';
        return;
      }

      const html = `
    <ul class="mini-list">
      ${records.map(tx => `
        <li>
          <div>
            <div><strong>${tx.name}</strong> ‚Ä¢ ${tx.type === 'cashout' ? 'R√∫t' : 'N·∫°p'}</div>
            <div class="note">${formatDate(tx.ts)}</div>
          </div>
            <div class="${tx.amount >= 0 ? 'amount-positive' : 'amount-negative'}">
              ${tx.amount >= 0 ? '+' : ''}${formatMoney(tx.amount)}
            </div>
        </li>
      `).join('')}
    </ul>
  `;

      content.innerHTML = html;
    }

    // Load VIP on page load
    document.addEventListener('DOMContentLoaded', () => {
      vipTransactions = normalizeVipTransactions(JSON.parse(localStorage.getItem(VIP_TX_KEY) || '[]'));
      hydrateVipAreaFromData();
      renderVipHistory();
      refreshQuickOrderList();
      updateDishNameSuggestions();
      loadGithubSettings();
      populateVipMemberSelect();
      populateVIPFilterDropdown(); // Populate filter dropdown

      // Lock VIP textarea to prevent manual editing
      const vipArea = document.getElementById('vipArea');
      if (vipArea) {
        vipArea.setAttribute('readonly', true);
        vipArea.style.cursor = 'not-allowed';
        vipArea.style.opacity = '0.8';
        vipArea.title = 'Ch·ªâ c√≥ th·ªÉ thay ƒë·ªïi qua N·∫°p VIP, Cash Out, ho·∫∑c Order';
      }

      initDraftAutosave();

      // Add listener for alvinFree checkbox to adjust min value of n
      const alvinFreeCheckbox = document.getElementById('alvinFree');
      const nInput = document.getElementById('n');

      if (alvinFreeCheckbox && nInput) {
        alvinFreeCheckbox.addEventListener('change', function () {
          if (this.checked) {
            nInput.min = 2;
            if (Number(nInput.value) < 2) {
              nInput.value = 2;
            }
          } else {
            nInput.min = 1;
          }
        });
      }

      const desiredPriceInput = document.getElementById('desiredPrice');
      if (desiredPriceInput) {
        desiredPriceInput.addEventListener('input', handleDesiredPriceInput);
        desiredPriceInput.addEventListener('change', handleDesiredPriceInput);
      }

      // Auto-backup mode: run export silently after load
      if (autoBackupMode) {
        setTimeout(() => {
          exportForAutomation({ download: false, silent: true });
        }, 1200);
      }
    });

    // VIP Management Functions
    function addNewVIP() {
      const name = prompt('Nh·∫≠p t√™n VIP:');
      if (!name || !name.trim()) return;

      const amount = prompt('S·ªë ti·ªÅn n·∫°p:');
      if (!amount || isNaN(amount) || Number(amount) <= 0) {
        alert('‚ö†Ô∏è S·ªë ti·ªÅn kh√¥ng h·ª£p l·ªá!');
        return;
      }

      const vipMap = parseVip(document.getElementById('vipArea').value);
      const currentBalance = vipMap.get(name.trim()) || 0;
      const newBalance = currentBalance + Number(amount);

      vipMap.set(name.trim(), newBalance);

      const vipText = vipToText(vipMap);
      document.getElementById('vipArea').value = vipText;
      persistVipList(vipText);

      recordVipTransaction({ name: name.trim(), amount: Number(amount), type: 'topup' });
      alert(`‚úÖ ƒê√£ n·∫°p ${formatMoney(Number(amount))} cho ${name.trim()}\nS·ªë d∆∞ m·ªõi: ${formatMoney(newBalance)}`);
    }

    function cashOutVIP() {
      const vipMap = parseVip(document.getElementById('vipArea').value);

      if (vipMap.size === 0) {
        alert('‚ö†Ô∏è Kh√¥ng c√≥ VIP n√†o!');
        return;
      }

      const vipList = Array.from(vipMap.keys()).join('\n');
      const name = prompt(`Ch·ªçn VIP ƒë·ªÉ cash out:\n\n${vipList}\n\nNh·∫≠p t√™n:`);
      if (!name || !name.trim()) return;

      const currentBalance = vipMap.get(name.trim());
      if (currentBalance === undefined) {
        alert('‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y VIP n√†y!');
        return;
      }

      const amount = prompt(`S·ªë d∆∞ hi·ªán t·∫°i: ${formatMoney(currentBalance)}\n\nNh·∫≠p s·ªë ti·ªÅn r√∫t (ho·∫∑c ƒë·ªÉ tr·ªëng ƒë·ªÉ r√∫t h·∫øt):`);

      let withdrawAmount;
      if (!amount || amount.trim() === '') {
        withdrawAmount = currentBalance;
      } else {
        withdrawAmount = Number(amount);
        if (isNaN(withdrawAmount) || withdrawAmount <= 0) {
          alert('‚ö†Ô∏è S·ªë ti·ªÅn kh√¥ng h·ª£p l·ªá!');
          return;
        }
        if (withdrawAmount > currentBalance) {
          alert('‚ö†Ô∏è S·ªë ti·ªÅn r√∫t v∆∞·ª£t qu√° s·ªë d∆∞!');
          return;
        }
      }

      const newBalance = currentBalance - withdrawAmount;

      if (newBalance === 0) {
        vipMap.delete(name.trim());
      } else {
        vipMap.set(name.trim(), newBalance);
      }

      const vipText = vipToText(vipMap);
      document.getElementById('vipArea').value = vipText;
      persistVipList(vipText);

      recordVipTransaction({ name: name.trim(), amount: -withdrawAmount, type: 'cashout' });
      alert(`‚úÖ ƒê√£ cash out ${formatMoney(withdrawAmount)} cho ${name.trim()}\nS·ªë d∆∞ c√≤n l·∫°i: ${formatMoney(newBalance)}`);
    }

    function importHistory() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';

      input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            const data = JSON.parse(event.target.result);

            if (!Array.isArray(data)) {
              throw new Error('Invalid format');
            }

            if (confirm(`B·∫°n c√≥ ch·∫Øc mu·ªën import ${data.length} ƒë∆°n h√†ng?\n\nL∆∞u √Ω: D·ªØ li·ªáu hi·ªán t·∫°i s·∫Ω B·ªä GHI ƒê√à!`)) {
              orderHistory = data;
              localStorage.setItem('orderHistory', JSON.stringify(orderHistory));
              hydrateVipAreaFromData({ forceHistory: true });
              refreshQuickOrderList();
              loadHistory();
              alert('‚úÖ Import th√†nh c√¥ng!');
            }
          } catch (err) {
            alert('‚ùå File kh√¥ng h·ª£p l·ªá! Vui l√≤ng ch·ªçn file JSON ƒë√∫ng ƒë·ªãnh d·∫°ng.');
          }
        };

        reader.readAsText(file);
      };

      input.click();
    }

    // Close modal when clicking outside
    document.getElementById('orderModal').addEventListener('click', (e) => {
      if (e.target.id === 'orderModal') {
        closeModal();
      }
    });
  </script>

</body>

</html>