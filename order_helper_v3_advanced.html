<!DOCTYPE html>
<html lang="vi">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Order Helper Pro - Advanced Edition</title>
  <!-- CSS Files -->
  <link rel="stylesheet" href="css/variables.css">
  <link rel="stylesheet" href="css/base.css">
  <link rel="stylesheet" href="css/components.css">
  <link rel="stylesheet" href="css/layout.css">
  <link rel="stylesheet" href="css/utilities.css">

</head>

<body>

  <div class="container">
    <!-- Header -->
    <div class="header">
      <h1>Order Helper Pro</h1>
      <div class="badge">Advanced Edition - Quick Parse + History + Debt Tracking</div>
    </div>

    <!-- Global Search Bar -->
    <div class="global-search-container">
      <div class="global-search-wrapper">
        <span class="search-icon">ğŸ”</span>
        <input type="text" id="globalSearch" class="global-search-input"
          placeholder="TÃ¬m kiáº¿m order, VIP, mÃ³n Äƒn... (Ctrl+K)" oninput="handleGlobalSearch(this.value)"
          onfocus="this.select()">
        <button class="search-clear" onclick="clearGlobalSearch()" style="display: none;">âœ•</button>
      </div>
      <div id="searchResults" class="search-results-dropdown"></div>
    </div>

    <!-- Tabs -->
    <div class="tabs">
      <div class="tab active" onclick="switchTab(event, 'newOrder')">
        ğŸ†• Táº¡o Ä‘Æ¡n má»›i
      </div>
      <div class="tab" onclick="switchTab(event, 'history')">
        ğŸ“œ Lá»‹ch sá»­ Ä‘Æ¡n hÃ ng
      </div>
      <div class="tab" onclick="switchTab(event, 'debt')">
        ğŸ’° Quáº£n lÃ½ cÃ´ng ná»£
      </div>
      <div class="tab" onclick="switchTab(event, 'stats')">
        ğŸ“Š Thá»‘ng kÃª
      </div>
      <div class="tab" onclick="switchTab(event, 'backup')">
        â˜ï¸ Backup
      </div>
    </div>

    <!-- Tab: New Order -->
    <div id="newOrder" class="tab-content active">
      <div class="grid">
        <!-- Quick Parse Input -->
        <div class="glass-card">
          <div class="section-title">âš¡ Nháº­p nhanh</div>

          <div class="form-group">
            <label class="form-label">Paste danh sÃ¡ch order</label>
            <textarea id="quickInput" class="form-textarea" rows="4"
              placeholder="VD: aDuck, aDave 8, Lucas, Alvis, Hunter, Harrison, Ryan 2, Daniel 2, Ben 2"></textarea>
            <div class="helper-text">
              <strong>Format:</strong> TÃªn (sá»‘ pháº§n máº·c Ä‘á»‹nh = 1), TÃªn 2 (2 pháº§n), TÃªn 3, ...
            </div>
          </div>

          <button class="btn btn-secondary btn-full" onclick="parseQuickInput()">
            ğŸš€ Parse & Fill vÃ o báº£ng
          </button>
        </div>

        <!-- Item & Pricing -->
        <div class="glass-card">
          <div class="section-title">ThÃ´ng tin mÃ³n Äƒn</div>

          <div class="form-group">
            <label class="form-label">TÃªn mÃ³n</label>
            <input id="itemName" class="form-input" list="dishNameHistory" value="Phá»Ÿ bÃ²"
              placeholder="Nháº­p hoáº·c chá»n tÃªn mÃ³n..." autocomplete="off">
            <datalist id="dishNameHistory"></datalist>
            <div class="helper-text">CÃ³ thá»ƒ chá»n mÃ³n tá»« lá»‹ch sá»­ hoáº·c nháº­p tÃªn má»›i</div>
          </div>

          <div class="form-row">
            <div class="form-group">
              <label class="form-label">Tá»•ng pháº§n (n)</label>
              <input id="n" class="form-input" type="number" min="2" step="1" value="12">
              <div class="helper-text">ÄÃ£ tÃ­nh cáº£ pháº§n cá»§a LÃ£o nhÃ¢n gia</div>
            </div>
          </div>

          <div class="checkbox-wrapper">
            <input id="alvinFree" type="checkbox" checked>
            <label class="checkbox-label">
              <strong>LÃ£o nhÃ¢n gia Äƒn 1 pháº§n</strong><br>

            </label>
          </div>

          <div class="form-row">
            <div class="form-group">
              <label class="form-label">Tá»•ng tiá»n mÃ³n (T)</label>
              <input id="totalCost" class="form-input" type="number" min="0" step="1" value="0">
            </div>
            <div class="form-group">
              <label class="form-label">Chi phÃ­/pháº§n (c)</label>
              <input id="costPerUnit" class="form-input" type="number" min="0" step="0.01" value="0">
              <div class="helper-text">Äá»ƒ 0 náº¿u dÃ¹ng T</div>
            </div>
          </div>

          <div class="form-row">
            <div class="form-group">
              <label class="form-label">PhÃ­ ship (S)</label>
              <input id="shipFee" class="form-input" type="number" min="0" step="1" value="0">
            </div>
            <div class="form-group">
              <label class="form-label">Lá»£i nhuáº­n má»¥c tiÃªu</label>
              <input id="targetProfit" class="form-input" type="number" min="0" step="1" value="6">
            </div>
          </div>

          <div class="form-group">
            <label class="form-label">GiÃ¡ bÃ¡n mong muá»‘n</label>
            <input id="desiredPrice" class="form-input" type="number" min="0" step="1"
              placeholder="Nháº­p giÃ¡ muá»‘n bÃ¡n...">
            <div class="helper-text">Tá»± nháº­p giÃ¡ náº¿u khÃ´ng dÃ¹ng má»©c gá»£i Ã½</div>
          </div>

          <button class="btn btn-secondary btn-full" onclick="suggestPrices()">
            ğŸ’¡ Äá» xuáº¥t 2 má»©c giÃ¡
          </button>

          <div id="priceSuggestion"></div>
        </div>

        <!-- VIP Management -->
        <div class="glass-card">
          <div class="section-title">Quáº£n lÃ½ VIP</div>

          <div class="form-group">
            <label class="form-label">Danh sÃ¡ch VIP (name=balance)</label>
            <textarea id="vipArea" class="form-textarea" rows="6">a Duck=145</textarea>
          </div>

          <div class="btn-group">
            <button type="button" class="btn btn-secondary" onclick="addNewVIP()">
              â• Náº¡p VIP
            </button>
            <button type="button" class="btn btn-warning" onclick="cashOutVIP()">
              ğŸ’¸ Cash Out
            </button>
          </div>

          <div class="alert alert-info" style="margin-top: 12px;">
            â„¹ï¸ Khi chá»‘t Ä‘Æ¡n, VIP sáº½ tá»± Ä‘á»™ng trá»« tiá»n. Sá»‘ dÆ° hiá»ƒn thá»‹ trong tin chá»‘t lÃ  sá»‘ dÆ° SAU KHI ÄÃƒ TRá»ª.
          </div>

          <div class="glass-card" style="margin-top: 16px; padding: 16px; background: rgba(255,255,255,0.03);">
            <div class="section-title" style="margin-bottom: 10px;">ğŸª™ Lá»‹ch sá»­ náº¡p/rÃºt VIP</div>
            <div id="vipHistory"></div>
          </div>
        </div>
      </div>

      <div class="glass-card draft-save-card">
        <div class="draft-status">
          <span id="draftStatusDot" class="draft-dot unsaved" aria-label="Tráº¡ng thÃ¡i lÆ°u nhÃ¡p"></span>
          <div>
            <div id="draftStatusText" class="draft-status-text">NhÃ¡p chÆ°a lÆ°u</div>
            <div id="draftMetaText" class="draft-meta">Tá»± Ä‘á»™ng lÆ°u 30 phÃºt/láº§n | LÆ°u cuá»‘i: â€”</div>
            <div id="draftBannerMessage" class="draft-banner"></div>
          </div>
        </div>
        <div class="draft-actions">
          <button class="btn btn-primary" onclick="manualSaveDraft()">ğŸ’¾ LÆ°u nhÃ¡p</button>
          <button class="btn btn-secondary" onclick="loadLatestDraftFromICloud()">ğŸ“‚ Táº£i nhÃ¡p</button>
          <button class="btn btn-danger" onclick="clearDraft()">ğŸ—‘ï¸ XÃ³a nhÃ¡p</button>
        </div>
      </div>

      <!-- VIP Top-up Modal -->
      <div id="vipTopupModal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
          <div class="modal-header">
            <h2>â• Náº¡p VIP</h2>
            <button class="close-btn" onclick="closeVipTopupModal()">Ã—</button>
          </div>
          <div class="modal-body">
            <div class="form-group">
              <label>TÃªn VIP</label>
              <input type="text" id="vipTopupName" class="form-input" placeholder="Nháº­p tÃªn VIP..." autofocus>
            </div>
            <div class="form-group">
              <label>Sá»‘ tiá»n náº¡p (Ä‘)</label>
              <input type="number" id="vipTopupAmount" class="form-input" placeholder="Nháº­p sá»‘ tiá»n..." min="1">
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" onclick="closeVipTopupModal()">Há»§y</button>
            <button type="button" class="btn btn-primary" onclick="submitVipTopup()">Náº¡p tiá»n</button>
          </div>
        </div>
      </div>

      <!-- VIP Cash Out Modal -->
      <div id="vipCashOutModal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
          <div class="modal-header">
            <h2>ğŸ’¸ Cash Out VIP</h2>
            <button class="close-btn" onclick="closeVipCashOutModal()">Ã—</button>
          </div>
          <div class="modal-body">
            <div class="form-group">
              <label>Chá»n VIP</label>
              <select id="vipCashOutName" class="form-input" onchange="updateCashOutBalance()">
                <option value="">-- Chá»n VIP --</option>
              </select>
            </div>
            <div class="form-group">
              <label>Sá»‘ dÆ° hiá»‡n táº¡i</label>
              <input type="text" id="vipCashOutCurrentBalance" class="form-input" readonly disabled>
            </div>
            <div class="form-group">
              <label>Sá»‘ tiá»n rÃºt (Ä‘á»ƒ trá»‘ng Ä‘á»ƒ rÃºt háº¿t)</label>
              <input type="number" id="vipCashOutAmount" class="form-input" placeholder="Nháº­p sá»‘ tiá»n..." min="1">
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" onclick="closeVipCashOutModal()">Há»§y</button>
            <button type="button" class="btn btn-warning" onclick="submitVipCashOut()">RÃºt tiá»n</button>
          </div>
        </div>
      </div>

      <!-- Order Detail Modal -->
      <!-- Order Table -->
      <div class="glass-card" style="margin-top: 24px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
          <div class="section-title" style="margin: 0;">Danh sÃ¡ch order</div>
          <button class="btn btn-ghost" onclick="addRow()">+ ThÃªm ngÆ°á»i</button>
        </div>

        <div class="table-wrapper">
          <table class="table" id="orderTable">
            <thead>
              <tr>
                <th style="width: 36%">TÃªn</th>
                <th style="width: 16%; text-align: right;">Sá»‘ pháº§n</th>
                <th style="width: 16%; text-align: right;">Pháº§n ship</th>
                <th style="width: 16%; text-align: center;">ÄÃ£ tráº£?</th>
                <th style="width: 16%; text-align: center;">XoÃ¡</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><input class="name-input" value="Ben" placeholder="Nháº­p tÃªn..."></td>
                <td><input type="number" min="1" step="1" value="1"></td>
                <td><input type="number" min="0" step="1" value="0" class="ship-count-input" placeholder="0"></td>
                <td style="text-align: center;"><input type="checkbox" class="payment-check"></td>
                <td style="text-align: center;"><button class="btn btn-danger" onclick="delRow(this)">âœ•</button></td>
              </tr>
            </tbody>
          </table>
        </div>

        <div class="helper-text">
          <strong>LÆ°u Ã½:</strong> Tick "ÄÃ£ tráº£" cho ngÆ°á»i Ä‘Ã£ thanh toÃ¡n ngay
        </div>
      </div>

      <!-- Compute Section -->
      <div class="glass-card" style="margin-top: 24px;">
        <div class="btn-group">
          <button class="btn btn-secondary" onclick="compute({ save: false })" style="flex: 1;">
            ğŸ§® TÃ­nh tiá»n
          </button>
          <button class="btn btn-primary" onclick="compute({ save: true })" style="flex: 1;">
            ğŸ’¾ LÆ°u Ä‘Æ¡n
          </button>
          <button class="btn btn-warning" onclick="resetOutput()" style="flex: 1;">
            ğŸ—‘ï¸ XoÃ¡ káº¿t quáº£
          </button>
        </div>

        <div id="summarySection"></div>
      </div>

      <!-- Message Output -->
      <div class="grid grid-2" style="margin-top: 24px;">
        <div class="glass-card">
          <div class="section-title">Tin nháº¯n chá»‘t Ä‘Æ¡n</div>

          <div class="form-group">
            <textarea id="finalMsg" class="form-textarea" rows="6" readonly></textarea>
          </div>

          <button class="btn btn-primary btn-full" onclick="copyAndSaveFinalMsg(event)">
            ğŸ“‹ Copy tin chá»‘t
          </button>
        </div>

        <div class="glass-card">
          <div class="section-title">Tin má»Ÿ order</div>

          <div class="form-group">
            <label class="form-label">Chá»n mÃ³n nhanh (tá»« lá»‹ch sá»­)</label>
            <select id="quickOrderSelect" class="form-input"></select>
            <div class="helper-text">Danh sÃ¡ch tá»± cáº­p nháº­t má»—i khi lÆ°u Ä‘Æ¡n</div>
          </div>

          <div class="form-row">
            <div class="form-group">
              <label class="form-label">Sá»‘ lÆ°á»£ng order</label>
              <input id="quickOrderQty" class="form-input" type="number" min="1" step="1" value="1">
            </div>
            <div class="form-group" style="display: flex; align-items: flex-end;">
              <button class="btn btn-secondary btn-full" onclick="generateOpenMsg()">Táº¡o tin</button>
            </div>
          </div>

          <div class="form-group">
            <textarea id="openMsg" class="form-textarea" rows="6" readonly></textarea>
          </div>

          <button class="btn btn-primary btn-full" onclick="copyMsg('openMsg', event)">
            ğŸ“‹ Copy tin má»Ÿ
          </button>
        </div>
      </div>
    </div>

    <!-- Tab: History -->
    <div id="history" class="tab-content">
      <div class="glass-card">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
          <div class="section-title" style="margin: 0;">Lá»‹ch sá»­ Ä‘Æ¡n hÃ ng</div>
          <div class="btn-group">
            <button class="btn btn-info" onclick="importHistory()">ğŸ“¤ Import</button>
            <button class="btn btn-secondary" onclick="exportHistory()">ğŸ“¥ Export JSON</button>
            <button class="btn btn-warning" onclick="clearHistory()">ğŸ—‘ï¸ XoÃ¡ táº¥t cáº£</button>
          </div>
        </div>

        <!-- Filter Controls -->
        <div class="history-filters" style="margin-bottom: 20px;">
          <div
            style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; margin-bottom: 12px;">
            <div>
              <label style="display: block; font-size: 0.75rem; color: var(--text-muted); margin-bottom: 4px;">ğŸ“… Tá»«
                ngÃ y</label>
              <input type="date" id="filterFromDate" class="form-input" style="padding: 8px 12px;"
                onchange="applyHistoryFilters()">
            </div>
            <div>
              <label style="display: block; font-size: 0.75rem; color: var(--text-muted); margin-bottom: 4px;">ğŸ“… Äáº¿n
                ngÃ y</label>
              <input type="date" id="filterToDate" class="form-input" style="padding: 8px 12px;"
                onchange="applyHistoryFilters()">
            </div>
            <div>
              <label style="display: block; font-size: 0.75rem; color: var(--text-muted); margin-bottom: 4px;">ğŸ‘¤
                VIP</label>
              <select id="filterVIP" class="form-select" style="padding: 8px 12px;" onchange="applyHistoryFilters()">
                <option value="">Táº¥t cáº£</option>
              </select>
            </div>
            <div>
              <label style="display: block; font-size: 0.75rem; color: var(--text-muted); margin-bottom: 4px;">ğŸœ MÃ³n
                Äƒn</label>
              <input type="text" id="filterItem" class="form-input" style="padding: 8px 12px;" placeholder="TÃ¬m mÃ³n..."
                oninput="applyHistoryFilters()">
            </div>
          </div>
          <div style="display: flex; gap: 8px; align-items: center;">
            <button class="btn btn-primary" onclick="applyHistoryFilters()" style="padding: 8px 16px;">
              ğŸ” Lá»c
            </button>
            <button class="btn btn-secondary" onclick="clearHistoryFilters()" style="padding: 8px 16px;">
              âœ• XÃ³a bá»™ lá»c
            </button>
            <div id="filterSummary" style="flex: 1; font-size: 0.85rem; color: var(--text-muted);"></div>
          </div>
        </div>

        <div id="historyList"></div>
      </div>
    </div>

    <!-- Tab: Debt Management -->
    <div id="debt" class="tab-content">
      <div class="glass-card">
        <div class="section-title">ğŸ’° Tá»•ng quan cÃ´ng ná»£</div>
        <div id="debtSummary"></div>
      </div>

      <div class="glass-card" style="margin-top: 24px;">
        <div class="section-title">ğŸ“‹ Chi tiáº¿t tá»«ng ngÆ°á»i</div>
        <div id="debtDetails"></div>
      </div>

      <!-- VIP Transaction History -->
      <div class="glass-card" style="margin-top: 24px;">
        <div class="section-title">ğŸ“Š Lá»‹ch sá»­ giao dá»‹ch VIP</div>

        <div class="form-group">
          <label class="form-label">Chá»n VIP member</label>
          <select id="vipMemberSelect" class="form-input" onchange="showVipMemberHistory()">
            <option value="">-- Chá»n VIP --</option>
          </select>
        </div>

        <div class="form-group">
          <label class="form-label">Sá»‘ dÆ° ban Ä‘áº§u (Ä‘)</label>
          <input type="number" id="vipInitialBalance" class="form-input" placeholder="0" oninput="saveInitialBalance()"
            onblur="saveInitialBalance()">
          <div class="helper-text">Nháº­p sá»‘ dÆ° táº¡i thá»i Ä‘iá»ƒm báº¯t Ä‘áº§u tÃ­nh (Ä‘á»ƒ trá»‘ng = 0Ä‘)</div>
        </div>

        <!-- Transaction Filters -->
        <div id="vipHistoryFilters"
          style="display: none; margin-top: 16px; padding: 16px; background: rgba(255,255,255,0.03); border-radius: 12px; border: 1px solid rgba(255,255,255,0.08);">
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px;">
            <div class="form-group" style="margin: 0;">
              <label class="form-label" style="font-size: 12px;">Tá»« ngÃ y</label>
              <input type="date" id="filterDateFrom" class="form-input" style="font-size: 13px; padding: 8px;"
                onchange="applyVipHistoryFilters()">
            </div>
            <div class="form-group" style="margin: 0;">
              <label class="form-label" style="font-size: 12px;">Äáº¿n ngÃ y</label>
              <input type="date" id="filterDateTo" class="form-input" style="font-size: 13px; padding: 8px;"
                onchange="applyVipHistoryFilters()">
            </div>
            <div class="form-group" style="margin: 0;">
              <label class="form-label" style="font-size: 12px;">Loáº¡i giao dá»‹ch</label>
              <select id="filterTxType" class="form-input" style="font-size: 13px; padding: 8px;"
                onchange="applyVipHistoryFilters()">
                <option value="all">Táº¥t cáº£</option>
                <option value="topup">ğŸ’° Náº¡p tiá»n</option>
                <option value="cashout">ğŸ’¸ RÃºt tiá»n</option>
                <option value="order">ğŸœ Order</option>
              </select>
            </div>
            <div class="form-group" style="margin: 0;">
              <label class="form-label" style="font-size: 12px;">Tráº¡ng thÃ¡i thanh toÃ¡n</label>
              <select id="filterPaymentStatus" class="form-input" style="font-size: 13px; padding: 8px;"
                onchange="applyVipHistoryFilters()">
                <option value="all">Táº¥t cáº£</option>
                <option value="paid">âœ… ÄÃ£ tráº£</option>
                <option value="unpaid">â³ ChÆ°a tráº£</option>
              </select>
            </div>
          </div>
          <div style="display: flex; gap: 8px; margin-top: 12px; flex-wrap: wrap;">
            <button onclick="clearVipHistoryFilters()" class="btn-secondary"
              style="padding: 8px 16px; font-size: 13px;">ğŸ”„ Äáº·t láº¡i</button>
            <button onclick="exportVipHistoryToCSV()" class="btn-primary"
              style="padding: 8px 16px; font-size: 13px; background: linear-gradient(135deg, var(--accent-green), var(--accent-blue));">ğŸ“¥
              Xuáº¥t CSV</button>
            <div style="flex: 1;"></div>
            <span id="filterResultCount" style="font-size: 13px; color: var(--text-muted); line-height: 32px;"></span>
          </div>
        </div>

        <div id="vipMemberHistoryContainer"></div>
      </div>
    </div>

    <!-- Tab: Stats -->
    <div id="stats" class="tab-content">
      <div class="glass-card">
        <div class="section-title">ğŸ“Š Thá»‘ng kÃª tá»•ng quan</div>
        <div id="statsContent"></div>
      </div>
    </div>

    <!-- Tab: Backup -->
    <div id="backup" class="tab-content">
      <!-- GitHub Settings -->
      <div class="glass-card">
        <div class="section-title">âš™ï¸ CÃ i Ä‘áº·t GitHub</div>

        <div class="alert alert-info">
          <span>â„¹ï¸</span>
          <div>
            <strong>HÆ°á»›ng dáº«n setup:</strong><br>
            1. Táº¡o GitHub Personal Access Token táº¡i <a href="https://github.com/settings/tokens" target="_blank"
              style="color: #60a5fa;">github.com/settings/tokens</a><br>
            2. Chá»n scope: <code>repo</code> (Full control of private repositories)<br>
            3. Copy token vÃ  paste vÃ o Ã´ bÃªn dÆ°á»›i<br>
            4. Nháº­p tÃªn repository (vÃ­ dá»¥: vuhoanganh/OrderHelper)
          </div>
        </div>

        <div class="form-group">
          <label class="form-label">GitHub Personal Access Token</label>
          <input id="githubToken" class="form-input" type="password" placeholder="ghp_xxxxxxxxxxxx"
            onblur="loadGithubRepos()">
          <div class="helper-text">Token sáº½ Ä‘Æ°á»£c lÆ°u trong localStorage cá»§a trÃ¬nh duyá»‡t</div>
        </div>

        <div class="form-row">
          <div class="form-group">
            <label class="form-label">Repository (owner/repo)</label>
            <select id="githubRepo" class="form-input" onchange="loadGithubBranches()">
              <option value="">-- Select repository --</option>
            </select>
            <div class="helper-text" id="repoLoadingStatus" style="display:none; color: var(--accent-blue);">â³ Loading
              repositories...</div>
          </div>
          <div class="form-group">
            <label class="form-label">Branch</label>
            <select id="githubBranch" class="form-input">
              <option value="main">main</option>
            </select>
            <div class="helper-text" id="branchLoadingStatus" style="display:none; color: var(--accent-blue);">â³ Loading
              branches...</div>
          </div>
        </div>

        <div class="checkbox-wrapper">
          <input id="githubAutoBackupEnabled" type="checkbox">
          <label class="checkbox-label">
            <strong>Báº­t auto-backup</strong><br>
            Tá»± Ä‘á»™ng backup data lÃªn GitHub theo interval Ä‘Ã£ cÃ i Ä‘áº·t
          </label>
        </div>

        <div class="form-group">
          <label class="form-label">Auto-backup Interval (phÃºt)</label>
          <input id="githubBackupInterval" class="form-input" type="number" min="5" step="5" value="30"
            placeholder="30">
          <div class="helper-text">Thá»i gian giá»¯a cÃ¡c láº§n auto-backup (tá»‘i thiá»ƒu 5 phÃºt)</div>
        </div>

        <button class="btn btn-primary btn-full" onclick="saveGithubSettings()">
          ğŸ’¾ LÆ°u cÃ i Ä‘áº·t
        </button>
      </div>

      <!-- Backup Controls -->
      <div class="glass-card">
        <div class="section-title">ğŸ”„ Backup & Restore</div>

        <div id="githubBackupStatus" class="alert alert-info" style="display: none;">
          <span>â„¹ï¸</span>
          <div id="githubBackupStatusText">ChÆ°a cÃ³ backup nÃ o</div>
        </div>

        <div class="summary-grid">
          <div class="summary-item">
            <h3>Láº§n backup cuá»‘i</h3>
            <div class="summary-value" id="lastBackupTime">--</div>
            <div class="summary-detail" id="lastBackupCommit">--</div>
          </div>
          <div class="summary-item">
            <h3>Tráº¡ng thÃ¡i</h3>
            <div class="summary-value" id="backupStatusIndicator">--</div>
            <div class="summary-detail" id="backupStatusDetail">--</div>
          </div>
        </div>

        <div class="btn-group" style="margin-bottom: 20px;">
          <button class="btn btn-primary" onclick="backupToGithub()" style="flex: 1;">
            ğŸ“¤ Backup to GitHub
          </button>
          <button class="btn btn-success" onclick="syncNow()" style="flex: 1;">
            ğŸ”„ Sync Now
          </button>
          <button class="btn btn-success" onclick="downloadBackup()" style="flex: 1;">
            ğŸ’¾ Download Backup
          </button>
          <button class="btn btn-info" onclick="restoreFromFile()" style="flex: 1;">
            ğŸ“¥ Restore from File
          </button>
          <button class="btn btn-secondary" onclick="restoreFromGithub()" style="flex: 1;">
            ğŸ“¥ Restore
          </button>
        </div>

        <div class="helper-text" style="margin-top: 16px;">
          <strong>Data sáº½ backup:</strong> Order History, VIP List, VIP Transactions
        </div>
      </div>

      <!-- Backup Log -->
      <div class="glass-card">
        <div class="section-title">ğŸ“ Backup Log</div>
        <div id="backupLog"
          style="max-height: 300px; overflow-y: auto; font-family: monospace; font-size: 12px; color: var(--text-secondary);">
          ChÆ°a cÃ³ log...
        </div>
      </div>
    </div>

  </div>

  <!-- Modal for Order Details -->
  <div id="orderModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">Chi tiáº¿t Ä‘Æ¡n hÃ ng</div>
        <button class="modal-close" onclick="closeModal()">Ã—</button>
      </div>
      <div id="modalBody"></div>
    </div>
  </div>

  <script>
    // Global State
    let orderHistory = JSON.parse(localStorage.getItem('orderHistory') || '[]');
    let selectedPrice = null;
    const autoBackupMode = new URLSearchParams(window.location.search).get('autobackup') === 'true';
    const DRAFT_STORAGE_KEY = 'draftOrder';
    const DRAFT_META_KEY = 'draftBackupMeta';
    const DRAFT_DIR = '/Users/alvin/Library/Mobile Documents/com~apple~CloudDocs/Kitchen/drafts';
    const DRAFT_BACKUP_INTERVAL_MS = 30 * 60 * 1000;
    const DRAFT_RETRY_INTERVAL_MS = 5 * 60 * 1000;
    let draftDirty = false;
    let draftBackupIntervalId = null;
    let draftBackupRetryTimeout = null;
    let lastDraftBackupPath = null;
    let debouncedLocalDraftSave;
    let draftBackupInFlight = false;
    let suppressDraftChange = false;
    let lastDebtorPaidSnapshot = null;
    let lastComputedSignature = null;
    let lastSavedSignature = null;
    let lastComputedOrder = null;
    let editingOrderId = null;
    let editingOrderDate = null;
    const VIP_TX_KEY = 'vipTransactions';
    let vipTransactions = [];

    // GitHub Backup Variables
    let githubAutoBackupInterval = null;
    const GITHUB_TOKEN_KEY = 'github_token';
    const GITHUB_REPO_KEY = 'github_repo';
    const GITHUB_BRANCH_KEY = 'github_branch';
    const GITHUB_BACKUP_FOLDER_KEY = 'github_backup_folder';
    const GITHUB_AUTO_BACKUP_ENABLED_KEY = 'github_auto_backup_enabled';
    const GITHUB_BACKUP_INTERVAL_KEY = 'github_backup_interval';
    const GITHUB_LAST_BACKUP_KEY = 'github_last_backup';
    const GITHUB_LAST_COMMIT_SHA_KEY = 'github_last_commit_sha';

    // Smart Name Matcher Class
    class SmartNameMatcher {
      constructor() {
        this.nameMap = new Map(); // normalized â†’ {original, data}
      }

      normalize(name) {
        if (!name) return '';
        return name
          .trim()
          .toLowerCase()
          .replace(/\s+/g, '')
          .normalize('NFD')
          .replace(/[\u0300-\u036f]/g, '');
      }

      add(name, data) {
        if (!name || !name.trim()) return;

        const normalized = this.normalize(name);
        const trimmedName = name.trim();

        // Check if already exists
        if (this.nameMap.has(normalized)) {
          const existing = this.nameMap.get(normalized);
          // Update data but keep original name if it's more "complete"
          if (trimmedName.length >= existing.original.length) {
            existing.original = trimmedName;
          }
          existing.data = data;
        } else {
          this.nameMap.set(normalized, {
            original: trimmedName,
            data: data
          });
        }
      }

      find(name) {
        const normalized = this.normalize(name);
        return this.nameMap.get(normalized);
      }

      getOriginalName(name) {
        const found = this.find(name);
        return found ? found.original : name.trim();
      }

      getData(name) {
        const found = this.find(name);
        return found ? found.data : null;
      }

      has(name) {
        const normalized = this.normalize(name);
        return this.nameMap.has(normalized);
      }

      getAllEntries() {
        return Array.from(this.nameMap.values()).map(v => ({
          name: v.original,
          data: v.data
        }));
      }

      clear() {
        this.nameMap.clear();
      }

      // Calculate similarity for fuzzy matching
      calculateSimilarity(str1, str2) {
        const longer = str1.length > str2.length ? str1 : str2;
        const shorter = str1.length > str2.length ? str2 : str1;

        if (longer.includes(shorter)) return 1.0;

        let matches = 0;
        for (let char of shorter) {
          if (longer.includes(char)) matches++;
        }
        return matches / longer.length;
      }

      // Find similar names (for suggestions)
      findSimilar(name, threshold = 0.7) {
        const normalized = this.normalize(name);
        const results = [];

        for (let [key, value] of this.nameMap) {
          const similarity = this.calculateSimilarity(normalized, key);
          if (similarity >= threshold && similarity < 1.0) {
            results.push({
              name: value.original,
              similarity: similarity
            });
          }
        }

        return results.sort((a, b) => b.similarity - a.similarity);
      }
    }

    // Utility Functions
    function formatMoney(x) {
      const neg = x < 0;
      const v = Math.round(Math.abs(x) * 100) / 100;
      return (neg ? '-' : '') + (Number.isInteger(v) ? v.toString() : v.toFixed(2)) + 'Ä‘';
    }

    function ceilInt(x) {
      return Math.ceil(x);
    }

    function parseVip(text) {
      const matcher = new SmartNameMatcher();

      text.split(/\n+/).forEach(line => {
        line = line.trim();
        if (!line) return;

        const [name, bal] = line.split('=');
        if (!name) return;

        const v = parseFloat((bal || '0').replace(/[^0-9.\-]/g, ''));
        const balance = isNaN(v) ? 0 : v;

        matcher.add(name, balance);
      });

      // Convert to Map for backward compatibility
      const map = new Map();
      matcher.getAllEntries().forEach(entry => {
        map.set(entry.name, entry.data);
      });

      // Attach matcher for later use
      map._matcher = matcher;

      return map;
    }

    function vipToText(map) {
      return Array.from(map.entries())
        .map(([k, v]) => `${k}=${formatMoney(v)}`)
        .join('\n');
    }

    function persistVipList(text, timestamp = Date.now()) {
      localStorage.setItem('vipList', text);
      localStorage.setItem('vipUpdatedAt', String(timestamp));
    }

    // Recompute VIP balances from current data to keep VIP management in sync with reports
    function recomputeVipBalances() {
      const vipAreaText = document.getElementById('vipArea')?.value || '';
      const vipMapCurrent = parseVip(vipAreaText);
      const baseNames = new Set(vipMapCurrent.keys()); // giá»¯ tÃªn Ä‘Ã£ cÃ³, nhÆ°ng khÃ´ng dÃ¹ng balance cÅ©
      const txNames = new Set();
      vipTransactions.forEach(tx => { if (tx.name) txNames.add(tx.name); });

      // Cá»™ng thÃªm cÃ¡c VIP cÃ³ default initial
      const defaultNames = new Set(Object.keys(DEFAULT_INITIAL_BALANCE));

      const names = new Set([...baseNames, ...txNames, ...defaultNames]);
      if (names.size === 0) return;

      const newMap = new Map();

      names.forEach(name => {
        const entries = [];

        const buildOrderKeys = (amt, item = '') => {
          const amount = Math.abs(Number(amt) || 0);
          const itemKey = (item || '').trim().toLowerCase();
          const keys = [`${amount}|${itemKey}`];
          // fallback: amount-only to dedupe vipTransactions (thÆ°á»ng khÃ´ng cÃ³ itemName)
          keys.push(`amount|${amount}`);
          return keys;
        };

        // VIP topup/cashout/order entries
        vipTransactions
          .filter(tx => tx.name === name)
          .forEach(tx => entries.push({
            ts: tx.ts || tx.id || Date.now(),
            amount: tx.amount,
            type: tx.type || (tx.amount >= 0 ? 'topup' : 'cashout'),
            isVipPayment: true
          }));

        // Build set of order keys already in vipTransactions to avoid double-count
        const vipOrderKeys = new Set();
        vipTransactions
          .filter(tx => tx.name === name && tx.type === 'order')
          .forEach(tx => buildOrderKeys(tx.amount, tx.itemName).forEach(k => vipOrderKeys.add(k)));

        // Orders for this VIP (chá»‰ tÃ­nh náº¿u Ä‘Ã£ lÃ  VIP hoáº·c cÃ³ tx VIP)
        orderHistory.forEach(order => {
          (order.details || []).forEach(d => {
            if (d.name !== name) return;
            const keys = buildOrderKeys(d.due, order.itemName);
            if (keys.some(k => vipOrderKeys.has(k))) return; // trÃ¡nh trÃ¹ng vá»›i tx VIP Ä‘Ã£ ghi
            entries.push({
              ts: order.date || order.id || Date.now(),
              amount: -Math.abs(d.due || 0),
              type: 'order',
              paid: !!d.paid,
              isVipPayment: !!d.isVipPayment
            });
          });
        });

        entries.sort((a, b) => new Date(a.ts).getTime() - new Date(b.ts).getTime());

        let bal = getInitialBalanceForVip(name, { persistDefault: true });
        let allowCredit = bal > 0;

        entries.forEach(e => {
          if (e.type === 'order') {
            const need = Math.abs(e.amount || 0);
            const payWithVip = e.isVipPayment || (e.paid && (bal >= need || allowCredit));
            if (payWithVip && need > 0) {
              bal += e.amount;
            }
          } else {
            bal += e.amount;
            if (e.amount > 0) allowCredit = true;
          }
        });

        // KhÃ´ng thÃªm vÃ o danh sÃ¡ch náº¿u balance báº±ng 0 vÃ  khÃ´ng cÃ³ giao dá»‹ch VIP, khÃ´ng cÃ³ default, khÃ´ng náº±m trong danh sÃ¡ch gá»‘c
        const hasVipTx = txNames.has(name);
        const hasDefault = DEFAULT_INITIAL_BALANCE[name] && DEFAULT_INITIAL_BALANCE[name] !== 0;
        const hasBase = baseNames.has(name);
        if (bal === 0 && !hasVipTx && !hasDefault && !hasBase) return;
        newMap.set(name, bal);
      });

      // Persist back to textarea/localStorage
      const vipText = vipToText(newMap);
      const vipArea = document.getElementById('vipArea');
      if (vipArea) vipArea.value = vipText;
      persistVipList(vipText);
    }

    // Update dish name suggestions from order history
    function updateDishNameSuggestions() {
      const datalist = document.getElementById('dishNameHistory');
      if (!datalist) return;

      const seen = new Set();
      const items = [];

      orderHistory.forEach(order => {
        const name = (order?.itemName || '').trim();
        if (!name || seen.has(name)) return;
        seen.add(name);
        const ts = new Date(order?.date || order?.id || 0).getTime() || 0;
        items.push({ name, ts });
      });

      if (items.length === 0) {
        datalist.innerHTML = '';
        return;
      }

      items.sort((a, b) => b.ts - a.ts);
      datalist.innerHTML = items.map(i => `<option value="${i.name.replace(/"/g, '&quot;')}">`).join('');
    }

    // Ensure dish suggestion dropdown can be opened even khi giÃ¡ trá»‹ hiá»‡n táº¡i khÃ´ng khá»›p
    function openDishSuggestions() {
      const input = document.getElementById('itemName');
      const datalist = document.getElementById('dishNameHistory');
      if (!input || !datalist || !datalist.options?.length) return;
      const prev = input.value;
      input.value = ''; // clear Ä‘á»ƒ browser hiá»ƒn thá»‹ toÃ n bá»™ options
      if (typeof input.showPicker === 'function') {
        input.showPicker();
      }
      setTimeout(() => {
        if (document.activeElement === input) {
          input.value = prev;
        }
      }, 100);
    }

    function getLatestVipFromHistory() {
      if (!Array.isArray(orderHistory) || orderHistory.length === 0) return null;

      const latest = orderHistory.reduce((acc, order) => {
        const time = new Date(order?.date || order?.id || 0).getTime();
        if (!isFinite(time) || !Array.isArray(order?.vipSnapshot) || order.vipSnapshot.length === 0) return acc;
        if (time > acc.time) {
          return { time, snapshot: order.vipSnapshot };
        }
        return acc;
      }, { time: -Infinity, snapshot: null });

      return latest.snapshot ? latest : null;
    }

    function hydrateVipAreaFromData(options = {}) {
      const vipArea = document.getElementById('vipArea');
      if (!vipArea) return;

      const savedVipText = (localStorage.getItem('vipList') || '').trim();
      const savedUpdatedAt = Number(localStorage.getItem('vipUpdatedAt') || 0);
      const hasSavedTimestamp = Number.isFinite(savedUpdatedAt) && savedUpdatedAt > 0;

      let chosenText = savedVipText;
      let chosenUpdatedAt = hasSavedTimestamp ? savedUpdatedAt : null;

      const latestHistoryVip = getLatestVipFromHistory();
      const shouldUseHistory = latestHistoryVip && (
        options.forceHistory ||
        !chosenText ||
        !hasSavedTimestamp || // náº¿u chÆ°a tá»«ng ghi timestamp thÃ¬ láº¥y dá»¯ liá»‡u má»›i nháº¥t tá»« history
        latestHistoryVip.time > savedUpdatedAt
      );

      if (shouldUseHistory) {
        const map = new Map(latestHistoryVip.snapshot);
        chosenText = vipToText(map);
        chosenUpdatedAt = latestHistoryVip.time;
      }

      if (chosenText) {
        vipArea.value = chosenText;
        persistVipList(chosenText, chosenUpdatedAt || Date.now());
      }
    }

    function formatDate(date) {
      const d = new Date(date);
      return d.toLocaleDateString('vi-VN', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      });
    }

    function debounce(fn, wait) {
      let t;
      return (...args) => {
        clearTimeout(t);
        t = setTimeout(() => fn.apply(null, args), wait);
      };
    }

    // ========== GitHub Backup Functions ==========

    function addBackupLog(message) {
      const logDiv = document.getElementById('backupLog');
      if (!logDiv) return;
      const timestamp = new Date().toLocaleTimeString('vi-VN');
      const line = `[${timestamp}] ${message}`;
      if (logDiv.textContent === 'ChÆ°a cÃ³ log...') {
        logDiv.textContent = line;
      } else {
        logDiv.textContent = line + '\n' + logDiv.textContent;
      }
      // Keep only last 50 lines
      const lines = logDiv.textContent.split('\n');
      if (lines.length > 50) {
        logDiv.textContent = lines.slice(0, 50).join('\n');
      }
    }

    function showBackupStatus(message, type = 'info') {
      const statusDiv = document.getElementById('githubBackupStatus');
      const textDiv = document.getElementById('githubBackupStatusText');
      if (!statusDiv || !textDiv) return;

      textDiv.textContent = message;
      statusDiv.style.display = 'flex';
      statusDiv.className = `alert alert-${type}`;

      // Auto-hide after 5 seconds for success/info messages
      if (type === 'success' || type === 'info') {
        setTimeout(() => {
          statusDiv.style.display = 'none';
        }, 5000);
      }
    }

    async function githubApiRequest(endpoint, method = 'GET', body = null) {
      const token = localStorage.getItem(GITHUB_TOKEN_KEY);
      if (!token) {
        throw new Error('GitHub token khÃ´ng tÃ¬m tháº¥y. Vui lÃ²ng cÃ i Ä‘áº·t token trong tab Backup.');
      }

      const url = `https://api.github.com${endpoint}`;
      const headers = {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/vnd.github.v3+json',
        'Content-Type': 'application/json'
      };

      const options = {
        method,
        headers
      };

      if (body) {
        options.body = JSON.stringify(body);
      }

      const response = await fetch(url, options);

      if (!response.ok) {
        const error = await response.json().catch(() => ({ message: response.statusText }));
        throw new Error(`GitHub API Error: ${error.message || response.statusText}`);
      }

      // Handle 204 No Content
      if (response.status === 204) {
        return null;
      }

      return await response.json();
    }

    async function getGithubFile(owner, repo, path, branch = 'main') {
      try {
        const data = await githubApiRequest(`/repos/${owner}/${repo}/contents/${path}?ref=${branch}`);
        if (data && data.content) {
          // Decode base64 content
          const content = atob(data.content.replace(/\n/g, ''));
          return {
            content,
            sha: data.sha
          };
        }
        return null;
      } catch (err) {
        // File not found is not an error in this case
        if (err.message.includes('Not Found') || err.message.includes('404')) {
          return null;
        }
        throw err;
      }
    }

    async function createOrUpdateGithubFile(owner, repo, path, content, message, sha = null) {
      const body = {
        message,
        content: btoa(unescape(encodeURIComponent(content))), // Encode to base64 with UTF-8 support
        branch: localStorage.getItem(GITHUB_BRANCH_KEY) || 'main'
      };

      if (sha) {
        body.sha = sha; // Required when updating existing file
      }

      return await githubApiRequest(`/repos/${owner}/${repo}/contents/${path}`, 'PUT', body);
    }

    function formatDraftTime(ts) {
      if (!ts) return 'â€”';
      return new Date(ts).toLocaleString('vi-VN', { hour12: false });
    }

    function normalizeVipTransactions(data = []) {
      if (!Array.isArray(data)) return [];
      const normalized = data.map((tx, idx) => {
        const amount = Number(tx?.amount);
        const idTs = Number(tx?.id);
        const parsedIdDate = isFinite(idTs) ? new Date(idTs) : null;
        const hasValidIdDate = parsedIdDate && isFinite(parsedIdDate.getTime());
        const tsSource = tx?.ts || (hasValidIdDate ? parsedIdDate.toISOString() : null);
        const parsedTs = tsSource ? new Date(tsSource) : null;
        const hasValidTs = parsedTs && isFinite(parsedTs.getTime());

        return {
          id: hasValidIdDate ? idTs : Date.now() + idx,
          ts: hasValidTs ? parsedTs.toISOString() : (hasValidIdDate ? parsedIdDate.toISOString() : new Date().toISOString()),
          name: (tx?.name || '').trim(),
          amount: isFinite(amount) ? amount : 0,
          type: tx?.type || (amount >= 0 ? 'topup' : 'cashout')
        };
      }).filter(tx => tx.name);

      localStorage.setItem(VIP_TX_KEY, JSON.stringify(normalized.slice(0, 200)));
      return normalized;
    }

    function buildOrderSignature(data = {}) {
      const normalizedDetails = Array.isArray(data.details) ? data.details.map(d => ({
        name: d.name,
        qty: d.qty,
        shipQty: d.shipQty || d.shipParts || 0,
        paid: !!d.paid,
        due: Number(d.due || 0),
        unitPrice: d.unitPrice
      })) : [];

      return JSON.stringify({
        itemName: data.itemName || '',
        totalParts: data.totalParts || 0,
        alvinFree: !!data.alvinFree,
        totalCostInput: Number(data.totalCostInput || 0),
        costPerUnitInput: Number(data.costPerUnitInput || 0),
        shipFee: Number(data.shipFee || 0),
        targetProfit: Number(data.targetProfit || 0),
        priceNonShip: Number(data.priceNonShip || 0),
        priceShip: Number(data.priceShip || data.priceNonShip || 0),
        splitShipMode: !!data.splitShipMode,
        details: normalizedDetails
      });
    }

    function recordVipTransaction({ name, amount, type, itemName, orderId }) {
      if (!name || !Number.isFinite(amount)) return;
      const entry = {
        id: Date.now(),
        ts: new Date().toISOString(),
        name: name.trim(),
        amount,
        type: type || (amount >= 0 ? 'topup' : 'cashout')
      };

      // Add itemName and orderId for order transactions
      if (type === 'order') {
        if (itemName) entry.itemName = itemName;
        if (orderId) entry.orderId = orderId;
        entry.paid = true; // VIP order transactions are always paid
      }

      vipTransactions.unshift(entry);
      vipTransactions = vipTransactions.slice(0, 200);
      localStorage.setItem(VIP_TX_KEY, JSON.stringify(vipTransactions));
      // Keep vip list in sync with recomputed balances after any VIP transaction
      recomputeVipBalances();
      renderVipHistory();
      populateVipMemberSelect();
    }

    function renderVipHistory() {
      const container = document.getElementById('vipHistory');
      if (!container) return;

      if (!vipTransactions.length) {
        container.innerHTML = '<div class="empty-state" style="padding:12px 0;">ChÆ°a cÃ³ giao dá»‹ch VIP</div>';
        return;
      }

      const html = `
    <ul class="mini-list">
      ${vipTransactions.slice(0, 20).map(tx => `
        <li>
          <div>
            <div><strong>${tx.name}</strong> â€¢ ${tx.type === 'cashout' ? 'RÃºt' : 'Náº¡p'}</div>
            <div class="note">${formatDate(tx.ts)}</div>
          </div>
          <div class="${tx.amount >= 0 ? 'amount-positive' : 'amount-negative'}">
            ${tx.amount >= 0 ? '+' : ''}${formatMoney(tx.amount)}
          </div>
        </li>
      `).join('')}
    </ul>
  `;
      container.innerHTML = html;
    }

    // Extract order transactions for a specific VIP member
    function getVipOrderTransactions(vipName) {
      const orderTxs = [];
      const normalizedVipName = vipName.trim().toLowerCase();

      console.log('=== DEBUG getVipOrderTransactions ===');
      console.log('Looking for VIP:', vipName, '(normalized:', normalizedVipName + ')');
      console.log('Total orders in history:', orderHistory.length);

      orderHistory.forEach((order, idx) => {
        // Debug first order structure
        if (idx === 0) {
          console.log('First order structure:', {
            id: order.id,
            ts: order.ts,
            itemName: order.itemName,
            hasDetails: !!order.details,
            detailsIsArray: Array.isArray(order.details),
            detailsLength: order.details?.length
          });
        }

        if (!order.details || !Array.isArray(order.details)) {
          if (idx < 3) console.log(`Order ${idx}: No details array`);
          return;
        }

        // Use order.id as timestamp (that's where it's stored)
        const timestamp = order.id;
        if (!timestamp || isNaN(parseInt(timestamp))) {
          if (idx < 3) console.log(`Order ${idx}: Invalid ID/timestamp`);
          return;
        }

        order.details.forEach((detail, detailIdx) => {
          const detailName = (detail.name || '').trim();
          const normalizedDetailName = detailName.toLowerCase();

          // Debug: log all detail names to see what we have
          if (idx < 3) {
            console.log(`Order ${idx}, Detail ${detailIdx}: name="${detailName}", due=${detail.due}, paid=${detail.paid}`);
          }

          if (normalizedDetailName === normalizedVipName && detail.due) {
            const date = new Date(parseInt(timestamp));
            if (isNaN(date.getTime())) return;

            console.log('âœ… MATCH FOUND:', detailName, 'due:', detail.due);

            orderTxs.push({
              id: timestamp + '_' + detailName,
              ts: date.toISOString(),
              name: vipName,
              amount: -Math.abs(detail.due),
              type: 'order',
              itemName: order.itemName || 'Order',
              paid: detail.paid || false,
              // Do not trust stale isVipPayment; will be recomputed by tx/vip matching + fallback
              isVipPayment: false
            });
          }
        });
      });

      console.log('Total order transactions found:', orderTxs.length);
      console.log('=== END DEBUG ===');

      return orderTxs;
    }

    // Get icon for transaction type
    function getTransactionIcon(type) {
      switch (type) {
        case 'topup': return 'ğŸ’°';
        case 'cashout': return 'ğŸ’¸';
        case 'order': return 'ğŸœ';
        default: return 'ğŸ“';
      }
    }

    // Get label for transaction
    function getTransactionLabel(tx) {
      switch (tx.type) {
        case 'topup': return 'Náº¡p tiá»n';
        case 'cashout': return 'RÃºt tiá»n';
        case 'order': return 'Order mÃ³n Äƒn';
        default: return 'Giao dá»‹ch';
      }
    }

    // VIP Member Transaction History Functions
    function populateVipMemberSelect() {
      const select = document.getElementById('vipMemberSelect');
      if (!select) return;

      // Get unique VIP names from transactions
      const vipNames = new Set();
      vipTransactions.forEach(tx => {
        if (tx.name) vipNames.add(tx.name);
      });

      // Also add VIP names from current VIP list
      const vipArea = document.getElementById('vipArea');
      if (vipArea) {
        const vipMap = parseVip(vipArea.value);
        vipMap.forEach((_, name) => vipNames.add(name));
      }

      // Sort and populate
      const sortedNames = Array.from(vipNames).sort();
      select.innerHTML = '<option value="">-- Chá»n VIP --</option>' +
        sortedNames.map(name => `<option value="${name}">${name}</option>`).join('');
    }
    // Store all transactions globally for filtering
    let currentVipTransactions = [];

    // VIP History Functions
    const DEFAULT_INITIAL_BALANCE = {
      'a Duck': 145,
      'a Dave': 1000
    };

    function saveInitialBalance() {
      const vipName = document.getElementById('vipMemberSelect').value;
      const balance = document.getElementById('vipInitialBalance').value;

      if (!vipName) return;

      // Save to localStorage
      const key = `vipInitialBalance_${vipName}`;
      localStorage.setItem(key, balance || '0');

      // Recalculate history
      showVipMemberHistory();
    }

    function getInitialBalanceForVip(name, options = {}) {
      if (!name) return 0;
      const saved = localStorage.getItem(`vipInitialBalance_${name}`);
      if (saved !== null && saved !== undefined && saved !== '') {
        return Number(saved);
      }
      const def = DEFAULT_INITIAL_BALANCE[name];
      if (options.persistDefault && def !== undefined) {
        localStorage.setItem(`vipInitialBalance_${name}`, def);
      }
      return def || 0;
    }

    function showVipMemberHistory() {
      const select = document.getElementById('vipMemberSelect');
      const container = document.getElementById('vipMemberHistoryContainer');
      const filtersDiv = document.getElementById('vipHistoryFilters');
      if (!select || !container) return;

      const selectedName = select.value;
      if (!selectedName) {
        container.innerHTML = '';
        if (filtersDiv) filtersDiv.style.display = 'none';
        return;
      }

      // Set initial balance input from saved/default
      const initialBalanceInput = document.getElementById('vipInitialBalance');
      const initialBalanceValue = getInitialBalanceForVip(selectedName, { persistDefault: true });
      if (initialBalanceInput) {
        initialBalanceInput.value = initialBalanceValue;
      }

      // Show filters
      if (filtersDiv) filtersDiv.style.display = 'block';

      // Helper to build a dedupe key for order transactions
      const buildOrderKey = (tx) => {
        if (tx.type !== 'order') return null;
        if (tx.orderId) return `id:${tx.orderId}`;
        const tsKey = new Date(tx.ts).getTime();
        return `ts:${tsKey}|amt:${tx.amount}`;
      };

      // Helper to fingerprint an order by item/amount (used to drop legacy duplicates)
      const fingerprintOrder = (tx) => {
        if (tx.type !== 'order') return [];
        const item = (tx.itemName || '').trim().toLowerCase();
        const amount = Math.abs(Number(tx.amount) || 0);
        return [`${item}|${amount}`, `amount|${amount}`];
      };

      // Get VIP transactions (topup/cashout/order)
      const vipTxs = vipTransactions.filter(tx => tx.name === selectedName);

      // Build a set of order keys already recorded as VIP transactions (avoid double counting)
      const vipOrderKeys = new Set();
      const vipOrderFingerprints = new Set();
      vipTxs.forEach(tx => {
        const key = buildOrderKey(tx);
        if (key) vipOrderKeys.add(key);
        fingerprintOrder(tx).forEach(fp => vipOrderFingerprints.add(fp));
      });

      // Get ALL order transactions from order history
      let orderTxs = getVipOrderTransactions(selectedName);

      // Mark orders as VIP-paid if they match a VIP transaction (even if deduped away)
      orderTxs = orderTxs.map(tx => {
        if (tx.type !== 'order') return tx;
        const key = buildOrderKey(tx);
        const fps = fingerprintOrder(tx);
        const isVipPayment = (key && vipOrderKeys.has(key)) || fps.some(fp => vipOrderFingerprints.has(fp)) || !!tx.isVipPayment;
        return { ...tx, isVipPayment };
      });

      // Build fingerprint set from order history (authoritative)
      const orderHistoryFingerprints = new Set();
      orderTxs.forEach(tx => fingerprintOrder(tx).forEach(fp => orderHistoryFingerprints.add(fp)));

      // Merge order history + vipTransactions without duplicating the same order
      const mergedTxs = [];

      // 1) Push order history first (authoritative for orders)
      mergedTxs.push(...orderTxs);

      // 2) Add vipTxs but skip duplicate orders that lack orderId and match history by item/amount
      vipTxs.forEach(tx => {
        if (tx.type === 'order') {
          const key = buildOrderKey(tx);
          const fps = fingerprintOrder(tx);
          if ((key && vipOrderKeys.has(key)) || (fps.some(fp => orderHistoryFingerprints.has(fp)) && !tx.orderId)) return;
        }
        mergedTxs.push(tx);
      });

      // Mark which orders are VIP vs Cash
      const markedTxs = mergedTxs.map(tx => {
        if (tx.type !== 'order') return { ...tx, isVipPayment: !!tx.orderId };
        const key = buildOrderKey(tx);
        const fps = fingerprintOrder(tx);
        const isVipPayment = tx.isVipPayment || (key && vipOrderKeys.has(key)) || fps.some(fp => vipOrderFingerprints.has(fp)) || !!tx.orderId;
        return { ...tx, isVipPayment };
      });

      // Fallback: if order is paid and we still have VIP balance at that time, auto-mark as VIP (when no explicit vip tx exists)
      const fallbackInitialBalance = getInitialBalanceForVip(selectedName, { persistDefault: true });
      const sortedForFallback = [...markedTxs].sort((a, b) => new Date(a.ts) - new Date(b.ts));
      let fallbackBalance = fallbackInitialBalance;
      let allowCredit = fallbackInitialBalance > 0; // chá»‰ cho Ã¢m khi Ä‘Ã£ cÃ³ dÆ°/Ä‘Ã£ náº¡p
      const adjustedTxs = sortedForFallback.map(tx => {
        const copy = { ...tx };
        const impactsVip = (t) => t.type === 'topup' || t.type === 'cashout' || (t.type === 'order' && t.isVipPayment);

        if (copy.type === 'order' && !copy.isVipPayment) {
          const needed = Math.abs(copy.amount || 0);
          if ((fallbackBalance >= needed || allowCredit) && needed > 0) {
            copy.isVipPayment = true;
            copy.paid = true;
          }
        }

        if (impactsVip(copy)) {
          fallbackBalance += copy.amount;
          if (copy.type === 'topup' && copy.amount > 0) {
            allowCredit = true;
          }
        }

        return copy;
      });

      // Combine all transactions for display (latest first)
      const allTxs = [...adjustedTxs]
        .sort((a, b) => new Date(b.ts).getTime() - new Date(a.ts).getTime());

      if (allTxs.length === 0) {
        container.innerHTML = '<div class="empty-state" style="padding: 12px 0;">ChÆ°a cÃ³ giao dá»‹ch nÃ o</div>';
        return;
      }

      // Initial balance (user can set manually)
      const initialBalance = getInitialBalanceForVip(selectedName, { persistDefault: true });

      // Calculate running balance including only VIP-impacting transactions
      let runningBalance = initialBalance;
      const sortedOldestFirst = [...allTxs].sort((a, b) =>
        new Date(a.ts).getTime() - new Date(b.ts).getTime()
      );

      // Calculate balance AFTER each transaction (chronological order)
      const txsWithBalance = sortedOldestFirst.map(tx => {
        const impactsVip = tx.type === 'topup' || tx.type === 'cashout' || (tx.type === 'order' && tx.isVipPayment);
        if (impactsVip) {
          runningBalance += tx.amount;
          return { ...tx, balance: runningBalance };
        }
        // Cash orders should not change VIP balance; show 0 for their balance column
        return { ...tx, balance: 0 };
      });

      // Store for filtering
      currentVipTransactions = txsWithBalance;

      // Render with current filters
      renderVipHistoryTable(selectedName, runningBalance, txsWithBalance);
    }

    function renderVipHistoryTable(selectedName, currentBalance, transactions) {
      const container = document.getElementById('vipMemberHistoryContainer');
      if (!container) return;

      // Count transaction types
      const topupCount = transactions.filter(tx => tx.type === 'topup').length;
      const cashoutCount = transactions.filter(tx => tx.type === 'cashout').length;
      const orderCount = transactions.filter(tx => tx.type === 'order').length;

      // Create a Set of order IDs that have actual VIP transactions
      const vipOrderIds = new Set();
      vipTransactions.forEach(tx => {
        if (tx.type === 'order' && tx.name === selectedName && tx.orderId) {
          vipOrderIds.add(tx.orderId);
        }
      });

      // Compact date format function
      const compactDate = (dateStr) => {
        const d = new Date(dateStr);
        const day = String(d.getDate()).padStart(2, '0');
        const month = String(d.getMonth() + 1).padStart(2, '0');
        const year = d.getFullYear();
        const hours = String(d.getHours()).padStart(2, '0');
        const minutes = String(d.getMinutes()).padStart(2, '0');
        return `${day}/${month}/${year} ${hours}:${minutes}`;
      };

      // Render compact table
      const html = `
        <div style="margin-top: 16px;">
          <!-- Header with summary -->
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; padding: 12px 16px; background: linear-gradient(135deg, rgba(99,102,241,0.1), rgba(168,85,247,0.1)); border-radius: 12px; border: 1px solid rgba(99,102,241,0.2);">
            <div>
              <div style="font-size: 14px; color: var(--text-muted); margin-bottom: 2px;">VIP Member</div>
              <div style="font-size: 18px; font-weight: 600; color: var(--text-primary);">${selectedName}</div>
            </div>
            <div style="text-align: right;">
              <div style="font-size: 14px; color: var(--text-muted); margin-bottom: 2px;">Sá»‘ dÆ° hiá»‡n táº¡i</div>
              <div style="font-size: 22px; font-weight: 700; color: ${currentBalance >= 0 ? 'var(--accent-green)' : 'var(--accent-red)'};">
                ${formatMoney(currentBalance)}
              </div>
            </div>
          </div>

          <!-- Transaction table -->
          <div style="border-radius: 12px; overflow: hidden; border: 1px solid rgba(255,255,255,0.08);">
            <div style="max-height: 60vh; overflow-y: auto; overflow-x: auto; background: var(--glass-bg);">
              <table style="width: 100%; min-width: 700px; border-collapse: collapse; font-size: 13px;">
                <thead style="position: sticky; top: 0; background: rgba(30,30,50,0.95); backdrop-filter: blur(10px); z-index: 1;">
                  <tr>
                    <th style="padding: 10px 12px; text-align: left; font-weight: 600; color: var(--text-muted); border-bottom: 2px solid rgba(255,255,255,0.1); white-space: nowrap;">ğŸ“… NgÃ y giá»</th>
                    <th style="padding: 10px 12px; text-align: left; font-weight: 600; color: var(--text-muted); border-bottom: 2px solid rgba(255,255,255,0.1); white-space: nowrap;">Loáº¡i</th>
                    <th style="padding: 10px 12px; text-align: center; font-weight: 600; color: var(--text-muted); border-bottom: 2px solid rgba(255,255,255,0.1); white-space: nowrap;">ğŸ’³ PT</th>
                    <th style="padding: 10px 12px; text-align: right; font-weight: 600; color: var(--text-muted); border-bottom: 2px solid rgba(255,255,255,0.1); white-space: nowrap;">Sá»‘ tiá»n</th>
                    <th style="padding: 10px 12px; text-align: left; font-weight: 600; color: var(--text-muted); border-bottom: 2px solid rgba(255,255,255,0.1);">Chi tiáº¿t</th>
                    <th style="padding: 10px 12px; text-align: right; font-weight: 600; color: var(--text-muted); border-bottom: 2px solid rgba(255,255,255,0.1); white-space: nowrap;">Sá»‘ dÆ°</th>
                  </tr>
                </thead>
                <tbody>
                  ${transactions.map((tx, idx) => {
        const isEven = idx % 2 === 0;
        const bgColor = isEven ? 'rgba(255,255,255,0.02)' : 'transparent';
        const typeLabel = tx.type === 'topup' ? 'ğŸ’° Náº¡p' : tx.type === 'cashout' ? 'ğŸ’¸ RÃºt' : 'ğŸœ Order';

        // Check if this order has actual VIP transaction
        let paymentMethod = '-';
        if (tx.type === 'order') {
          if (!tx.paid) {
            paymentMethod = '<span style="background: linear-gradient(135deg, #f59e0b, #fbbf24); color: white; padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 600;">â³ Pending</span>';
          } else if (tx.isVipPayment) {
            paymentMethod = '<span style="background: linear-gradient(135deg, #10b981, #34d399); color: white; padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 600;">VIP</span>';
          } else {
            paymentMethod = '<span style="background: linear-gradient(135deg, #6b7280, #9ca3af); color: white; padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 600;">Cash</span>';
          }
        }

        const amountColor = tx.amount >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';
        const balanceColor = tx.balance >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';

        return `
                      <tr style="background: ${bgColor}; transition: background 0.2s;" onmouseover="this.style.background='rgba(99,102,241,0.08)'" onmouseout="this.style.background='${bgColor}'">
                        <td style="padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,0.05); color: var(--text-secondary); white-space: nowrap;">${compactDate(tx.ts)}</td>
                        <td style="padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,0.05); white-space: nowrap;">${typeLabel}</td>
                        <td style="padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,0.05); text-align: center; white-space: nowrap;">${paymentMethod}</td>
                        <td style="padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,0.05); text-align: right; font-weight: 600; color: ${amountColor}; white-space: nowrap;">
                          ${tx.amount >= 0 ? '+' : ''}${formatMoney(tx.amount)}
                        </td>
                        <td style="padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,0.05); color: var(--text-secondary);">
                          ${tx.type === 'order' ? `${tx.itemName || 'Order'} ${tx.paid ? 'âœ…' : 'â³'}` : '-'}
                        </td>
                        <td style="padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,0.05); text-align: right; font-weight: 600; color: ${balanceColor}; white-space: nowrap;">
                          ${formatMoney(tx.balance)}
                        </td>
                      </tr>
                    `;
      }).join('')}
                </tbody>
              </table>
            </div>
          </div>

          <!-- Summary footer -->
          <div style="margin-top: 12px; padding: 12px 16px; background: rgba(255,255,255,0.03); border-radius: 12px; border: 1px solid rgba(255,255,255,0.08);">
            <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 8px;">
              <div style="font-size: 13px; color: var(--text-muted);">
                <strong style="color: var(--text-primary);">Tá»•ng: ${transactions.length}</strong> giao dá»‹ch
              </div>
              <div style="font-size: 13px; color: var(--text-muted); display: flex; gap: 16px;">
                <span>ğŸ’° Náº¡p: <strong style="color: var(--accent-green);">${topupCount}</strong></span>
                <span>ğŸ’¸ RÃºt: <strong style="color: var(--accent-yellow);">${cashoutCount}</strong></span>
                <span>ğŸœ Order: <strong style="color: var(--accent-blue);">${orderCount}</strong></span>
              </div>
            </div>
          </div>
        </div>
      `;

      container.innerHTML = html;
    }

    // Apply filters to VIP history
    function applyVipHistoryFilters() {
      if (currentVipTransactions.length === 0) return;

      const select = document.getElementById('vipMemberSelect');
      const vipArea = document.getElementById('vipArea');
      const selectedName = select ? select.value : '';
      const initialBalance = getInitialBalanceForVip(selectedName, { persistDefault: true });

      // Get filter values
      const dateFrom = document.getElementById('filterDateFrom')?.value;
      const dateTo = document.getElementById('filterDateTo')?.value;
      const txType = document.getElementById('filterTxType')?.value || 'all';
      const paymentStatus = document.getElementById('filterPaymentStatus')?.value || 'all';

      // Apply filters
      let filtered = [...currentVipTransactions];

      // Date range filter
      if (dateFrom) {
        const fromDate = new Date(dateFrom);
        fromDate.setHours(0, 0, 0, 0);
        filtered = filtered.filter(tx => new Date(tx.ts) >= fromDate);
      }
      if (dateTo) {
        const toDate = new Date(dateTo);
        toDate.setHours(23, 59, 59, 999);
        filtered = filtered.filter(tx => new Date(tx.ts) <= toDate);
      }

      // Transaction type filter
      if (txType !== 'all') {
        filtered = filtered.filter(tx => tx.type === txType);
      }

      // Payment status filter (only for orders)
      if (paymentStatus !== 'all') {
        filtered = filtered.filter(tx => {
          if (tx.type !== 'order') return true; // Keep non-order transactions
          return paymentStatus === 'paid' ? tx.paid : !tx.paid;
        });
      }

      // Update result count
      const countSpan = document.getElementById('filterResultCount');
      if (countSpan) {
        countSpan.textContent = `Hiá»ƒn thá»‹ ${filtered.length}/${currentVipTransactions.length} giao dá»‹ch`;
      }

      // Recalculate running balance for filtered list (chronological)
      let runningBalance = initialBalance;
      const recalculated = [...filtered]
        .sort((a, b) => new Date(a.ts) - new Date(b.ts))
        .map(tx => {
          const impactsVip = tx.type === 'topup' || tx.type === 'cashout' || (tx.type === 'order' && tx.isVipPayment);
          if (impactsVip) {
            runningBalance += tx.amount;
            return { ...tx, balance: runningBalance };
          }
          return { ...tx, balance: 0 };
        });

      // Render filtered results (use final runningBalance for header)
      renderVipHistoryTable(selectedName, runningBalance, recalculated);
    }

    // Clear all filters
    function clearVipHistoryFilters() {
      document.getElementById('filterDateFrom').value = '';
      document.getElementById('filterDateTo').value = '';
      document.getElementById('filterTxType').value = 'all';
      document.getElementById('filterPaymentStatus').value = 'all';

      const countSpan = document.getElementById('filterResultCount');
      if (countSpan) countSpan.textContent = '';

      // Re-render with all transactions
      const select = document.getElementById('vipMemberSelect');
      const vipArea = document.getElementById('vipArea');
      const selectedName = select ? select.value : '';
      const currentBalance = vipArea ? (parseVip(vipArea.value).get(selectedName) || 0) : 0;

      renderVipHistoryTable(selectedName, currentBalance, currentVipTransactions);
    }

    // Export VIP history to CSV
    function exportVipHistoryToCSV() {
      const select = document.getElementById('vipMemberSelect');
      if (!select || !select.value) {
        alert('âš ï¸ Vui lÃ²ng chá»n VIP member trÆ°á»›c khi xuáº¥t CSV');
        return;
      }

      const selectedName = select.value;

      // Get currently displayed transactions (respecting filters)
      const vipArea = document.getElementById('vipArea');
      const currentBalance = vipArea ? (parseVip(vipArea.value).get(selectedName) || 0) : 0;

      // Get filter values to determine which transactions to export
      const dateFrom = document.getElementById('filterDateFrom')?.value;
      const dateTo = document.getElementById('filterDateTo')?.value;
      const txType = document.getElementById('filterTxType')?.value || 'all';
      const paymentStatus = document.getElementById('filterPaymentStatus')?.value || 'all';

      // Apply same filters as display
      let transactions = [...currentVipTransactions];

      if (dateFrom) {
        const fromDate = new Date(dateFrom);
        fromDate.setHours(0, 0, 0, 0);
        transactions = transactions.filter(tx => new Date(tx.ts) >= fromDate);
      }
      if (dateTo) {
        const toDate = new Date(dateTo);
        toDate.setHours(23, 59, 59, 999);
        transactions = transactions.filter(tx => new Date(tx.ts) <= toDate);
      }
      if (txType !== 'all') {
        transactions = transactions.filter(tx => tx.type === txType);
      }
      if (paymentStatus !== 'all') {
        transactions = transactions.filter(tx => {
          if (tx.type !== 'order') return true;
          return paymentStatus === 'paid' ? tx.paid : !tx.paid;
        });
      }

      if (transactions.length === 0) {
        alert('âš ï¸ KhÃ´ng cÃ³ giao dá»‹ch nÃ o Ä‘á»ƒ xuáº¥t');
        return;
      }

      // Format date for CSV
      const formatDateCSV = (dateStr) => {
        const d = new Date(dateStr);
        const day = String(d.getDate()).padStart(2, '0');
        const month = String(d.getMonth() + 1).padStart(2, '0');
        const year = d.getFullYear();
        const hours = String(d.getHours()).padStart(2, '0');
        const minutes = String(d.getMinutes()).padStart(2, '0');
        return `${day}/${month}/${year} ${hours}:${minutes}`;
      };

      // Get transaction type label
      const getTypeLabel = (type) => {
        if (type === 'topup') return 'Náº¡p tiá»n';
        if (type === 'cashout') return 'RÃºt tiá»n';
        if (type === 'order') return 'Order';
        return 'Giao dá»‹ch';
      };

      // Format amount for CSV (remove 'Ä‘' suffix)
      const formatAmountCSV = (amount) => {
        return amount.toFixed(0);
      };

      // Build CSV content
      let csv = [];

      // Add UTF-8 BOM for Excel compatibility with Vietnamese characters
      csv.push('\uFEFF');

      // Add header info
      csv.push(`VIP Member: ${selectedName}\n`);
      csv.push(`Sá»‘ dÆ° hiá»‡n táº¡i: ${formatAmountCSV(currentBalance)}Ä‘\n`);
      csv.push(`NgÃ y xuáº¥t: ${formatDateCSV(new Date().toISOString())}\n`);
      csv.push(`Tá»•ng sá»‘ giao dá»‹ch: ${transactions.length}\n`);
      csv.push('\n');

      // Add table header
      csv.push('NgÃ y giá»,Loáº¡i,Sá»‘ tiá»n (Ä‘),Chi tiáº¿t,Sá»‘ dÆ° (Ä‘)\n');

      // Add transaction rows
      transactions.forEach(tx => {
        const date = formatDateCSV(tx.ts);
        const type = getTypeLabel(tx.type);
        const amount = formatAmountCSV(tx.amount);
        const detail = tx.type === 'order'
          ? `${tx.itemName} ${tx.paid ? '[ÄÃ£ tráº£]' : '[ChÆ°a tráº£]'}`
          : '-';
        const balance = formatAmountCSV(tx.balance);

        // Escape commas and quotes in detail field
        const escapedDetail = detail.replace(/"/g, '""');
        const detailField = detail.includes(',') ? `"${escapedDetail}"` : detail;

        csv.push(`${date},${type},${amount},${detailField},${balance}\n`);
      });

      // Add summary footer
      csv.push('\n');
      const topupCount = transactions.filter(tx => tx.type === 'topup').length;
      const cashoutCount = transactions.filter(tx => tx.type === 'cashout').length;
      const orderCount = transactions.filter(tx => tx.type === 'order').length;
      csv.push(`Tá»•ng há»£p:,Náº¡p: ${topupCount} láº§n,RÃºt: ${cashoutCount} láº§n,Order: ${orderCount} láº§n,\n`);

      // Create blob and download
      const csvContent = csv.join('');
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');

      // Generate filename with date
      const now = new Date();
      const dateStr = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}`;
      const filename = `vip_transactions_${selectedName.replace(/\s+/g, '_')}_${dateStr}.csv`;

      link.href = URL.createObjectURL(blob);
      link.download = filename;
      link.style.display = 'none';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);

      // Show success message
      const filterCount = document.getElementById('filterResultCount');
      if (filterCount) {
        const originalText = filterCount.textContent;
        filterCount.innerHTML = `<span style="color: var(--accent-green);">âœ… ÄÃ£ xuáº¥t ${transactions.length} giao dá»‹ch</span>`;
        setTimeout(() => {
          filterCount.textContent = originalText;
        }, 3000);
      }
    }

    // ========== Global Search Functions ==========

    let searchTimeout = null;

    function handleGlobalSearch(query) {
      const resultsContainer = document.getElementById('searchResults');
      const clearBtn = document.querySelector('.search-clear');

      // Show/hide clear button
      clearBtn.style.display = query ? 'block' : 'none';

      if (!query || query.trim().length < 2) {
        resultsContainer.classList.remove('show');
        return;
      }

      // Debounce search
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(() => {
        const results = searchAllData(query.trim());
        renderSearchResults(results);
      }, 200);
    }

    function searchAllData(query) {
      const lowerQuery = query.toLowerCase();
      const results = {
        vips: [],
        orders: [],
        items: []
      };

      // Search VIPs
      const vipArea = document.getElementById('vipArea');
      if (vipArea) {
        const vipMap = parseVip(vipArea.value);
        vipMap.forEach((balance, name) => {
          if (name.toLowerCase().includes(lowerQuery)) {
            results.vips.push({ name, balance });
          }
        });
      }

      // Search Orders
      orderHistory.forEach(order => {
        const itemMatch = order.itemName && order.itemName.toLowerCase().includes(lowerQuery);
        const dateStr = formatDate(order.date || order.id);
        const dateMatch = dateStr.toLowerCase().includes(lowerQuery);

        // Search in order details (VIP names)
        let detailMatch = false;
        if (order.details && Array.isArray(order.details)) {
          detailMatch = order.details.some(d =>
            d.name && d.name.toLowerCase().includes(lowerQuery)
          );
        }

        if (itemMatch || dateMatch || detailMatch) {
          results.orders.push(order);
        }
      });

      // Search unique item names
      const itemCounts = new Map();
      orderHistory.forEach(order => {
        if (order.itemName) {
          const itemLower = order.itemName.toLowerCase();
          if (itemLower.includes(lowerQuery)) {
            itemCounts.set(order.itemName, (itemCounts.get(order.itemName) || 0) + 1);
          }
        }
      });

      itemCounts.forEach((count, item) => {
        results.items.push({ name: item, count });
      });

      // Limit results
      results.vips = results.vips.slice(0, 5);
      results.orders = results.orders.slice(0, 5);
      results.items = results.items.slice(0, 5);

      return results;
    }

    function renderSearchResults(results) {
      const container = document.getElementById('searchResults');
      const hasResults = results.vips.length > 0 || results.orders.length > 0 || results.items.length > 0;

      if (!hasResults) {
        container.innerHTML = '<div class="search-no-results">âŒ KhÃ´ng tÃ¬m tháº¥y káº¿t quáº£</div>';
        container.classList.add('show');
        return;
      }

      let html = '';

      // VIP Results
      if (results.vips.length > 0) {
        html += '<div class="search-result-section">';
        html += '<div class="search-section-title">ğŸ‘¥ VIP Members</div>';
        results.vips.forEach(vip => {
          const balanceClass = vip.balance >= 0 ? 'positive' : 'negative';
          html += `
            <div class="search-result-item" onclick="goToVip('${vip.name}')">
              <span class="search-result-icon">ğŸ‘¤</span>
              <div class="search-result-content">
                <div class="search-result-title">${vip.name}</div>
                <div class="search-result-subtitle">
                  <span class="balance-badge ${balanceClass}">${formatMoney(vip.balance)}</span>
                </div>
              </div>
            </div>
          `;
        });
        html += '</div>';
      }

      // Order Results
      if (results.orders.length > 0) {
        html += '<div class="search-result-section">';
        html += '<div class="search-section-title">ğŸ“‹ Orders</div>';
        results.orders.forEach(order => {
          const dateStr = formatDate(order.date || order.id);
          html += `
            <div class="search-result-item" onclick="goToOrder(${order.id})">
              <span class="search-result-icon">ğŸœ</span>
              <div class="search-result-content">
                <div class="search-result-title">${order.itemName}</div>
                <div class="search-result-subtitle">${dateStr}</div>
              </div>
            </div>
          `;
        });
        html += '</div>';
      }

      // Item Results
      if (results.items.length > 0) {
        html += '<div class="search-result-section">';
        html += '<div class="search-section-title">ğŸ½ï¸ Items</div>';
        results.items.forEach(item => {
          html += `
            <div class="search-result-item" onclick="searchOrdersByItem('${item.name}')">
              <span class="search-result-icon">ğŸ”</span>
              <div class="search-result-content">
                <div class="search-result-title">${item.name}</div>
                <div class="search-result-subtitle">
                  <span class="count-badge">${item.count} Ä‘Æ¡n</span>
                </div>
              </div>
            </div>
          `;
        });
        html += '</div>';
      }

      container.innerHTML = html;
      container.classList.add('show');
    }

    function clearGlobalSearch() {
      document.getElementById('globalSearch').value = '';
      document.getElementById('searchResults').classList.remove('show');
      document.querySelector('.search-clear').style.display = 'none';
    }

    function goToVip(vipName) {
      clearGlobalSearch();
      switchTab(null, 'debt');

      // Select VIP in dropdown
      setTimeout(() => {
        const select = document.getElementById('vipMemberSelect');
        if (select) {
          select.value = vipName;
          showVipMemberHistory();
          select.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
      }, 100);
    }

    function goToOrder(orderId) {
      clearGlobalSearch();
      switchTab(null, 'history');

      // Highlight and scroll to order
      setTimeout(() => {
        viewOrderDetails(orderId);
      }, 100);
    }

    function searchOrdersByItem(itemName) {
      clearGlobalSearch();
      switchTab(null, 'history');

      // TODO: Could add filter functionality here
      console.log('Search orders for item:', itemName);
    }

    // Keyboard shortcut: Ctrl+K to focus search
    document.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
        e.preventDefault();
        document.getElementById('globalSearch').focus();
      }

      // ESC to close search results
      if (e.key === 'Escape') {
        clearGlobalSearch();
      }
    });

    // ========== GitHub Settings & Main Functions ==========

    /**
     * Load user's GitHub repositories and populate dropdown
     */
    async function loadGithubRepos() {
      const token = document.getElementById('githubToken').value.trim();
      const repoSelect = document.getElementById('githubRepo');
      const statusDiv = document.getElementById('repoLoadingStatus');

      if (!token) {
        // No token, reset dropdown
        repoSelect.innerHTML = '<option value="">-- Nháº­p token trÆ°á»›c --</option>';
        return;
      }

      try {
        statusDiv.style.display = 'block';
        statusDiv.textContent = 'â³ Loading repositories...';

        // Temporarily save token to localStorage for API call
        // (it will be saved permanently when user clicks "LÆ°u cÃ i Ä‘áº·t")
        localStorage.setItem(GITHUB_TOKEN_KEY, token);

        // Fetch user's repos
        const repos = await githubApiRequest('/user/repos?per_page=100&sort=updated');

        if (!repos || repos.length === 0) {
          repoSelect.innerHTML = '<option value="">-- No repositories found --</option>';
          statusDiv.textContent = 'â„¹ï¸ No repositories found';
          return;
        }

        // Populate dropdown with repos
        repoSelect.innerHTML = '<option value="">-- Select repository --</option>';

        repos.forEach(repo => {
          const option = document.createElement('option');
          option.value = repo.full_name; // e.g., "vuhoanganh/OrderHelper"
          option.textContent = `${repo.full_name} ${repo.private ? 'ğŸ”’' : ''}`;
          repoSelect.appendChild(option);
        });

        // Auto-select if only one repo or if OrderHelper exists
        const orderHelperRepo = repos.find(r => r.name.toLowerCase().includes('orderhelper'));
        if (orderHelperRepo) {
          repoSelect.value = orderHelperRepo.full_name;
        } else if (repos.length === 1) {
          repoSelect.value = repos[0].full_name;
        }

        statusDiv.textContent = `âœ… Loaded ${repos.length} repositories`;
        setTimeout(() => { statusDiv.style.display = 'none'; }, 3000);

      } catch (err) {
        console.error('Load repos error:', err);
        repoSelect.innerHTML = '<option value="">-- Error loading repos --</option>';
        statusDiv.textContent = `âŒ ${err.message}`;
        statusDiv.style.color = 'var(--accent-red)';
      }
    }

    /**
     * Load branches for selected repository
     */
    async function loadGithubBranches() {
      const repo = document.getElementById('githubRepo').value.trim();
      const branchSelect = document.getElementById('githubBranch');
      const statusDiv = document.getElementById('branchLoadingStatus');

      if (!repo) {
        // No repo selected, reset to default
        branchSelect.innerHTML = '<option value="main">main</option>';
        return;
      }

      try {
        statusDiv.style.display = 'block';
        statusDiv.textContent = 'â³ Loading branches...';

        const [owner, repoName] = repo.split('/');

        // Fetch repo branches
        const branches = await githubApiRequest(`/repos/${owner}/${repoName}/branches`);

        if (!branches || branches.length === 0) {
          branchSelect.innerHTML = '<option value="main">main</option>';
          statusDiv.textContent = 'â„¹ï¸ No branches found, using default: main';
          setTimeout(() => { statusDiv.style.display = 'none'; }, 3000);
          return;
        }

        // Populate dropdown with branches
        branchSelect.innerHTML = '';

        branches.forEach(branch => {
          const option = document.createElement('option');
          option.value = branch.name;
          option.textContent = branch.name;
          branchSelect.appendChild(option);
        });

        // Auto-select main or master if exists
        const mainBranch = branches.find(b => b.name === 'main');
        const masterBranch = branches.find(b => b.name === 'master');

        if (mainBranch) {
          branchSelect.value = 'main';
        } else if (masterBranch) {
          branchSelect.value = 'master';
        } else {
          // Select first branch
          branchSelect.value = branches[0].name;
        }

        statusDiv.textContent = `âœ… Loaded ${branches.length} branches`;
        setTimeout(() => { statusDiv.style.display = 'none'; }, 2000);

      } catch (err) {
        console.error('Load branches error:', err);
        branchSelect.innerHTML = '<option value="main">main</option>';
        statusDiv.textContent = `âŒ ${err.message}`;
        statusDiv.style.color = 'var(--accent-red)';
        setTimeout(() => {
          statusDiv.style.display = 'none';
          statusDiv.style.color = 'var(--accent-blue)';
        }, 5000);
      }
    }

    function saveGithubSettings() {
      const token = document.getElementById('githubToken').value.trim();
      const repo = document.getElementById('githubRepo').value.trim();
      const branch = document.getElementById('githubBranch').value.trim();
      const autoBackupEnabled = document.getElementById('githubAutoBackupEnabled').checked;
      const interval = parseInt(document.getElementById('githubBackupInterval').value) || 30;

      if (!token || !repo) {
        alert('âš ï¸ Vui lÃ²ng nháº­p GitHub Token vÃ  Repository!');
        return;
      }

      // Validate repo format
      if (!repo.includes('/')) {
        alert('âš ï¸ Repository pháº£i cÃ³ format: owner/repo (vÃ­ dá»¥: vuhoanganh/OrderHelper)');
        return;
      }

      // Save to localStorage
      localStorage.setItem(GITHUB_TOKEN_KEY, token);
      localStorage.setItem(GITHUB_REPO_KEY, repo);
      localStorage.setItem(GITHUB_BRANCH_KEY, branch || 'main');
      localStorage.setItem(GITHUB_AUTO_BACKUP_ENABLED_KEY, autoBackupEnabled);
      localStorage.setItem(GITHUB_BACKUP_INTERVAL_KEY, interval);

      addBackupLog('âœ… ÄÃ£ lÆ°u cÃ i Ä‘áº·t GitHub');
      showBackupStatus('âœ… ÄÃ£ lÆ°u cÃ i Ä‘áº·t thÃ nh cÃ´ng!', 'success');

      // Restart auto-backup if enabled
      if (autoBackupEnabled) {
        initGithubAutoBackup();
        addBackupLog(`ğŸ”„ ÄÃ£ báº­t auto-backup (má»—i ${interval} phÃºt)`);
      } else {
        if (githubAutoBackupInterval) {
          clearInterval(githubAutoBackupInterval);
          githubAutoBackupInterval = null;
          addBackupLog('â¸ï¸ ÄÃ£ táº¯t auto-backup');
        }
      }

      alert('âœ… ÄÃ£ lÆ°u cÃ i Ä‘áº·t GitHub!');
    }

    function loadGithubSettings() {
      const token = localStorage.getItem(GITHUB_TOKEN_KEY) || '';
      const repo = localStorage.getItem(GITHUB_REPO_KEY) || '';
      const branch = localStorage.getItem(GITHUB_BRANCH_KEY) || 'main';
      const autoBackupEnabled = localStorage.getItem(GITHUB_AUTO_BACKUP_ENABLED_KEY) === 'true';
      const interval = parseInt(localStorage.getItem(GITHUB_BACKUP_INTERVAL_KEY)) || 30;

      document.getElementById('githubToken').value = token;
      document.getElementById('githubRepo').value = repo;
      document.getElementById('githubBranch').value = branch;
      document.getElementById('githubAutoBackupEnabled').checked = autoBackupEnabled;
      document.getElementById('githubBackupInterval').value = interval;

      // Update last backup display
      updateBackupStatusDisplay();

      // Start auto-backup if enabled
      if (autoBackupEnabled && token && repo) {
        initGithubAutoBackup();
      }
    }

    function updateBackupStatusDisplay() {
      const lastBackupTime = localStorage.getItem(GITHUB_LAST_BACKUP_KEY);
      const lastCommitSha = localStorage.getItem(GITHUB_LAST_COMMIT_SHA_KEY);

      const timeElem = document.getElementById('lastBackupTime');
      const commitElem = document.getElementById('lastBackupCommit');
      const statusElem = document.getElementById('backupStatusIndicator');
      const detailElem = document.getElementById('backupStatusDetail');

      if (timeElem) {
        if (lastBackupTime) {
          const date = new Date(parseInt(lastBackupTime));
          timeElem.textContent = formatDate(date);
        } else {
          timeElem.textContent = 'ChÆ°a backup';
        }
      }

      if (commitElem) {
        if (lastCommitSha) {
          commitElem.textContent = `Commit: ${lastCommitSha.substring(0, 7)}`;
        } else {
          commitElem.textContent = '--';
        }
      }

      if (statusElem && detailElem) {
        const autoBackupEnabled = localStorage.getItem(GITHUB_AUTO_BACKUP_ENABLED_KEY) === 'true';
        if (autoBackupEnabled) {
          statusElem.textContent = 'ğŸŸ¢ Active';
          const interval = parseInt(localStorage.getItem(GITHUB_BACKUP_INTERVAL_KEY)) || 30;
          detailElem.textContent = `Auto-backup: ${interval} phÃºt`;
        } else {
          statusElem.textContent = 'âšª Inactive';
          detailElem.textContent = 'Auto-backup táº¯t';
        }
      }
    }

    function downloadBackup() {
      try {
        // Collect all data from localStorage
        const backup = {
          version: "1.0",
          timestamp: new Date().toISOString(),
          backupTime: Date.now(),
          data: {
            orderHistory: JSON.parse(localStorage.getItem('orderHistory') || '[]'),
            vipTransactions: JSON.parse(localStorage.getItem('vipTransactions') || '[]'),
            vipList: localStorage.getItem('vipList') || ''
          },
          metadata: {
            orderCount: JSON.parse(localStorage.getItem('orderHistory') || '[]').length,
            transactionCount: JSON.parse(localStorage.getItem('vipTransactions') || '[]').length,
            exportedBy: 'Order Helper Pro',
            exportDate: new Date().toLocaleString('vi-VN', { timeZone: 'Asia/Ho_Chi_Minh' })
          }
        };

        // Create blob and download
        const blob = new Blob([JSON.stringify(backup, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        const now = new Date();
        const datePart = now.toLocaleDateString('en-GB').replace(/\//g, '-');
        const timePart = now.toLocaleTimeString('en-GB', { hour12: false }).replace(/:/g, '');
        a.href = url;
        a.download = `backup-${datePart}-${timePart}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        alert('âœ… ÄÃ£ táº£i xuá»‘ng file backup!');
      } catch (err) {
        alert('âŒ Lá»—i khi táº¡o backup: ' + err.message);
        console.error(err);
      }
    }

    function restoreFromFile() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';

      input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        try {
          const text = await file.text();
          const backup = JSON.parse(text);

          if (!backup.data || !backup.data.orderHistory || !backup.data.vipTransactions || !backup.data.vipList) {
            alert('âŒ File backup khÃ´ng há»£p lá»‡!');
            return;
          }

          const confirmMsg = `Restore tá»«:\n${file.name}\n\n${backup.data.orderHistory.length} orders\n${backup.data.vipTransactions.length} transactions\n\nâš ï¸ Dá»¯ liá»‡u hiá»‡n táº¡i sáº½ bá»‹ ghi Ä‘Ã¨!`;
          if (!confirm(confirmMsg)) return;

          localStorage.setItem('orderHistory', JSON.stringify(backup.data.orderHistory));
          localStorage.setItem('vipTransactions', JSON.stringify(backup.data.vipTransactions));
          localStorage.setItem('vipList', backup.data.vipList);

          alert('âœ… Restore thÃ nh cÃ´ng!');
          setTimeout(() => location.reload(), 1000);
        } catch (err) {
          alert('âŒ Lá»—i: ' + err.message);
        }
      };

      input.click();
    }

    async function backupToGithub() {
      try {
        addBackupLog('ğŸš€ Báº¯t Ä‘áº§u backup...');
        showBackupStatus('â³ Äang backup lÃªn GitHub...', 'info');

        const repo = localStorage.getItem(GITHUB_REPO_KEY);
        const branch = localStorage.getItem(GITHUB_BRANCH_KEY) || 'main';

        if (!repo) {
          throw new Error('ChÆ°a cÃ i Ä‘áº·t repository');
        }

        const [owner, repoName] = repo.split('/');
        if (!owner || !repoName) {
          throw new Error('Repository format khÃ´ng há»£p lá»‡');
        }

        const timestamp = new Date().toISOString();
        const now = new Date();

        // Generate filename like: backup-13-12-2025-190912.json
        const day = String(now.getDate()).padStart(2, '0');
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const year = now.getFullYear();
        const hours = String(now.getHours()).padStart(2, '0');
        const minutes = String(now.getMinutes()).padStart(2, '0');
        const seconds = String(now.getSeconds()).padStart(2, '0');
        const versionedFilename = `backup-${day}-${month}-${year}-${hours}${minutes}${seconds}.json`;

        // Prepare combined backup data
        const backupData = {
          version: '1.0',
          timestamp,
          backupTime: Date.now(),
          data: {
            orderHistory: orderHistory,
            vipList: localStorage.getItem('vipList') || '',
            vipTransactions: vipTransactions
          },
          metadata: {
            orderCount: orderHistory.length,
            transactionCount: vipTransactions.length,
            exportedBy: 'Order Helper Pro',
            exportDate: `${hours}:${minutes}:${seconds} ${day}/${month}/${year}`
          }
        };

        const backupJSON = JSON.stringify(backupData, null, 2);

        // 1. Upload latest file (for sync)
        addBackupLog('ğŸ“¤ Uploading kitchen_backup.json (latest)...');
        const latestFile = await getGithubFile(owner, repoName, 'kitchen_backup.json', branch);
        await createOrUpdateGithubFile(
          owner,
          repoName,
          'kitchen_backup.json',
          backupJSON,
          `Backup data - ${timestamp}`,
          latestFile?.sha
        );
        addBackupLog('âœ… Latest file uploaded');

        // 2. Upload versioned file (for history)
        addBackupLog(`ğŸ“¤ Uploading DB/${versionedFilename} (history)...`);
        const versionedPath = `DB/${versionedFilename}`;
        const versionedFile = await getGithubFile(owner, repoName, versionedPath, branch);
        const result = await createOrUpdateGithubFile(
          owner,
          repoName,
          versionedPath,
          backupJSON,
          `Versioned backup - ${timestamp}`,
          versionedFile?.sha
        );
        addBackupLog('âœ… Versioned file uploaded');

        // Save backup info
        localStorage.setItem(GITHUB_LAST_BACKUP_KEY, Date.now());
        if (result?.commit?.sha) {
          localStorage.setItem(GITHUB_LAST_COMMIT_SHA_KEY, result.commit.sha);
        }

        updateBackupStatusDisplay();
        addBackupLog(`âœ… Hybrid backup complete!`);
        addBackupLog(`   Latest: kitchen_backup.json`);
        addBackupLog(`   History: DB/${versionedFilename}`);
        addBackupLog(`   Data: ${orderHistory.length} orders, ${vipTransactions.length} VIP transactions`);
        showBackupStatus('âœ… Backup thÃ nh cÃ´ng!', 'success');

      } catch (err) {
        const errorMsg = `âŒ Lá»—i backup: ${err.message}`;
        addBackupLog(errorMsg);
        showBackupStatus(errorMsg, 'warning');
        alert(errorMsg);
        console.error('Backup error:', err);
      }
    }

    async function restoreFromGithub() {
      if (!confirm('âš ï¸ Restore sáº½ ghi Ä‘Ã¨ dá»¯ liá»‡u hiá»‡n táº¡i. Báº¡n cÃ³ cháº¯c cháº¯n?')) {
        return;
      }

      try {
        addBackupLog('ğŸ“¥ Báº¯t Ä‘áº§u restore...');
        showBackupStatus('â³ Äang restore tá»« GitHub...', 'info');

        const repo = localStorage.getItem(GITHUB_REPO_KEY);
        const branch = localStorage.getItem(GITHUB_BRANCH_KEY) || 'main';

        if (!repo) {
          throw new Error('ChÆ°a cÃ i Ä‘áº·t repository');
        }

        const [owner, repoName] = repo.split('/');

        // Fetch combined backup file
        addBackupLog('ğŸ“¥ Äang táº£i kitchen_backup.json...');
        const backupFile = await getGithubFile(owner, repoName, 'kitchen_backup.json', branch);

        if (!backupFile) {
          throw new Error('KhÃ´ng tÃ¬m tháº¥y backup file trÃªn GitHub');
        }

        const backupData = JSON.parse(backupFile.content);

        // Restore order history
        if (backupData.data?.orderHistory && Array.isArray(backupData.data.orderHistory)) {
          orderHistory = backupData.data.orderHistory;
          localStorage.setItem('orderHistory', JSON.stringify(orderHistory));
          addBackupLog(`âœ… ÄÃ£ restore ${orderHistory.length} orders`);
        }

        // Restore VIP list
        if (backupData.data?.vipList) {
          localStorage.setItem('vipList', backupData.data.vipList);
          document.getElementById('vipArea').value = backupData.data.vipList;
          addBackupLog('âœ… ÄÃ£ restore VIP list');
        }

        // Restore VIP transactions
        if (backupData.data?.vipTransactions && Array.isArray(backupData.data.vipTransactions)) {
          vipTransactions = backupData.data.vipTransactions;
          localStorage.setItem(VIP_TX_KEY, JSON.stringify(vipTransactions));
          addBackupLog(`âœ… ÄÃ£ restore ${vipTransactions.length} VIP transactions`);
        }

        // Refresh UI
        renderHistory();
        renderVipHistory();
        refreshQuickOrderList();
        updateDishNameSuggestions();

        addBackupLog('âœ… Restore hoÃ n táº¥t!');
        showBackupStatus('âœ… Restore thÃ nh cÃ´ng!', 'success');
        alert('âœ… ÄÃ£ restore dá»¯ liá»‡u tá»« GitHub thÃ nh cÃ´ng!');

      } catch (err) {
        const errorMsg = `âŒ Lá»—i restore: ${err.message}`;
        addBackupLog(errorMsg);
        showBackupStatus(errorMsg, 'warning');
        alert(errorMsg);
        console.error('Restore error:', err);
      }
    }

    function initGithubAutoBackup() {
      // Clear existing interval
      if (githubAutoBackupInterval) {
        clearInterval(githubAutoBackupInterval);
      }

      const interval = parseInt(localStorage.getItem(GITHUB_BACKUP_INTERVAL_KEY)) || 30;
      const enabled = localStorage.getItem(GITHUB_AUTO_BACKUP_ENABLED_KEY) === 'true';

      if (!enabled) return;

      // Set up new interval (convert minutes to milliseconds)
      githubAutoBackupInterval = setInterval(async () => {
        addBackupLog('ğŸ”„ Auto-backup triggered');
        await backupToGithub();
      }, interval * 60 * 1000);

      addBackupLog(`ğŸ”„ Auto-backup scheduled (every ${interval} minutes)`);
    }

    // ========== GitHub Sync Functions ==========

    /**
     * Pull latest data from GitHub
     * @returns {Object} Remote data and metadata
     */
    async function pullFromGithub() {
      try {
        addBackupLog('ğŸ“¥ Pulling data from GitHub...');

        const repo = localStorage.getItem(GITHUB_REPO_KEY);
        const branch = localStorage.getItem(GITHUB_BRANCH_KEY) || 'main';

        if (!repo) {
          throw new Error('ChÆ°a cÃ i Ä‘áº·t repository');
        }

        const [owner, repoName] = repo.split('/');
        if (!owner || !repoName) {
          throw new Error('Repository format khÃ´ng há»£p lá»‡');
        }

        // Fetch remote backup file
        const remoteFile = await getGithubFile(owner, repoName, 'kitchen_backup.json', branch);

        if (!remoteFile || !remoteFile.content) {
          addBackupLog('â„¹ï¸ No remote data found');
          return null;
        }

        // Parse remote data
        const remoteData = JSON.parse(remoteFile.content);

        addBackupLog(`âœ… Pulled: ${remoteData.data?.orderHistory?.length || 0} orders, ${remoteData.data?.vipTransactions?.length || 0} transactions`);

        return {
          data: remoteData.data,
          timestamp: remoteData.timestamp,
          backupTime: remoteData.backupTime
        };

      } catch (err) {
        addBackupLog(`âŒ Pull failed: ${err.message}`);
        throw err;
      }
    }

    /**
     * Merge local and remote data using last-write-wins strategy
     * @param {Object} localData - Local data
     * @param {Object} remoteData - Remote data
     * @returns {Object} Merged data
     */
    function mergeData(localData, remoteData) {
      addBackupLog('ğŸ”„ Merging data...');

      // Merge orderHistory by ID (keep newest by timestamp)
      const orderMap = new Map();

      // Add local orders
      (localData.orderHistory || []).forEach(order => {
        orderMap.set(order.id, order);
      });

      // Add/update with remote orders (newer wins)
      (remoteData.orderHistory || []).forEach(order => {
        const existing = orderMap.get(order.id);
        if (!existing) {
          orderMap.set(order.id, order);
        } else {
          // Compare timestamps - newer wins
          const existingTime = new Date(existing.date || existing.id).getTime();
          const remoteTime = new Date(order.date || order.id).getTime();
          if (remoteTime > existingTime) {
            orderMap.set(order.id, order);
          }
        }
      });

      // Merge vipTransactions by ID (keep all unique)
      const txMap = new Map();

      (localData.vipTransactions || []).forEach(tx => {
        txMap.set(tx.id, tx);
      });

      (remoteData.vipTransactions || []).forEach(tx => {
        if (!txMap.has(tx.id)) {
          txMap.set(tx.id, tx);
        }
      });

      const merged = {
        orderHistory: Array.from(orderMap.values())
          .sort((a, b) => new Date(b.date || b.id) - new Date(a.date || a.id)),
        vipTransactions: Array.from(txMap.values())
          .sort((a, b) => new Date(b.ts || b.id) - new Date(a.ts || a.id))
      };

      addBackupLog(`âœ… Merged: ${merged.orderHistory.length} orders, ${merged.vipTransactions.length} transactions`);

      return merged;
    }

    /**
     * Apply remote/merged data to local storage
     * @param {Object} data - Data to apply
     */
    function applyRemoteData(data) {
      addBackupLog('ğŸ’¾ Applying data to localStorage...');

      // Update localStorage
      orderHistory = data.orderHistory || [];
      vipTransactions = data.vipTransactions || [];

      localStorage.setItem('orderHistory', JSON.stringify(orderHistory));
      localStorage.setItem('vipTransactions', JSON.stringify(vipTransactions));

      // Recalculate VIP balances from transactions
      if (typeof recomputeVipBalances === 'function') {
        recomputeVipBalances();
      }

      addBackupLog('âœ… Data applied successfully');
    }

    /**
     * Full sync: Pull from GitHub, merge with local, push back
     */
    async function syncNow() {
      try {
        addBackupLog('ğŸ”„ Starting full sync...');
        showBackupStatus('ğŸ”„ Syncing...', 'info');

        // 1. Pull remote data
        const remote = await pullFromGithub();

        if (!remote) {
          // No remote data, just push local
          addBackupLog('ğŸ“¤ No remote data, pushing local...');
          await backupToGithub();
          showBackupStatus('âœ… Sync complete (pushed local)', 'success');
          return;
        }

        // 2. Get local data
        const local = {
          orderHistory: orderHistory,
          vipTransactions: vipTransactions
        };

        // 3. Merge
        const merged = mergeData(local, remote.data);

        // 4. Apply merged data locally
        applyRemoteData(merged);

        // 5. Push merged data back to GitHub
        addBackupLog('ğŸ“¤ Pushing merged data...');
        await backupToGithub();

        // 6. Refresh UI
        loadHistory();
        loadDebtManagement();
        renderVipHistory();
        populateVipMemberSelect();

        addBackupLog('âœ… Full sync complete!');
        showBackupStatus('âœ… Sync complete!', 'success');

        return merged;

      } catch (err) {
        const errorMsg = `âŒ Sync failed: ${err.message}`;
        addBackupLog(errorMsg);
        showBackupStatus(errorMsg, 'warning');
        throw err;
      }
    }

    function refreshQuickOrderList() {
      const select = document.getElementById('quickOrderSelect');
      if (!select) return;

      const seen = new Set();
      const items = [];

      orderHistory.forEach(order => {
        const name = (order?.itemName || '').trim();
        if (!name || seen.has(name)) return;
        seen.add(name);
        const ts = new Date(order?.date || order?.id || 0).getTime() || 0;
        items.push({ name, ts });
      });

      if (items.length === 0) {
        select.innerHTML = '<option value="">ChÆ°a cÃ³ mÃ³n nÃ o</option>';
        return;
      }

      items.sort((a, b) => b.ts - a.ts);
      select.innerHTML = items.map(i => `<option value="${i.name}">${i.name}</option>`).join('');
    }

    // Draft autosave helpers
    function getDraftPayload(hasChanges = draftDirty) {
      const people = Array.from(document.querySelectorAll('#orderTable tbody tr')).map(tr => {
        const nameInput = tr.children[0]?.querySelector('input');
        const qtyInput = tr.children[1]?.querySelector('input');
        const shipPartsInput = tr.children[2]?.querySelector('input');
        const paidCheck = tr.children[3]?.querySelector('input[type="checkbox"]');
        return {
          name: (nameInput?.value || '').trim(),
          qty: Number(qtyInput?.value || 0),
          shipParts: Number(shipPartsInput?.value || 0),
          paid: !!paidCheck?.checked
        };
      }).filter(p => p.name);

      return {
        draftOrder: {
          itemName: document.getElementById('itemName')?.value || '',
          totalParts: Number(document.getElementById('n')?.value || 0),
          alvinFree: !!document.getElementById('alvinFree')?.checked,
          desiredPrice: Number(document.getElementById('desiredPrice')?.value || 0),
          people,
          lastModified: Date.now(),
          hasChanges: hasChanges === true
        }
      };
    }

    function applyPeopleToTable(people = []) {
      const tbody = document.querySelector('#orderTable tbody');
      if (!tbody) return;
      suppressDraftChange = true;
      tbody.innerHTML = '';

      if (!Array.isArray(people) || people.length === 0) {
        addRow();
        suppressDraftChange = false;
        return;
      }

      people.forEach(p => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
      <td><input class="name-input" value="${p.name || ''}" placeholder="Nháº­p tÃªn..."></td>
      <td><input type="number" min="1" step="1" value="${p.qty || 1}"></td>
      <td><input type="number" min="0" step="1" value="${p.shipParts || 0}" class="ship-count-input" placeholder="0"></td>
      <td style="text-align: center;"><input type="checkbox" class="payment-check" ${p.paid ? 'checked' : ''}></td>
      <td style="text-align: center;"><button class="btn btn-danger" onclick="delRow(this)">âœ•</button></td>
    `;
        tbody.appendChild(tr);
      });

      suppressDraftChange = false;
    }

    function updateDraftStatusUI(draftOrder = {}) {
      const dot = document.getElementById('draftStatusDot');
      const statusText = document.getElementById('draftStatusText');
      const metaText = document.getElementById('draftMetaText');
      const hasChanges = draftOrder.hasChanges || draftDirty;
      const lastModified = draftOrder.lastModified || draftOrder.draftModified || Date.now();

      if (dot) {
        dot.classList.toggle('saved', !hasChanges);
        dot.classList.toggle('unsaved', hasChanges);
      }
      if (statusText) {
        statusText.textContent = hasChanges ? 'NhÃ¡p cÃ³ thay Ä‘á»•i (chÆ°a backup iCloud)' : 'NhÃ¡p Ä‘Ã£ lÆ°u';
      }
      if (metaText) {
        metaText.textContent = `Tá»± Ä‘á»™ng lÆ°u 30 phÃºt/láº§n | LÆ°u cuá»‘i: ${formatDraftTime(lastModified)}`;
      }
    }

    function setDraftBanner(message) {
      const banner = document.getElementById('draftBannerMessage');
      if (banner) banner.textContent = message || '';
    }

    function saveDraftToLocalStorage() {
      const draft = getDraftPayload(true);
      localStorage.setItem(DRAFT_STORAGE_KEY, JSON.stringify(draft));
      draftDirty = true;
      updateDraftStatusUI(draft.draftOrder);
      return draft;
    }

    function loadDraftFromLocalStorage() {
      try {
        const raw = localStorage.getItem(DRAFT_STORAGE_KEY);
        return raw ? JSON.parse(raw) : null;
      } catch (_err) {
        return null;
      }
    }

    function restoreDraftToUI(draftData) {
      if (!draftData || !draftData.draftOrder) return;

      const data = draftData.draftOrder;
      document.getElementById('itemName').value = data.itemName || '';
      document.getElementById('n').value = data.totalParts || 0;
      document.getElementById('alvinFree').checked = !!data.alvinFree;
      const desiredPriceInput = document.getElementById('desiredPrice');
      if (desiredPriceInput) desiredPriceInput.value = data.desiredPrice || '';
      selectedPrice = data.desiredPrice ? Number(data.desiredPrice) : null;
      applyPeopleToTable(data.people || []);

      draftDirty = !!data.hasChanges;
      updateDraftStatusUI(data);
      setDraftBanner('ğŸ“‹ ÄÃ£ khÃ´i phá»¥c Ä‘Æ¡n nhÃ¡p');
    }

    function markDraftChanged() {
      if (suppressDraftChange) return;
      lastComputedSignature = null;
      lastComputedOrder = null;
      draftDirty = true;
      updateDraftStatusUI({ hasChanges: true, lastModified: Date.now() });
      if (debouncedLocalDraftSave) {
        debouncedLocalDraftSave();
      } else {
        saveDraftToLocalStorage();
      }
    }

    function recordDraftMeta(path, savedAt) {
      const meta = JSON.parse(localStorage.getItem(DRAFT_META_KEY) || '[]').filter(Boolean);
      meta.unshift({ path, savedAt });

      // Deduplicate by path
      const unique = [];
      const seen = new Set();
      meta.forEach(entry => {
        if (!entry.path || seen.has(entry.path)) return;
        seen.add(entry.path);
        unique.push(entry);
      });

      localStorage.setItem(DRAFT_META_KEY, JSON.stringify(unique.slice(0, 10)));
    }

    async function deleteDraftFile(path) {
      try {
        if (window.orderHelperNative?.deleteFile) {
          await window.orderHelperNative.deleteFile(path);
          return true;
        }
        if (window.webkit?.messageHandlers?.orderHelperNative) {
          window.webkit.messageHandlers.orderHelperNative.postMessage({ action: 'deleteFile', path });
          return true;
        }
      } catch (err) {
        console.error('Delete draft failed', err);
      }
      return false;
    }

    async function cleanupOldDraftBackups() {
      const entries = JSON.parse(localStorage.getItem(DRAFT_META_KEY) || '[]').filter(Boolean);
      const now = Date.now();

      const toKeep = entries
        .filter(e => e.path)
        .sort((a, b) => (b.savedAt || 0) - (a.savedAt || 0));

      const fresh = toKeep.filter(e => now - (e.savedAt || 0) <= 7 * 24 * 60 * 60 * 1000);
      const survivors = fresh.slice(0, 5);
      const survivorPaths = new Set(survivors.map(s => s.path));
      const toDelete = toKeep.filter(e => !survivorPaths.has(e.path));

      for (const entry of toDelete) {
        await deleteDraftFile(entry.path);
      }

      localStorage.setItem(DRAFT_META_KEY, JSON.stringify(survivors));
    }

    async function writeFileToICloud(path, content, { allowDownloadFallback = false } = {}) {
      try {
        if (window.orderHelperNative?.writeFile) {
          await window.orderHelperNative.writeFile({ path, content });
          return { ok: true };
        }
        if (window.orderHelperNative?.writeTextFile) {
          await window.orderHelperNative.writeTextFile(path, content);
          return { ok: true };
        }
        if (window.webkit?.messageHandlers?.orderHelperNative) {
          window.webkit.messageHandlers.orderHelperNative.postMessage({ action: 'writeFile', path, content });
          return { ok: true };
        }
      } catch (err) {
        return { ok: false, error: err?.message || 'Unknown write error' };
      }

      if (allowDownloadFallback) {
        const a = document.createElement('a');
        const blob = new Blob([content], { type: 'application/json' });
        a.href = URL.createObjectURL(blob);
        a.download = path.split('/').pop();
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
        return { ok: true, fallback: true };
      }

      return { ok: false, error: 'KhÃ´ng cÃ³ bridge Ä‘á»ƒ ghi iCloud' };
    }

    function appendLog(message) {
      const line = `[${new Date().toISOString()}] ${message}`;
      console.error(line);
      try {
        if (window.orderHelperNative?.appendLog) {
          window.orderHelperNative.appendLog(line);
          return;
        }
        if (window.webkit?.messageHandlers?.orderHelperNative) {
          window.webkit.messageHandlers.orderHelperNative.postMessage({ action: 'appendLog', message: line });
        }
      } catch (_err) {
        // ignore
      }
    }

    function getDraftFilename(ts) {
      const d = new Date(ts);
      const pad = (n) => String(n).padStart(2, '0');
      const yyyy = d.getFullYear();
      const mm = pad(d.getMonth() + 1);
      const dd = pad(d.getDate());
      const hh = pad(d.getHours());
      const min = pad(d.getMinutes());
      return `draft_order_${yyyy}-${mm}-${dd}_${hh}${min}.json`;
    }

    async function saveDraftToICloud({ force = false, allowDownloadFallback = false, reason = 'auto' } = {}) {
      if (!force && !draftDirty) return false;

      if (draftBackupInFlight) return false;
      draftBackupInFlight = true;

      const draft = getDraftPayload(force || draftDirty);
      const now = Date.now();
      const filename = getDraftFilename(now);
      const path = `${DRAFT_DIR}/${filename}`;
      const content = JSON.stringify(draft, null, 2);

      try {
        if (window.orderHelperNative?.ensureDir) {
          try {
            await window.orderHelperNative.ensureDir(DRAFT_DIR);
          } catch (_err) {
            // ignore dir creation errors, writer may still handle it
          }
        }

        const res = await writeFileToICloud(path, content, { allowDownloadFallback });

        if (res.ok) {
          draft.draftOrder.hasChanges = false;
          draft.draftOrder.lastModified = now;
          localStorage.setItem(DRAFT_STORAGE_KEY, JSON.stringify(draft));
          draftDirty = false;
          lastDraftBackupPath = path;
          updateDraftStatusUI(draft.draftOrder);
          setDraftBanner(`âœ… ÄÃ£ backup iCloud (${filename})`);
          recordDraftMeta(path, now);
          cleanupOldDraftBackups();
          if (draftBackupRetryTimeout) {
            clearTimeout(draftBackupRetryTimeout);
            draftBackupRetryTimeout = null;
          }
          return true;
        }

        setDraftBanner('âš ï¸ LÆ°u iCloud tháº¥t báº¡i, sáº½ thá»­ láº¡i sau');
        appendLog(`Draft backup failed (${reason}): ${res.error || 'unknown error'}`);

        if (!draftBackupRetryTimeout) {
          draftBackupRetryTimeout = setTimeout(() => {
            draftBackupRetryTimeout = null;
            saveDraftToICloud({ force: true, reason: 'retry' });
          }, DRAFT_RETRY_INTERVAL_MS);
        }

        return false;
      } finally {
        draftBackupInFlight = false;
      }
    }

    async function readFileFromICloud(path) {
      try {
        if (window.orderHelperNative?.readFile) {
          return await window.orderHelperNative.readFile(path);
        }
        if (window.orderHelperNative?.readTextFile) {
          return await window.orderHelperNative.readTextFile(path);
        }
      } catch (err) {
        appendLog(`Read draft failed: ${err?.message || err}`);
      }

      try {
        const res = await fetch(`file://${encodeURI(path)}`);
        if (res.ok) {
          return await res.text();
        }
      } catch (_err) {
        // ignore fetch errors
      }

      return null;
    }

    async function loadLatestDraftFromICloud() {
      let entries = JSON.parse(localStorage.getItem(DRAFT_META_KEY) || '[]').filter(e => e && e.path);

      if (entries.length === 0 && window.orderHelperNative?.listFiles) {
        try {
          const files = await window.orderHelperNative.listFiles(DRAFT_DIR);
          if (Array.isArray(files)) {
            entries = files
              .filter(f => typeof f === 'string' && f.startsWith('draft_order_') && f.endsWith('.json'))
              .map(name => ({ path: `${DRAFT_DIR}/${name}`, savedAt: Date.now() }));
            localStorage.setItem(DRAFT_META_KEY, JSON.stringify(entries));
          }
        } catch (_err) {
          // ignore listing failures
        }
      }

      if (entries.length === 0) {
        setDraftBanner('â„¹ï¸ KhÃ´ng tÃ¬m tháº¥y nhÃ¡p iCloud nÃ o Ä‘á»ƒ táº£i');
        return;
      }

      const latest = entries.sort((a, b) => (b.savedAt || 0) - (a.savedAt || 0))[0];
      const content = await readFileFromICloud(latest.path);

      if (!content) {
        setDraftBanner('âŒ KhÃ´ng thá»ƒ Ä‘á»c nhÃ¡p tá»« iCloud');
        appendLog('Load draft from iCloud failed: missing content');
        return;
      }

      try {
        const data = JSON.parse(content);
        const payload = data && data.draftOrder ? data.draftOrder : data;
        restoreDraftToUI({ draftOrder: { ...payload, hasChanges: false } });
        draftDirty = false;
        updateDraftStatusUI({ ...payload, hasChanges: false });
        setDraftBanner('ğŸ“‚ ÄÃ£ táº£i nhÃ¡p tá»« iCloud');
      } catch (err) {
        appendLog(`Parse draft failed: ${err?.message || err}`);
        setDraftBanner('âŒ File nhÃ¡p khÃ´ng há»£p lá»‡');
      }
    }

    function clearDraft() {
      localStorage.removeItem(DRAFT_STORAGE_KEY);
      draftDirty = false;
      document.getElementById('itemName').value = '';
      document.getElementById('n').value = '';
      document.getElementById('alvinFree').checked = true;
      applyPeopleToTable([]);
      updateDraftStatusUI({ hasChanges: false, lastModified: Date.now() });
      setDraftBanner('ğŸ—‘ï¸ ÄÃ£ xoÃ¡ nhÃ¡p cá»¥c bá»™');
    }

    function setupDraftListeners() {
      const watchedSelectors = ['#quickInput', '#itemName', '#n', '#alvinFree', '#totalCost', '#costPerUnit', '#shipFee', '#targetProfit', '#desiredPrice', '#itemDesc', '#deadline'];
      watchedSelectors.forEach(sel => {
        const el = document.querySelector(sel);
        if (el) {
          el.addEventListener('input', markDraftChanged);
          el.addEventListener('change', markDraftChanged);
        }
      });

      const table = document.getElementById('orderTable');
      if (table) {
        table.addEventListener('input', markDraftChanged);
        table.addEventListener('change', markDraftChanged);
      }
    }

    function startDraftBackupInterval() {
      if (draftBackupIntervalId) clearInterval(draftBackupIntervalId);
      draftBackupIntervalId = setInterval(() => {
        saveDraftToICloud({ reason: 'interval' });
      }, DRAFT_BACKUP_INTERVAL_MS);
    }

    function handleBeforeUnload() {
      if (draftDirty) {
        saveDraftToLocalStorage();
        saveDraftToICloud({ force: true, reason: 'beforeunload' });
      }
    }

    function initDraftAutosave() {
      debouncedLocalDraftSave = debounce(() => saveDraftToLocalStorage(), 1000);

      const storedDraft = loadDraftFromLocalStorage();
      if (storedDraft) {
        restoreDraftToUI(storedDraft);
      } else {
        loadLatestDraftFromICloud();
      }

      updateDraftStatusUI(storedDraft?.draftOrder || { hasChanges: false, lastModified: null });

      setupDraftListeners();
      startDraftBackupInterval();
      window.addEventListener('beforeunload', handleBeforeUnload);
    }

    function manualSaveDraft() {
      saveDraftToLocalStorage();
      saveDraftToICloud({ force: true, allowDownloadFallback: true, reason: 'manual' });
    }

    // Tab Management
    function switchTab(evt, tabName) {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));

      const target = evt?.currentTarget || evt?.target;
      if (target) target.classList.add('active');
      document.getElementById(tabName).classList.add('active');

      // Load data for specific tabs
      if (tabName === 'history') loadHistory();
      if (tabName === 'debt') loadDebtManagement();
      if (tabName === 'stats') loadStats();
    }
    window.switchTab = switchTab;

    // Quick Parse Input
    function parseQuickInput() {
      const input = document.getElementById('quickInput').value.trim();
      if (!input) {
        alert('Vui lÃ²ng nháº­p danh sÃ¡ch order');
        return;
      }

      // Parse VIP for smart matching
      const vipMap = parseVip(document.getElementById('vipArea').value);
      const vipMatcher = vipMap._matcher || new SmartNameMatcher();

      // Clear existing table
      const tbody = document.querySelector('#orderTable tbody');
      tbody.innerHTML = '';

      // Parse format: lines or commas, with optional qty via space/colon
      const items = input
        .split(/[\n,]+/)
        .map(s => s.trim())
        .filter(s => s);
      let totalParts = 0;
      const suggestions = [];

      items.forEach(item => {
        // Extract name and quantity
        const match = item.match(/^(.+?)[\s:]+(\d+)$/);
        const inputName = match ? match[1].trim() : item.trim();
        const qty = match ? parseInt(match[2]) : 1;

        totalParts += qty;

        // Smart match against VIP
        const matchedVIP = vipMatcher.find(inputName);
        let finalName = inputName;

        if (matchedVIP && matchedVIP.original !== inputName) {
          finalName = matchedVIP.original;
          suggestions.push({
            input: inputName,
            suggested: matchedVIP.original
          });
        }

        // Add row to table
        const tr = document.createElement('tr');
        tr.innerHTML = `
      <td><input class="name-input" value="${finalName}"></td>
      <td><input type="number" min="1" step="1" value="${qty}"></td>
      <td><input type="number" min="0" step="1" value="0" class="ship-count-input" placeholder="0"></td>
      <td style="text-align: center;"><input type="checkbox" class="payment-check"></td>
      <td style="text-align: center;"><button class="btn btn-danger" onclick="delRow(this)">âœ•</button></td>
    `;
        tbody.appendChild(tr);
      });

      // Update total parts (add 1 for LÃ£o nhÃ¢n gia)
      document.getElementById('n').value = totalParts + 1;

      // Clear quick input
      document.getElementById('quickInput').value = '';

      // Show success message with suggestions
      let msg = `âœ… ÄÃ£ parse ${items.length} ngÆ°á»i, tá»•ng ${totalParts + 1} pháº§n (bao gá»“m LÃ£o nhÃ¢n gia)`;

      if (suggestions.length > 0) {
        msg += '\n\nğŸ”„ Smart matching Ä‘Ã£ tá»± Ä‘á»™ng sá»­a tÃªn:';
        suggestions.forEach(s => {
          msg += `\nâ€¢ "${s.input}" â†’ "${s.suggested}"`;
        });
      }

      markDraftChanged();
      alert(msg);
    }

    // Table Management
    function addRow() {
      const tbody = document.querySelector('#orderTable tbody');
      const tr = document.createElement('tr');
      tr.innerHTML = `
    <td><input class="name-input" value="" placeholder="Nháº­p tÃªn..."></td>
    <td><input type="number" min="1" step="1" value="1"></td>
    <td><input type="number" min="0" step="1" value="0" class="ship-count-input" placeholder="0"></td>
    <td style="text-align: center;"><input type="checkbox" class="payment-check"></td>
    <td style="text-align: center;"><button class="btn btn-danger" onclick="delRow(this)">âœ•</button></td>
  `;
      tbody.appendChild(tr);
      markDraftChanged();
    }

    function delRow(btn) {
      btn.closest('tr').remove();
      markDraftChanged();
    }

    // Price Suggestion
    function suggestPrices() {
      const n = Number(document.getElementById('n').value || 0);
      const alvinFree = document.getElementById('alvinFree').checked;
      const totalCost = Number(document.getElementById('totalCost').value || 0);
      const costPerUnit = Number(document.getElementById('costPerUnit').value || 0);
      const shipFee = Number(document.getElementById('shipFee').value || 0);
      const targetProfit = Number(document.getElementById('targetProfit').value || 6);

      // Validation: Check minimum parts
      const minParts = alvinFree ? 2 : 1;
      if (n < minParts) {
        alert(`âš ï¸ Lá»—i: Khi báº­t "LÃ£o nhÃ¢n gia free", tá»•ng pháº§n pháº£i â‰¥ 2.\n\nHiá»‡n táº¡i: ${n} pháº§n\nYÃªu cáº§u tá»‘i thiá»ƒu: ${minParts} pháº§n\n\nğŸ’¡ Gá»£i Ã½: TÄƒng sá»‘ pháº§n lÃªn hoáº·c táº¯t "LÃ£o nhÃ¢n gia free".`);
        return;
      }

      const denom = alvinFree ? (n - 1) : n;

      // Double check denom (safety guard)
      if (denom <= 0) {
        alert('âš ï¸ Lá»—i há»‡ thá»‘ng: Máº«u sá»‘ khÃ´ng há»£p lá»‡. Vui lÃ²ng kiá»ƒm tra láº¡i tá»•ng pháº§n.');
        return;
      }

      let T = 0;
      if (costPerUnit > 0) {
        T = n * costPerUnit + shipFee;
      } else if (totalCost > 0) {
        T = totalCost + shipFee;
      } else {
        alert('Vui lÃ²ng nháº­p Tá»•ng tiá»n mÃ³n (T) hoáº·c Chi phÃ­/pháº§n (c)');
        return;
      }

      const priceBreakEven = ceilInt(T / denom);
      const priceProfit = ceilInt((T + targetProfit) / denom);

      const suggestionHTML = `
    <div class="price-suggestion">
      <div class="price-card" onclick="selectPrice(${priceBreakEven}, event)">
        <div class="price-card-label">HoÃ  vá»‘n</div>
        <div class="price-card-value">${priceBreakEven}Ä‘</div>
        <div class="price-card-desc">Thu = Chi</div>
      </div>
      <div class="price-card active" onclick="selectPrice(${priceProfit}, event)">
        <div class="price-card-label">Lá»i ${targetProfit}Ä‘</div>
        <div class="price-card-value">${priceProfit}Ä‘</div>
        <div class="price-card-desc">Lá»i tá»‘i thiá»ƒu ${targetProfit}Ä‘</div>
      </div>
    </div>
  `;

      document.getElementById('priceSuggestion').innerHTML = suggestionHTML;
      selectPrice(priceProfit);
    }

    function handleDesiredPriceInput() {
      const input = document.getElementById('desiredPrice');
      if (!input) return;

      const manualPrice = Number(input.value || 0);
      document.querySelectorAll('.price-card').forEach(card => card.classList.remove('active'));

      if (manualPrice > 0) {
        selectedPrice = manualPrice;
      } else {
        selectedPrice = null;
      }
    }

    function selectPrice(price, evt) {
      document.querySelectorAll('.price-card').forEach(card => {
        card.classList.remove('active');
      });

      if (evt && evt.target) {
        evt.target.closest('.price-card').classList.add('active');
      }

      selectedPrice = price;
      const desiredPriceInput = document.getElementById('desiredPrice');
      if (desiredPriceInput) desiredPriceInput.value = price;
    }

    // Main Compute Function
    function compute(options = {}) {
      const saveHistory = !!options.save;
      const silent = !!options.silent;
      const skipIfUnchanged = !!options.skipIfUnchanged;
      const itemName = document.getElementById('itemName').value.trim() || 'MÃ³n Äƒn';
      const n = Number(document.getElementById('n').value || 0);
      const alvinFree = document.getElementById('alvinFree').checked;
      const totalCost = Number(document.getElementById('totalCost').value || 0);
      const costPerUnit = Number(document.getElementById('costPerUnit').value || 0);
      const shipFee = Number(document.getElementById('shipFee').value || 0);
      const targetProfitInput = Number(document.getElementById('targetProfit')?.value || 0);
      const desiredPriceInput = Number(document.getElementById('desiredPrice')?.value || 0);
      const itemDesc = document.getElementById('itemDesc')?.value || '';
      const deadline = document.getElementById('deadline')?.value || '';
      const isEditingExisting = !!editingOrderId;

      // Validation: Check minimum parts
      const minParts = alvinFree ? 2 : 1;
      if (n < minParts) {
        alert(`âš ï¸ Lá»—i: Khi báº­t "LÃ£o nhÃ¢n gia free", tá»•ng pháº§n pháº£i â‰¥ 2.\n\nHiá»‡n táº¡i: ${n} pháº§n\nYÃªu cáº§u tá»‘i thiá»ƒu: ${minParts} pháº§n\n\nğŸ’¡ Gá»£i Ã½: TÄƒng sá»‘ pháº§n lÃªn hoáº·c táº¯t "LÃ£o nhÃ¢n gia free".`);
        return null;
      }

      const denom = alvinFree ? (n - 1) : n;
      if (denom <= 0) {
        alert('âš ï¸ Lá»—i há»‡ thá»‘ng: Máº«u sá»‘ khÃ´ng há»£p lá»‡. Vui lÃ²ng kiá»ƒm tra láº¡i tá»•ng pháº§n.');
        return null;
      }

      let T = 0;
      if (costPerUnit > 0) {
        T = n * costPerUnit + shipFee;
      } else if (totalCost > 0) {
        T = totalCost + shipFee;
      }

      // Parse Order Table
      const rows = Array.from(document.querySelectorAll('#orderTable tbody tr')).map(tr => {
        const nameInput = tr.children[0].querySelector('input');
        const qtyInput = tr.children[1].querySelector('input');
        const shipPartsInput = tr.children[2].querySelector('input');
        const paidCheck = tr.children[3].querySelector('input[type="checkbox"]');
        const name = (nameInput.value || '').trim();
        const qty = Number(qtyInput.value || 0);
        let shipParts = Number(shipPartsInput.value || 0);
        shipParts = Math.max(0, Math.min(shipParts, qty)); // clamp 0..qty
        const paid = paidCheck.checked;
        return { name, qty, paid, shipParts };
      }).filter(r => r.name && r.qty > 0);

      const shipCount = rows.reduce((sum, r) => sum + r.shipParts, 0);
      const nonShipCount = rows.reduce((sum, r) => sum + (r.qty - r.shipParts), 0);

      // Decide pricing mode
      let sellingPrice = selectedPrice;
      let priceNonShip = null;
      let priceShip = null;
      let revenue = 0;
      let profit = 0;
      const foodCostOnly = T - shipFee;

      const canSplitShip = shipFee > 0 && shipCount > 0;

      if (canSplitShip) {
        // Base giÃ¡: chia Ä‘á»u tiá»n mÃ³n; ship chia riÃªng cho pháº§n cÃ³ ship
        const basePrice = foodCostOnly / denom;
        priceNonShip = ceilInt(basePrice);
        const surchargePerShip = shipFee / shipCount;
        priceShip = ceilInt(basePrice + surchargePerShip);
        sellingPrice = priceNonShip; // keep for backward compatibility fields

        const revenueNonShip = priceNonShip * nonShipCount;
        const revenueShip = priceShip * shipCount;
        revenue = revenueNonShip + revenueShip;
        profit = revenue - (foodCostOnly + shipFee);
      } else {
        if (!selectedPrice) {
          alert('Vui lÃ²ng báº¥m "Äá» xuáº¥t 2 má»©c giÃ¡" vÃ  chá»n giÃ¡ bÃ¡n trÆ°á»›c.');
          return null;
        }
        sellingPrice = selectedPrice;
        priceNonShip = sellingPrice;
        priceShip = sellingPrice;
        revenue = denom * sellingPrice;
        profit = revenue - T;
      }

      // Parse VIP with smart matching
      const vipFromArea = parseVip(document.getElementById('vipArea').value);
      const vipPersisted = parseVip(localStorage.getItem('vipList') || '');
      let vipMap = new Map([...vipPersisted, ...vipFromArea]);

      // Get matcher from vipMap
      const vipMatcher = vipFromArea._matcher || new SmartNameMatcher();

      // Re-populate matcher with all VIP data
      vipMap.forEach((balance, name) => {
        vipMatcher.add(name, balance);
      });

      // Process payments with smart name matching
      const members = [];
      const vipChanged = new Set();
      const orderDetails = [];
      const nameCorrections = []; // Track name corrections

      rows.forEach(r => {
        const shipQty = r.shipParts;
        const nonShipQty = r.qty - shipQty;
        const due = shipQty * priceShip + nonShipQty * priceNonShip;

        // Smart match: check if this name matches any VIP
        const matchedVIP = vipMatcher.find(r.name);

        if (matchedVIP) {
          // Found VIP match!
          const originalName = matchedVIP.original;
          const currentBalance = matchedVIP.data;
          const newBalance = currentBalance - due;

          // Update VIP balance
          vipMap.set(originalName, newBalance);
          vipMatcher.add(originalName, newBalance);
          vipChanged.add(originalName);

          // Track if name was corrected
          if (r.name !== originalName) {
            nameCorrections.push({
              input: r.name,
              corrected: originalName
            });
          }

          orderDetails.push({
            name: originalName, // Use original VIP name
            qty: r.qty,
            shipQty,
            nonShipQty,
            due: due,
            paid: true, // VIP auto-paid
            unitPrice: shipQty > 0 && nonShipQty > 0 ? `${formatMoney(priceNonShip)} / ${formatMoney(priceShip)}` : (shipQty > 0 ? priceShip : priceNonShip)
          });
        } else {
          // Not VIP, add to members
          orderDetails.push({
            name: r.name,
            qty: r.qty,
            shipQty,
            nonShipQty,
            due: due,
            paid: r.paid,
            unitPrice: shipQty > 0 && nonShipQty > 0 ? `${formatMoney(priceNonShip)} / ${formatMoney(priceShip)}` : (shipQty > 0 ? priceShip : priceNonShip)
          });

          if (!r.paid) {
            members.push({ name: r.name, due: due, qty: r.qty });
          }
        }
      });

      // Save to history
      const order = {
        id: editingOrderId || Date.now(),
        date: editingOrderDate || new Date().toISOString(),
        itemName: itemName,
        totalParts: n,
        alvinFree,
        sellingPrice: sellingPrice,
        sellingPriceShip: priceShip,
        sellingPriceNonShip: priceNonShip,
        splitShipMode: canSplitShip,
        shipCount,
        nonShipCount,
        shipFee,
        totalCost: T,
        totalCostInput: totalCost,
        costPerUnitInput: costPerUnit,
        targetProfit: targetProfitInput,
        desiredPriceInput,
        itemDesc,
        deadline,
        revenue: revenue,
        profit: profit,
        details: orderDetails,
        vipSnapshot: Array.from(vipMap.entries())
      };

      const orderSignature = buildOrderSignature({
        itemName,
        totalParts: n,
        alvinFree,
        totalCostInput: totalCost,
        costPerUnitInput: costPerUnit,
        shipFee,
        targetProfit: targetProfitInput,
        priceNonShip,
        priceShip,
        splitShipMode: canSplitShip,
        details: orderDetails
      });
      order.signature = orderSignature;
      lastComputedSignature = orderSignature;
      lastComputedOrder = order;

      let savedToHistory = false;
      const skipSave = saveHistory && skipIfUnchanged && lastSavedSignature === orderSignature;

      if (saveHistory && !skipSave) {
        if (isEditingExisting) {
          const idx = orderHistory.findIndex(o => o.id === editingOrderId);
          if (idx >= 0) {
            orderHistory[idx] = order;
          } else {
            orderHistory.unshift(order);
          }
        } else {
          orderHistory.unshift(order);
        }
        localStorage.setItem('orderHistory', JSON.stringify(orderHistory));

        // BUG FIX: Create VIP transactions for all VIP-paid details
        // This ensures transactions are created for both NEW and EDITED orders
        orderDetails.forEach(detail => {
          // Check if this person is a VIP (not just if balance changed)
          const isVIP = vipMap.has(detail.name);

          if (detail.paid && isVIP) {
            // VIP member paid - check if transaction already exists
            const existingTx = vipTransactions.find(tx =>
              tx.orderId === order.id &&
              tx.name === detail.name &&
              Math.abs(tx.amount) === detail.due
            );

            // Only create if transaction doesn't exist (prevents duplicates when editing)
            if (!existingTx) {
              recordVipTransaction({
                name: detail.name,
                amount: -detail.due,
                type: 'order',
                itemName: order.itemName,
                orderId: order.id
              });
            }
          }
        });

        lastSavedSignature = orderSignature;
        savedToHistory = true;
      } else if (saveHistory && skipSave) {
        lastSavedSignature = orderSignature;
      }
      if (saveHistory && (savedToHistory || skipSave)) {
        refreshQuickOrderList();
        updateDishNameSuggestions();
      }
      if (saveHistory && (savedToHistory || skipSave)) {
        editingOrderId = null;
        editingOrderDate = null;
      }

      // Generate Summary HTML
      const priceDetailText = canSplitShip
        ? `Ko ship: ${formatMoney(priceNonShip)} | CÃ³ ship: ${formatMoney(priceShip)}`
        : `${formatMoney(sellingPrice)}/pháº§n`;

      const revenueDetail = canSplitShip
        ? `${nonShipCount} Ã— ${formatMoney(priceNonShip)} + ${shipCount} Ã— ${formatMoney(priceShip)}`
        : `${denom} Ã— ${formatMoney(sellingPrice)}`;

      const summaryHTML = `
    <div class="summary-grid">
      <div class="summary-item">
        <h3>Tá»•ng pháº§n (n)</h3>
        <div class="summary-value">${n} pháº§n</div>
        <div class="summary-detail">${alvinFree ? `Thu ${denom} pháº§n (LÃ£o nhÃ¢n gia free)` : `Thu ${n} pháº§n`}</div>
      </div>
      <div class="summary-item">
        <h3>Tá»•ng chi (T)</h3>
        <div class="summary-value">${formatMoney(T)}</div>
        <div class="summary-detail">${costPerUnit > 0 ? `${n} Ã— ${formatMoney(costPerUnit)}` : formatMoney(totalCost)} + ship ${formatMoney(shipFee)}</div>
      </div>
      <div class="summary-item">
        <h3>Thu</h3>
        <div class="summary-value">${formatMoney(revenue)}</div>
        <div class="summary-detail">${revenueDetail}</div>
      </div>
      <div class="summary-item">
        <h3>Káº¿t quáº£</h3>
        <div class="summary-value ${profit >= 0 ? 'profit-positive' : 'profit-negative'}">
          ${profit >= 0 ? 'Lá»i' : 'Lá»—'} ${formatMoney(Math.abs(profit))}
        </div>
        <div class="summary-detail">HoÃ  vá»‘n: ${ceilInt(T / denom)}Ä‘/pháº§n</div>
      </div>
    </div>

    <div class="summary-grid" style="margin-top: 12px;">
      <div class="summary-item">
        <h3>ÄÆ¡n giÃ¡</h3>
        <div class="summary-value">${priceDetailText}</div>
        <div class="summary-detail">${canSplitShip ? `Ship ${shipCount} pháº§n | KhÃ´ng ship ${nonShipCount} pháº§n` : 'Ãp dá»¥ng chung cho táº¥t cáº£'}</div>
      </div>
      ${canSplitShip ? `
      <div class="summary-item">
        <h3>Chi tiáº¿t ship</h3>
        <div class="summary-value">${formatMoney(shipFee)}</div>
        <div class="summary-detail">${formatMoney(shipFee / shipCount)} má»—i pháº§n ship (lÃ m trÃ²n khi tÃ­nh tiá»n)</div>
      </div>` : ''}
    </div>

    <div class="grid" style="margin-top: 20px;">
      <div class="glass-card" style="padding: 20px;">
        <h3 style="font-size: 16px; margin-bottom: 12px; color: var(--text-secondary);">ğŸ‘‘ VIP (sá»‘ dÆ° sau khi trá»«)</h3>
        ${vipMap.size > 0 ? `
          <ul class="info-list">
            ${Array.from(vipMap.entries()).map(([name, bal]) => {
        const charged = vipChanged.has(name);
        const chargeAmount = charged
          ? orderDetails.filter(d => d.name === name).reduce((sum, d) => sum + d.due, 0)
          : 0;
        return `
              <li>
                <span class="name">${name}${charged ? ` (Ä‘Ã£ trá»« ${formatMoney(chargeAmount)})` : ''}</span>
                <span>
                  <span class="value">${formatMoney(bal)}</span>
                </span>
              </li>
            `;
      }).join('')}
          </ul>
        ` : '<div class="empty-state"><div class="empty-state-icon">ğŸ«™</div>ChÆ°a cÃ³ VIP</div>'}
      </div>

      <div class="glass-card" style="padding: 20px;">
        <h3 style="font-size: 16px; margin-bottom: 12px; color: var(--text-secondary);">ğŸ‘¥ Member (chÆ°a tráº£)</h3>
        ${members.length > 0 ? `
          <ul class="info-list">
            ${members.map(m => `
              <li>
                <span class="name">${m.name}${m.qty > 1 ? ` (${m.qty} pháº§n)` : ''}</span>
                <span class="value" style="color: var(--accent-red);">-${formatMoney(m.due)}</span>
              </li>
            `).join('')}
          </ul>
        ` : '<div class="empty-state"><div class="empty-state-icon">âœ…</div>Táº¥t cáº£ Ä‘Ã£ thanh toÃ¡n</div>'}
      </div>
    </div>
  `;

      document.getElementById('summarySection').innerHTML = summaryHTML;

      // Generate Final Message - Show VIP balance AFTER deduction
      const vipLine = vipMap.size > 0
        ? Array.from(vipMap.entries()).map(([name, bal]) => {
          // Check if this VIP was in the order
          const wasCharged = vipChanged.has(name);
          return `${name} (${formatMoney(bal)})`;
        }).join(', ')
        : 'â€”';

      const memLine = members.length > 0
        ? members.map(m => `${m.name}${m.qty > 1 ? ` (${m.qty} pháº§n)` : ''} (-${formatMoney(m.due)})`).join(', ')
        : 'â€”';

      const priceLine = canSplitShip
        ? `${formatMoney(priceNonShip)} ko ship | ${formatMoney(priceShip)} cÃ³ ship (ship ${shipCount} pháº§n, phÃ­ ${formatMoney(shipFee)})`
        : `${formatMoney(sellingPrice)}/pháº§n`;

      const finalMsg = `ğŸ½ ${itemName}: ${priceLine}\nğŸ‘‘ VIP: ${vipLine}\nğŸ‘¥ Member (chÆ°a tráº£): ${memLine}`;

      document.getElementById('finalMsg').value = finalMsg;

      if (saveHistory) {
        // Update VIP storage
        const vipText = vipToText(vipMap);
        document.getElementById('vipArea').value = vipText;
        persistVipList(vipText);

        if (skipSave) {
          if (!silent) {
            alert('â„¹ï¸ ÄÆ¡n nÃ y Ä‘Ã£ Ä‘Æ°á»£c lÆ°u trÆ°á»›c Ä‘Ã³, khÃ´ng lÆ°u trÃ¹ng.');
          } else {
            setDraftBanner('â„¹ï¸ ÄÆ¡n nÃ y Ä‘Ã£ Ä‘Æ°á»£c lÆ°u trÆ°á»›c Ä‘Ã³');
          }
        } else if (nameCorrections.length > 0) {
          const correctionMsg = nameCorrections
            .map(c => `â€¢ "${c.input}" â†’ "${c.corrected}"`)
            .join('\n');
          if (!silent) {
            alert(`âœ… ÄÃ£ lÆ°u Ä‘Æ¡n!\n\nğŸ”„ Smart matching Ä‘Ã£ tá»± Ä‘á»™ng sá»­a tÃªn:\n${correctionMsg}`);
          } else {
            setDraftBanner('âœ… ÄÃ£ lÆ°u Ä‘Æ¡n (Ä‘Ã£ sá»­a tÃªn smart matching)');
          }
        } else if (!silent) {
          alert('âœ… ÄÃ£ lÆ°u Ä‘Æ¡n vÃ o lá»‹ch sá»­!');
        } else {
          setDraftBanner('âœ… ÄÃ£ lÆ°u Ä‘Æ¡n vÃ o lá»‹ch sá»­');
        }

        // After any save, refresh VIP balances so panel/report stay aligned
        recomputeVipBalances();
      } else {
        setDraftBanner('â„¹ï¸ ÄÃ£ tÃ­nh táº¡m, báº¥m "LÆ°u Ä‘Æ¡n" Ä‘á»ƒ ghi vÃ o lá»‹ch sá»­');
      }

      return { order, saved: savedToHistory || skipSave, signature: orderSignature };
    }

    // Generate Open Order Message
    function generateOpenMsg() {
      const select = document.getElementById('quickOrderSelect');
      const qtyInput = document.getElementById('quickOrderQty');
      const fallbackName = document.getElementById('itemName')?.value.trim() || 'MÃ³n Äƒn';
      const itemName = select && select.value ? select.value : fallbackName;
      const qty = Math.max(1, Number(qtyInput?.value || 1));

      document.getElementById('openMsg').value = `${itemName} +${qty} order`;
    }

    // Reset Output
    function resetOutput() {
      document.getElementById('summarySection').innerHTML = '';
      document.getElementById('finalMsg').value = '';
      document.getElementById('openMsg').value = '';
      document.getElementById('priceSuggestion').innerHTML = '';
      const desiredPriceInput = document.getElementById('desiredPrice');
      if (desiredPriceInput) desiredPriceInput.value = '';
      selectedPrice = null;
    }

    // Copy Message
    function copyMsg(id, event) {
      const ta = document.getElementById(id);
      ta.select();
      ta.setSelectionRange(0, 99999);

      try {
        document.execCommand('copy');

        if (event && event.target) {
          const btn = event.target;
          const originalText = btn.textContent;
          btn.textContent = 'âœ“ ÄÃ£ copy!';
          setTimeout(() => {
            btn.textContent = originalText;
          }, 2000);
        } else {
          alert('âœ… ÄÃ£ copy!');
        }
      } catch (err) {
        alert('Vui lÃ²ng copy thá»§ cÃ´ng báº±ng Ctrl+C');
      }
    }

    function copyAndSaveFinalMsg(event) {
      const finalMsgArea = document.getElementById('finalMsg');
      const hasMessage = finalMsgArea.value.trim().length > 0;
      const isUnsaved = lastComputedSignature !== lastSavedSignature;

      if (!hasMessage || isUnsaved) {
        const res = compute({ save: true, silent: true, skipIfUnchanged: true });
        if (!res) return;
      }

      copyMsg('finalMsg', event);
      updateData('orderValue', formatMoney(totalPayable));
    }

    // ========== Order History Filters ==========

    let historyFilters = {
      fromDate: null,
      toDate: null,
      vip: '',
      itemName: ''
    };

    function populateVIPFilterDropdown() {
      const select = document.getElementById('filterVIP');
      if (!select) return;

      // Get unique VIP names from orders
      const vipNames = new Set();
      orderHistory.forEach(order => {
        if (order.details && Array.isArray(order.details)) {
          order.details.forEach(detail => {
            if (detail.name) vipNames.add(detail.name);
          });
        }
      });

      // Also add from VIP list
      const vipArea = document.getElementById('vipArea');
      if (vipArea) {
        const vipMap = parseVip(vipArea.value);
        vipMap.forEach((_, name) => vipNames.add(name));
      }

      // Populate dropdown
      const options = '<option value="">Táº¥t cáº£</option>' +
        Array.from(vipNames).sort().map(name =>
          `<option value="${name}">${name}</option>`
        ).join('');
      select.innerHTML = options;
    }

    function applyHistoryFilters() {
      // Get filter values
      historyFilters.fromDate = document.getElementById('filterFromDate').value;
      historyFilters.toDate = document.getElementById('filterToDate').value;
      historyFilters.vip = document.getElementById('filterVIP').value;
      historyFilters.itemName = document.getElementById('filterItem').value.toLowerCase();

      // Re-render with filters
      renderHistory();

      // Update summary
      updateFilterSummary();
    }

    function clearHistoryFilters() {
      document.getElementById('filterFromDate').value = '';
      document.getElementById('filterToDate').value = '';
      document.getElementById('filterVIP').value = '';
      document.getElementById('filterItem').value = '';

      historyFilters = {
        fromDate: null,
        toDate: null,
        vip: '',
        itemName: ''
      };

      renderHistory();
      updateFilterSummary();
    }

    function updateFilterSummary() {
      const summary = document.getElementById('filterSummary');
      if (!summary) return;

      const activeFilters = [];
      if (historyFilters.fromDate) activeFilters.push(`Tá»« ${historyFilters.fromDate}`);
      if (historyFilters.toDate) activeFilters.push(`Ä‘áº¿n ${historyFilters.toDate}`);
      if (historyFilters.vip) activeFilters.push(`VIP: ${historyFilters.vip}`);
      if (historyFilters.itemName) activeFilters.push(`MÃ³n: ${historyFilters.itemName}`);

      if (activeFilters.length > 0) {
        summary.textContent = 'ğŸ” ' + activeFilters.join(' â€¢ ');
      } else {
        summary.textContent = '';
      }
    }

    function filterOrderHistory(orders) {
      return orders.filter(order => {
        // Date filter
        if (historyFilters.fromDate || historyFilters.toDate) {
          const orderDate = new Date(order.date || order.id);
          const orderDateStr = orderDate.toISOString().split('T')[0];

          if (historyFilters.fromDate && orderDateStr < historyFilters.fromDate) {
            return false;
          }
          if (historyFilters.toDate && orderDateStr > historyFilters.toDate) {
            return false;
          }
        }

        // VIP filter
        if (historyFilters.vip) {
          const hasVIP = order.details && order.details.some(d => d.name === historyFilters.vip);
          if (!hasVIP) return false;
        }

        // Item name filter
        if (historyFilters.itemName) {
          const itemMatch = order.itemName && order.itemName.toLowerCase().includes(historyFilters.itemName);
          if (!itemMatch) return false;
        }

        return true;
      });
    }

    // Render History
    function renderHistory() {
      const historyList = document.getElementById('historyList');

      if (orderHistory.length === 0) {
        historyList.innerHTML = '<div class="empty-state"><div class="empty-state-icon">ğŸ“­</div>ChÆ°a cÃ³ Ä‘Æ¡n hÃ ng nÃ o</div>';
        refreshQuickOrderList();
        return;
      }

      // Apply filters
      const filteredOrders = filterOrderHistory(orderHistory);

      if (filteredOrders.length === 0) {
        historyList.innerHTML = '<div class="empty-state">âŒ KhÃ´ng tÃ¬m tháº¥y Ä‘Æ¡n hÃ ng nÃ o phÃ¹ há»£p vá»›i bá»™ lá»c</div>';
        refreshQuickOrderList();
        return;
      }

      historyList.innerHTML = filteredOrders.map(order => {
        const paidCount = order.details.filter(d => d.paid).length;
        const totalCount = order.details.length;
        const statusClass = paidCount === totalCount ? 'status-paid' : (paidCount > 0 ? 'status-partial' : 'status-unpaid');
        const statusText = paidCount === totalCount ? 'ÄÃ£ thanh toÃ¡n' : `${paidCount}/${totalCount} Ä‘Ã£ tráº£`;
        const historyPriceLine = order.splitShipMode
          ? `${order.nonShipCount || 0}Ã—${formatMoney(order.sellingPriceNonShip || order.sellingPrice)} + ${order.shipCount || 0}Ã—${formatMoney(order.sellingPriceShip || order.sellingPrice)}`
          : `${order.totalParts} pháº§n Ã— ${formatMoney(order.sellingPrice)}`;

        return `
      <div class="history-item" onclick="showOrderDetail(${order.id})">
        <div class="history-header">
          <div class="history-title">${order.itemName}</div>
          <div class="history-date">${formatDate(order.date)}</div>
        </div>
        <div class="history-details">
          ${historyPriceLine} = ${formatMoney(order.revenue)} 
          <span class="${order.profit >= 0 ? 'profit-positive' : 'profit-negative'}">
            (${order.profit >= 0 ? 'Lá»i' : 'Lá»—'} ${formatMoney(Math.abs(order.profit))})
          </span>
          <span class="status-badge ${statusClass}">${statusText}</span>
        </div>
      </div>
    `;
      }).join('');
      refreshQuickOrderList();
    }

    function showOrderDetail(orderId) {
      const order = orderHistory.find(o => o.id === orderId);
      if (!order) return;

      const modalBody = document.getElementById('modalBody');
      const modalPriceLabel = order.splitShipMode
        ? `Ko ship ${formatMoney(order.sellingPriceNonShip || order.sellingPrice)} | Ship ${formatMoney(order.sellingPriceShip || order.sellingPrice)}`
        : `${formatMoney(order.sellingPrice)}/pháº§n`;

      modalBody.innerHTML = `
    <div class="form-group">
      <label class="form-label">TÃªn mÃ³n</label>
      <div style="font-size: 18px; font-weight: 600; color: var(--text-primary);">${order.itemName}</div>
    </div>

    <div class="form-row">
      <div class="form-group">
        <label class="form-label">NgÃ y giá»</label>
        <div style="color: var(--text-primary);">${formatDate(order.date)}</div>
      </div>
      <div class="form-group">
        <label class="form-label">GiÃ¡ bÃ¡n</label>
        <div style="color: var(--text-primary);">${modalPriceLabel}</div>
      </div>
    </div>

    <div class="summary-grid" style="margin: 20px 0;">
      <div class="summary-item">
        <h3>Tá»•ng chi</h3>
        <div class="summary-value">${formatMoney(order.totalCost)}</div>
      </div>
      <div class="summary-item">
        <h3>Thu vá»</h3>
        <div class="summary-value">${formatMoney(order.revenue)}</div>
      </div>
      <div class="summary-item">
        <h3>Káº¿t quáº£</h3>
        <div class="summary-value ${order.profit >= 0 ? 'profit-positive' : 'profit-negative'}">
          ${order.profit >= 0 ? 'Lá»i' : 'Lá»—'} ${formatMoney(Math.abs(order.profit))}
        </div>
      </div>
    </div>

    <div class="form-group">
      <label class="form-label">Danh sÃ¡ch order</label>
      <div class="table-wrapper">
        <table class="table">
          <thead>
              <tr>
                <th>TÃªn</th>
                <th style="text-align: right;">Sá»‘ pháº§n</th>
                <th style="text-align: right;">ÄÆ¡n giÃ¡</th>
                <th style="text-align: right;">Ship</th>
                <th style="text-align: right;">ThÃ nh tiá»n</th>
                <th style="text-align: center;">Tráº¡ng thÃ¡i</th>
              </tr>
            </thead>
            <tbody>
              ${order.details.map(d => `
              <tr>
                <td>${d.name}</td>
                <td style="text-align: right;">${d.qty}</td>
                <td style="text-align: right;">${typeof d.unitPrice === 'string' ? d.unitPrice : formatMoney(d.unitPrice || order.sellingPrice)}</td>
                <td style="text-align: right;">${d.shipQty ? `${d.shipQty} ğŸšš` : '0'}</td>
                <td style="text-align: right;">${formatMoney(d.due)}</td>
                <td style="text-align: center;">
                  <span class="status-badge ${d.paid ? 'status-paid' : 'status-unpaid'}">
                    ${d.paid ? 'ÄÃ£ tráº£' : 'ChÆ°a tráº£'}
                  </span>
                </td>
              </tr>
            `).join('')}
          </tbody>
        </table>
      </div>
    </div>

    <div class="btn-group" style="margin-top: 20px;">
      <button class="btn btn-secondary" onclick="editOrder(${order.id})">âœï¸ Chá»‰nh sá»­a Ä‘Æ¡n</button>
      <button class="btn btn-info" onclick="markAllPaid(${order.id})">âœ“ ÄÃ¡nh dáº¥u táº¥t cáº£ Ä‘Ã£ tráº£</button>
      <button class="btn btn-danger" onclick="deleteOrder(${order.id})">ğŸ—‘ï¸ XoÃ¡ Ä‘Æ¡n nÃ y</button>
    </div>
  `;

      document.getElementById('orderModal').classList.add('active');
    }

    function editOrder(orderId) {
      const order = orderHistory.find(o => o.id === orderId);
      if (!order) return;

      editingOrderId = orderId;
      editingOrderDate = order.date;
      closeModal();

      const newOrderTab = document.querySelector('.tab[onclick*="newOrder"]');
      switchTab({ currentTarget: newOrderTab }, 'newOrder');

      document.getElementById('itemName').value = order.itemName || '';
      const totalPartsValue = order.totalParts || order.nonShipCount + order.shipCount || '';
      document.getElementById('n').value = totalPartsValue;
      document.getElementById('alvinFree').checked = !!order.alvinFree;
      document.getElementById('shipFee').value = order.shipFee || 0;

      const totalCostInputValue = order.totalCostInput !== undefined
        ? order.totalCostInput
        : Math.max((order.totalCost || 0) - (order.shipFee || 0), 0);
      document.getElementById('totalCost').value = totalCostInputValue ?? 0;
      document.getElementById('costPerUnit').value = order.costPerUnitInput ?? 0;

      const targetProfitInputEl = document.getElementById('targetProfit');
      if (targetProfitInputEl) {
        targetProfitInputEl.value = order.targetProfit !== undefined ? order.targetProfit : (targetProfitInputEl.value || 0);
      }

      const desiredPriceInput = document.getElementById('desiredPrice');
      const desiredPriceValue = order.desiredPriceInput ?? order.sellingPriceNonShip ?? order.sellingPrice ?? '';
      if (desiredPriceInput) desiredPriceInput.value = desiredPriceValue;
      selectedPrice = desiredPriceValue ? Number(desiredPriceValue) : null;

      const itemDescInput = document.getElementById('itemDesc');
      if (itemDescInput) itemDescInput.value = order.itemDesc || '';
      const deadlineInput = document.getElementById('deadline');
      if (deadlineInput) deadlineInput.value = order.deadline || '';

      const people = (order.details || []).map(d => ({
        name: d.name,
        qty: d.qty,
        shipParts: d.shipQty || d.shipParts || 0,
        paid: d.paid
      }));
      applyPeopleToTable(people);

      markDraftChanged();
      setDraftBanner('âœï¸ Äang chá»‰nh sá»­a Ä‘Æ¡n tá»« lá»‹ch sá»­. Báº¥m "LÆ°u Ä‘Æ¡n" Ä‘á»ƒ cáº­p nháº­t.');
    }

    function closeModal() {
      document.getElementById('orderModal').classList.remove('active');
    }

    function deleteOrder(orderId) {
      if (!confirm('XÃ¡c nháº­n xoÃ¡ Ä‘Æ¡n hÃ ng nÃ y?')) return;

      orderHistory = orderHistory.filter(o => o.id !== orderId);
      localStorage.setItem('orderHistory', JSON.stringify(orderHistory));

      closeModal();
      loadHistory();
      alert('âœ… ÄÃ£ xoÃ¡ Ä‘Æ¡n hÃ ng');
    }

    function markAllPaid(orderId) {
      const order = orderHistory.find(o => o.id === orderId);
      if (!order) return;

      order.details.forEach(d => d.paid = true);
      localStorage.setItem('orderHistory', JSON.stringify(orderHistory));

      showOrderDetail(orderId);
      alert('âœ… ÄÃ£ Ä‘Ã¡nh dáº¥u táº¥t cáº£ Ä‘Ã£ thanh toÃ¡n');
    }

    function markDebtorPaid(name) {
      if (!name) return;
      const target = name.trim();
      const changes = [];
      let totalCleared = 0;

      orderHistory.forEach(order => {
        order.details.forEach((d, idx) => {
          if (!d.paid && d.name === target) {
            changes.push({ orderId: order.id, detailIndex: idx, due: d.due });
            totalCleared += d.due;
          }
        });
      });

      if (changes.length === 0) {
        alert('â„¹ï¸ KhÃ´ng tháº¥y cÃ´ng ná»£ cáº§n cáº­p nháº­t cho ngÆ°á»i nÃ y');
        return;
      }

      const confirmMsg = `ÄÃ¡nh dáº¥u Ä‘Ã£ tráº£ cho ${target}?\n${changes.length} má»¥c, tá»•ng ${formatMoney(totalCleared)}`;
      if (!confirm(confirmMsg)) return;

      // Check if this person has VIP
      const vipMap = parseVip(document.getElementById('vipArea').value);
      const hasVIP = vipMap.has(target);
      let paymentMethod = 'cash';

      if (hasVIP) {
        const currentBalance = vipMap.get(target);

        // Deduct from VIP balance
        const newBalance = currentBalance - totalCleared;
        vipMap.set(target, newBalance);

        // Update VIP textarea and persist
        const vipText = vipToText(vipMap);
        document.getElementById('vipArea').value = vipText;
        persistVipList(vipText);

        // Record VIP transaction for each debt
        changes.forEach(change => {
          const order = orderHistory.find(o => o.id === change.orderId);
          if (order) {
            recordVipTransaction({
              name: target,
              amount: -change.due,
              type: 'order',
              itemName: order.itemName,
              orderId: order.id
            });
            // Mark order detail as paid via VIP
            if (order.details && order.details[change.detailIndex]) {
              order.details[change.detailIndex].isVipPayment = true;
            }
          }
        });

        paymentMethod = 'vip';
      }

      // Mark as paid
      changes.forEach(change => {
        const order = orderHistory.find(o => o.id === change.orderId);
        if (order && order.details[change.detailIndex]) {
          order.details[change.detailIndex].paid = true;
          if (paymentMethod === 'vip') {
            order.details[change.detailIndex].isVipPayment = true;
          }
        }
      });

      lastDebtorPaidSnapshot = { name: target, changes };
      localStorage.setItem('orderHistory', JSON.stringify(orderHistory));
      loadDebtManagement();
      loadHistory();
      renderVipHistory();
      populateVipMemberSelect();

      const paymentText = paymentMethod === 'vip' ? 'tá»« VIP' : 'báº±ng tiá»n máº·t';
      alert(`âœ… ÄÃ£ Ä‘Ã¡nh dáº¥u ${target} Ä‘Ã£ tráº£ háº¿t ná»£ ${paymentText}\nTá»•ng: ${formatMoney(totalCleared)}`);
    }

    function markSingleDebtPaid(orderId, detailIndex, name) {
      const order = orderHistory.find(o => o.id === orderId);
      if (!order || !order.details?.[detailIndex]) return;

      const detail = order.details[detailIndex];
      if (detail.paid) {
        alert('â„¹ï¸ Má»¥c nÃ y Ä‘Ã£ Ä‘Æ°á»£c Ä‘Ã¡nh dáº¥u tráº£ rá»“i');
        return;
      }

      const confirmMsg = `ÄÃ¡nh dáº¥u Ä‘Ã£ tráº£ cho ${name || detail.name}?\n` +
        `${order.itemName} - ${formatMoney(detail.due)} (${detail.qty} pháº§n)`;
      if (!confirm(confirmMsg)) return;

      const target = (name || detail.name).trim();

      // Check if this person has VIP
      const vipMap = parseVip(document.getElementById('vipArea').value);
      const hasVIP = vipMap.has(target);
      let paymentMethod = 'cash';

      if (hasVIP) {
        const currentBalance = vipMap.get(target);

        // Deduct from VIP balance
        const newBalance = currentBalance - detail.due;
        vipMap.set(target, newBalance);

        // Update VIP textarea and persist
        const vipText = vipToText(vipMap);
        document.getElementById('vipArea').value = vipText;
        persistVipList(vipText);

        // Check if transaction already exists (prevent duplicates)
        const existingTx = vipTransactions.find(tx =>
          tx.orderId === order.id &&
          tx.name === target &&
          Math.abs(tx.amount) === detail.due
        );

        // Record VIP transaction only if it doesn't exist
        if (!existingTx) {
          recordVipTransaction({
            name: target,
            amount: -detail.due,
            type: 'order',
            itemName: order.itemName,
            orderId: order.id,
            paid: true
          });
        }
        detail.isVipPayment = true;

        paymentMethod = 'vip';
      }

      detail.paid = true;
      lastDebtorPaidSnapshot = {
        name: target,
        changes: [{ orderId, detailIndex, due: detail.due }]
      };

      localStorage.setItem('orderHistory', JSON.stringify(orderHistory));
      loadDebtManagement();
      loadHistory();
      renderVipHistory();
      populateVipMemberSelect();

      const paymentText = paymentMethod === 'vip' ? 'tá»« VIP' : 'báº±ng tiá»n máº·t';
      alert(`âœ… ÄÃ£ Ä‘Ã¡nh dáº¥u Ä‘Ã£ tráº£ ${paymentText}`);
    }

    function undoLastDebtorPaid() {
      if (!lastDebtorPaidSnapshot || !lastDebtorPaidSnapshot.changes?.length) {
        alert('â„¹ï¸ KhÃ´ng cÃ³ thao tÃ¡c nÃ o Ä‘á»ƒ hoÃ n tÃ¡c');
        return;
      }

      const { name, changes } = lastDebtorPaidSnapshot;

      // Check if this person has VIP - if so, refund the amount
      const vipMap = parseVip(document.getElementById('vipArea').value);
      const hasVIP = vipMap.has(name);

      if (hasVIP) {
        const currentBalance = vipMap.get(name);
        let totalRefund = 0;

        changes.forEach(change => {
          if (change.due) {
            totalRefund += change.due;
          }
        });

        // Refund to VIP balance
        const newBalance = currentBalance + totalRefund;
        vipMap.set(name, newBalance);

        // Update VIP textarea and persist
        const vipText = vipToText(vipMap);
        document.getElementById('vipArea').value = vipText;
        persistVipList(vipText);
      }

      // Mark as unpaid
      changes.forEach(change => {
        const order = orderHistory.find(o => o.id === change.orderId);
        if (order && order.details[change.detailIndex]) {
          order.details[change.detailIndex].paid = false;
        }
      });

      localStorage.setItem('orderHistory', JSON.stringify(orderHistory));
      loadDebtManagement();
      loadHistory();
      renderVipHistory();
      populateVipMemberSelect();

      const refundText = hasVIP ? ' (Ä‘Ã£ hoÃ n tiá»n vÃ o VIP)' : '';
      alert(`â†©ï¸ ÄÃ£ hoÃ n tÃ¡c Ä‘Ã¡nh dáº¥u Ä‘Ã£ tráº£ cho ${name}${refundText}`);
      lastDebtorPaidSnapshot = null;
    }

    // Export helper for manual use and automation
    function exportForAutomation(options = {}) {
      const { download = true, silent = false } = options;

      try {
        const stored = localStorage.getItem('orderHistory');
        const parsed = stored ? JSON.parse(stored) : [];
        const filename = `order_history_${new Date().toISOString().split('T')[0]}.json`;
        const content = JSON.stringify(parsed, null, 2);

        if (download) {
          const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(content);
          const linkElement = document.createElement('a');
          linkElement.setAttribute('href', dataUri);
          linkElement.setAttribute('download', filename);
          document.body.appendChild(linkElement);
          linkElement.click();
          document.body.removeChild(linkElement);
        }

        const result = { success: true, filename, count: parsed.length, content };
        window.__autobackupResult = result;
        return result;
      } catch (error) {
        const result = { success: false, error: error.message };
        window.__autobackupResult = result;
        if (!silent) {
          alert('âŒ Lá»—i export: ' + error.message);
        }
        return result;
      }
    }

    function exportHistory() {
      const res = exportForAutomation({ download: true, silent: true });
      if (!res.success) {
        alert('âŒ KhÃ´ng thá»ƒ export: ' + res.error);
      }
    }

    function clearHistory() {
      if (!confirm('XÃ¡c nháº­n xoÃ¡ toÃ n bá»™ lá»‹ch sá»­ Ä‘Æ¡n hÃ ng?')) return;

      orderHistory = [];
      localStorage.setItem('orderHistory', JSON.stringify(orderHistory));
      refreshQuickOrderList();
      loadHistory();
      alert('âœ… ÄÃ£ xoÃ¡ toÃ n bá»™ lá»‹ch sá»­');
    }

    // Debt Management
    function loadDebtManagement() {
      const debtMap = new Map();

      orderHistory.forEach(order => {
        order.details.forEach((d, detailIndex) => {
          if (!d.paid) {
            const current = debtMap.get(d.name) || { total: 0, orders: [] };
            current.total += d.due;
            current.orders.push({
              orderId: order.id,
              itemName: order.itemName,
              date: order.date,
              detailIndex,
              qty: d.qty,
              due: d.due
            });
            debtMap.set(d.name, current);
          }
        });
      });

      // Summary
      const totalDebt = Array.from(debtMap.values()).reduce((sum, d) => sum + d.total, 0);
      const debtorCount = debtMap.size;

      const summaryHTML = `
    <div class="stats-grid">
      <div class="stat-card">
        <div class="stat-icon">ğŸ’°</div>
        <div class="stat-value">${formatMoney(totalDebt)}</div>
        <div class="stat-label">Tá»•ng cÃ´ng ná»£</div>
      </div>
      <div class="stat-card">
        <div class="stat-icon">ğŸ‘¥</div>
        <div class="stat-value">${debtorCount}</div>
        <div class="stat-label">NgÆ°á»i Ä‘ang ná»£</div>
      </div>
    </div>
  `;

      document.getElementById('debtSummary').innerHTML = summaryHTML;

      // Details
      if (debtMap.size === 0) {
        document.getElementById('debtDetails').innerHTML = '<div class="empty-state"><div class="empty-state-icon">âœ…</div>KhÃ´ng cÃ³ cÃ´ng ná»£</div>';
        return;
      }

      const undoBtn = `
    <div class="btn-group" style="margin-bottom: 12px;">
      <button class="btn btn-info" onclick="undoLastDebtorPaid()">â†©ï¸ HoÃ n tÃ¡c láº§n cuá»‘i</button>
    </div>
  `;

      const detailsHTML = undoBtn + Array.from(debtMap.entries())
        .sort((a, b) => b[1].total - a[1].total)
        .map(([name, data]) => `
      <div class="glass-card" style="margin-bottom: 16px; padding: 20px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
          <div>
            <div style="font-size: 20px; font-weight: 700; color: var(--text-primary);">${name}</div>
            <div style="font-size: 14px; color: var(--text-muted);">${data.orders.length} Ä‘Æ¡n chÆ°a thanh toÃ¡n</div>
          </div>
          <div style="text-align: right;">
            <div style="font-size: 24px; font-weight: 700; color: var(--accent-red);">${formatMoney(data.total)}</div>
            <button class="btn btn-primary" style="margin-top: 8px;" onclick='markDebtorPaid(${JSON.stringify(name)})'>ÄÃ£ tráº£</button>
          </div>
        </div>

        <div class="table-wrapper">
          <table class="table">
            <thead>
              <tr>
                <th>NgÃ y</th>
                <th>MÃ³n</th>
                <th style="text-align: right;">Sá»‘ pháº§n</th>
                <th style="text-align: right;">Tiá»n</th>
                <th style="text-align: center;">HÃ nh Ä‘á»™ng</th>
              </tr>
            </thead>
            <tbody>
              ${data.orders.map(o => `
                <tr>
                  <td onclick="showOrderDetail(${o.orderId})" style="cursor: pointer;">${formatDate(o.date).split(' ')[0]}</td>
                  <td onclick="showOrderDetail(${o.orderId})" style="cursor: pointer;">${o.itemName}</td>
                  <td style="text-align: right;" onclick="showOrderDetail(${o.orderId})" style="cursor: pointer;">${o.qty}</td>
                  <td style="text-align: right;" onclick="showOrderDetail(${o.orderId})" style="cursor: pointer;">${formatMoney(o.due)}</td>
                  <td style="text-align: center;">
                    <button class="btn btn-primary" style="padding: 6px 10px; font-size: 12px;"
                      onclick='markSingleDebtPaid(${o.orderId}, ${o.detailIndex}, ${JSON.stringify(name)});'>
                      ÄÃ£ tráº£
                    </button>
                  </td>
                </tr>
              `).join('')}
            </tbody>
          </table>
        </div>
      </div>
    `).join('');

      document.getElementById('debtDetails').innerHTML = detailsHTML;
    }

    // Stats
    function loadStats() {
      if (orderHistory.length === 0) {
        document.getElementById('statsContent').innerHTML = '<div class="empty-state"><div class="empty-state-icon">ğŸ“Š</div>ChÆ°a cÃ³ dá»¯ liá»‡u Ä‘á»ƒ thá»‘ng kÃª</div>';
        return;
      }

      const totalOrders = orderHistory.length;
      const totalRevenue = orderHistory.reduce((sum, o) => sum + o.revenue, 0);
      const totalCost = orderHistory.reduce((sum, o) => sum + o.totalCost, 0);
      const totalProfit = totalRevenue - totalCost;

      const statsHTML = `
    <div class="stats-grid">
      <div class="stat-card">
        <div class="stat-icon">ğŸ“¦</div>
        <div class="stat-value">${totalOrders}</div>
        <div class="stat-label">Tá»•ng Ä‘Æ¡n hÃ ng</div>
      </div>
      <div class="stat-card">
        <div class="stat-icon">ğŸ’µ</div>
        <div class="stat-value">${formatMoney(totalRevenue)}</div>
        <div class="stat-label">Tá»•ng thu</div>
      </div>
      <div class="stat-card">
        <div class="stat-icon">ğŸ’¸</div>
        <div class="stat-value">${formatMoney(totalCost)}</div>
        <div class="stat-label">Tá»•ng chi</div>
      </div>
      <div class="stat-card">
        <div class="stat-icon">${totalProfit >= 0 ? 'ğŸ“ˆ' : 'ğŸ“‰'}</div>
        <div class="stat-value ${totalProfit >= 0 ? 'profit-positive' : 'profit-negative'}">
          ${formatMoney(Math.abs(totalProfit))}
        </div>
        <div class="stat-label">${totalProfit >= 0 ? 'Lá»£i nhuáº­n' : 'Thua lá»—'}</div>
      </div>
    </div>

    <div class="glass-card" style="margin-top: 24px; padding: 20px;">
      <h3 style="font-size: 16px; margin-bottom: 16px; color: var(--text-secondary);">ğŸ½ Top mÃ³n Ä‘Æ°á»£c order nhiá»u nháº¥t</h3>
      ${getTopItems()}
    </div>

    <div class="glass-card" style="margin-top: 24px; padding: 20px;">
      <h3 style="font-size: 16px; margin-bottom: 16px; color: var(--text-secondary);">ğŸ‘¥ Top ngÆ°á»i order nhiá»u nháº¥t</h3>
      ${getTopPeople()}
    </div>

    <div class="glass-card" style="margin-top: 24px; padding: 20px;">
      <h3 style="font-size: 16px; margin-bottom: 16px; color: var(--text-secondary);">ğŸ“‘ BÃ¡o cÃ¡o VIP (náº¡p/rÃºt)</h3>
      <div class="form-group">
        <label class="form-label">Chá»n VIP</label>
        <select id="vipReportSelect" class="form-input"></select>
      </div>
      <div id="vipReportContent" class="info-list"></div>
    </div>
  `;

      document.getElementById('statsContent').innerHTML = statsHTML;
      initVipReportPanel();
    }

    function getTopItems() {
      const itemMap = new Map();

      orderHistory.forEach(order => {
        const current = itemMap.get(order.itemName) || { count: 0, revenue: 0 };
        current.count += 1;
        current.revenue += order.revenue;
        itemMap.set(order.itemName, current);
      });

      const sorted = Array.from(itemMap.entries())
        .sort((a, b) => b[1].count - a[1].count)
        .slice(0, 5);

      if (sorted.length === 0) return '<div class="empty-state-icon">â€”</div>';

      return `
    <ul class="info-list">
      ${sorted.map(([name, data]) => `
        <li>
          <span class="name">${name}</span>
          <span>
            <span class="value">${data.count} láº§n</span>
            <span class="note">${formatMoney(data.revenue)}</span>
          </span>
        </li>
      `).join('')}
    </ul>
  `;
    }

    function getTopPeople() {
      const peopleMap = new Map();

      orderHistory.forEach(order => {
        order.details.forEach(d => {
          const current = peopleMap.get(d.name) || { count: 0, total: 0 };
          current.count += d.qty;
          current.total += d.due;
          peopleMap.set(d.name, current);
        });
      });

      const sorted = Array.from(peopleMap.entries())
        .sort((a, b) => b[1].count - a[1].count)
        .slice(0, 5);

      if (sorted.length === 0) return '<div class="empty-state-icon">â€”</div>';

      return `
    <ul class="info-list">
      ${sorted.map(([name, data]) => `
        <li>
          <span class="name">${name}</span>
          <span>
            <span class="value">${data.count} pháº§n</span>
            <span class="note">${formatMoney(data.total)}</span>
          </span>
        </li>
      `).join('')}
    </ul>
  `;
    }

    function getVipNamesFromTransactions() {
      const names = new Set();
      vipTransactions.forEach(tx => {
        if (tx?.name) names.add(tx.name);
      });
      return Array.from(names).sort((a, b) => a.localeCompare(b, 'vi', { sensitivity: 'base' }));
    }

    function initVipReportPanel() {
      const select = document.getElementById('vipReportSelect');
      const content = document.getElementById('vipReportContent');
      if (!select || !content) return;

      const names = getVipNamesFromTransactions();
      if (names.length === 0) {
        select.innerHTML = '<option value="">ChÆ°a cÃ³ giao dá»‹ch VIP</option>';
        content.innerHTML = '<div class="empty-state" style="padding:12px 0;">ChÆ°a cÃ³ giao dá»‹ch VIP</div>';
        return;
      }

      select.innerHTML = ['<option value="">Chá»n VIP...</option>'].concat(
        names.map(n => `<option value="${n}">${n}</option>`)
      ).join('');

      select.onchange = (e) => {
        renderVipReport(e.target.value);
      };

      renderVipReport(names[0]);
      select.value = names[0];
    }

    function renderVipReport(name) {
      const content = document.getElementById('vipReportContent');
      if (!content) return;
      const vipName = document.getElementById('vipMemberSelect').value;
      if (!vipName) {
        document.getElementById('vipHistoryContent').innerHTML = '<p style="text-align: center; color: var(--text-secondary);">Chá»n VIP Ä‘á»ƒ xem lá»‹ch sá»­</p>';
        return;
      }

      // Load saved initial balance
      const savedBalance = localStorage.getItem(`vipInitialBalance_${vipName}`);
      const initialBalanceInput = document.getElementById('vipInitialBalance');
      const initialBalance = getInitialBalanceForVip(vipName, { persistDefault: true });
      if (initialBalanceInput) {
        initialBalanceInput.value = savedBalance !== null ? savedBalance : initialBalance;
      }

      if (!name) {
        content.innerHTML = '<div class="empty-state" style="padding:12px 0;">Chá»n VIP Ä‘á»ƒ xem lá»‹ch sá»­</div>';
        return;
      }

      const records = vipTransactions.filter(tx => tx.name === name);
      if (records.length === 0) {
        content.innerHTML = '<div class="empty-state" style="padding:12px 0;">KhÃ´ng cÃ³ giao dá»‹ch cho VIP nÃ y</div>';
        return;
      }

      const html = `
    <ul class="mini-list">
      ${records.map(tx => `
        <li>
          <div>
            <div><strong>${tx.name}</strong> â€¢ ${tx.type === 'cashout' ? 'RÃºt' : 'Náº¡p'}</div>
            <div class="note">${formatDate(tx.ts)}</div>
          </div>
            <div class="${tx.amount >= 0 ? 'amount-positive' : 'amount-negative'}">
              ${tx.amount >= 0 ? '+' : ''}${formatMoney(tx.amount)}
            </div>
        </li>
      `).join('')}
    </ul>
  `;

      content.innerHTML = html;
    }

    // Load VIP on page load
    document.addEventListener('DOMContentLoaded', () => {
      vipTransactions = normalizeVipTransactions(JSON.parse(localStorage.getItem(VIP_TX_KEY) || '[]'));
      hydrateVipAreaFromData();
      renderVipHistory();
      refreshQuickOrderList();
      updateDishNameSuggestions();
      loadGithubSettings();
      populateVipMemberSelect();
      populateVIPFilterDropdown(); // Populate filter dropdown
      recomputeVipBalances();
      // Enable dish name suggestions dropdown
      const itemNameInput = document.getElementById('itemName');
      if (itemNameInput) {
        ['focus', 'click'].forEach(evt => itemNameInput.addEventListener(evt, openDishSuggestions));
      }

      // Lock VIP textarea to prevent manual editing
      const vipArea = document.getElementById('vipArea');
      if (vipArea) {
        vipArea.setAttribute('readonly', true);
        vipArea.style.cursor = 'not-allowed';
        vipArea.style.opacity = '0.8';
        vipArea.title = 'Chá»‰ cÃ³ thá»ƒ thay Ä‘á»•i qua Náº¡p VIP, Cash Out, hoáº·c Order';
      }

      initDraftAutosave();

      // Add listener for alvinFree checkbox to adjust min value of n
      const alvinFreeCheckbox = document.getElementById('alvinFree');
      const nInput = document.getElementById('n');

      if (alvinFreeCheckbox && nInput) {
        alvinFreeCheckbox.addEventListener('change', function () {
          if (this.checked) {
            nInput.min = 2;
            if (Number(nInput.value) < 2) {
              nInput.value = 2;
            }
          } else {
            nInput.min = 1;
          }
        });
      }

      const desiredPriceInput = document.getElementById('desiredPrice');
      if (desiredPriceInput) {
        desiredPriceInput.addEventListener('input', handleDesiredPriceInput);
        desiredPriceInput.addEventListener('change', handleDesiredPriceInput);
      }

      // Auto-backup mode: run export silently after load
      if (autoBackupMode) {
        setTimeout(() => {
          exportForAutomation({ download: false, silent: true });
        }, 1200);
      }

      // Auto-pull from GitHub on load (if configured)
      const githubRepo = localStorage.getItem(GITHUB_REPO_KEY);
      const githubToken = localStorage.getItem(GITHUB_TOKEN_KEY);

      if (githubRepo && githubToken) {
        setTimeout(async () => {
          try {
            addBackupLog('ğŸ”„ Auto-pull on load...');
            const remote = await pullFromGithub();

            if (remote) {
              // Check if remote is newer than local
              const localTimestamp = localStorage.getItem('lastDataTimestamp') || '0';
              const remoteTimestamp = remote.backupTime || remote.timestamp;

              if (remoteTimestamp > localTimestamp) {
                const local = {
                  orderHistory: orderHistory,
                  vipTransactions: vipTransactions
                };

                const merged = mergeData(local, remote.data);
                applyRemoteData(merged);

                // Refresh UI
                loadHistory();
                loadDebtManagement();
                renderVipHistory();
                populateVipMemberSelect();

                // Save timestamp
                localStorage.setItem('lastDataTimestamp', remoteTimestamp);

                addBackupLog(`âœ… Auto-pull complete: synced ${merged.orderHistory.length} orders`);
              } else {
                addBackupLog('â„¹ï¸ Local data is up to date');
              }
            }
          } catch (err) {
            // Silently fail - don't block app loading
            console.warn('Auto-pull failed:', err);
            addBackupLog(`âš ï¸ Auto-pull failed: ${err.message}`);
          }
        }, 2000); // Delay to not block initial load
      }
    });

    // VIP Management Functions
    function addNewVIP() {
      // Open modal
      document.getElementById('vipTopupModal').classList.add('active');
      // Clear previous values
      document.getElementById('vipTopupName').value = '';
      document.getElementById('vipTopupAmount').value = '';
      // Focus on name input
      setTimeout(() => document.getElementById('vipTopupName').focus(), 100);
    }

    function closeVipTopupModal() {
      document.getElementById('vipTopupModal').classList.remove('active');
    }

    function submitVipTopup() {
      const name = document.getElementById('vipTopupName').value.trim();
      const amount = document.getElementById('vipTopupAmount').value;

      if (!name) {
        alert('âš ï¸ Vui lÃ²ng nháº­p tÃªn VIP!');
        document.getElementById('vipTopupName').focus();
        return;
      }

      if (!amount || isNaN(amount) || Number(amount) <= 0) {
        alert('âš ï¸ Sá»‘ tiá»n khÃ´ng há»£p lá»‡!');
        document.getElementById('vipTopupAmount').focus();
        return;
      }

      const vipMap = parseVip(document.getElementById('vipArea').value);
      const currentBalance = vipMap.get(name) || 0;
      const newBalance = currentBalance + Number(amount);

      vipMap.set(name, newBalance);

      const vipText = vipToText(vipMap);
      document.getElementById('vipArea').value = vipText;
      persistVipList(vipText);

      recordVipTransaction({ name: name, amount: Number(amount), type: 'topup' });

      // Close modal
      closeVipTopupModal();

      // Show success
      alert(`âœ… ÄÃ£ náº¡p ${formatMoney(Number(amount))} cho ${name}\nSá»‘ dÆ° má»›i: ${formatMoney(newBalance)}`);
    }

    function cashOutVIP() {
      // Parse VIP list
      const vipMap = parseVip(document.getElementById('vipArea').value);

      // Populate dropdown
      const select = document.getElementById('vipCashOutName');
      select.innerHTML = '<option value="">-- Chá»n VIP --</option>';

      for (const [name, balance] of vipMap.entries()) {
        const option = document.createElement('option');
        option.value = name;
        option.textContent = `${name} (${formatMoney(balance)})`;
        select.appendChild(option);
      }

      // Clear previous values
      document.getElementById('vipCashOutCurrentBalance').value = '';
      document.getElementById('vipCashOutAmount').value = '';

      // Open modal
      document.getElementById('vipCashOutModal').classList.add('active');
    }

    function closeVipCashOutModal() {
      document.getElementById('vipCashOutModal').classList.remove('active');
    }

    function updateCashOutBalance() {
      const name = document.getElementById('vipCashOutName').value;
      if (!name) {
        document.getElementById('vipCashOutCurrentBalance').value = '';
        return;
      }

      const vipMap = parseVip(document.getElementById('vipArea').value);
      const balance = vipMap.get(name) || 0;
      document.getElementById('vipCashOutCurrentBalance').value = formatMoney(balance);
    }

    function submitVipCashOut() {
      const name = document.getElementById('vipCashOutName').value;

      if (!name) {
        alert('âš ï¸ Vui lÃ²ng chá»n VIP!');
        return;
      }

      const vipMap = parseVip(document.getElementById('vipArea').value);
      const currentBalance = vipMap.get(name) || 0;

      if (currentBalance <= 0) {
        alert('âš ï¸ VIP nÃ y khÃ´ng cÃ³ sá»‘ dÆ°!');
        return;
      }

      const amountInput = document.getElementById('vipCashOutAmount').value;
      let amount = 0;

      if (!amountInput || amountInput.trim() === '') {
        // RÃºt háº¿t
        amount = currentBalance;
      } else {
        amount = Number(amountInput);
        if (isNaN(amount) || amount <= 0) {
          alert('âš ï¸ Sá»‘ tiá»n khÃ´ng há»£p lá»‡!');
          document.getElementById('vipCashOutAmount').focus();
          return;
        }
        if (amount > currentBalance) {
          alert(`âš ï¸ Sá»‘ tiá»n rÃºt vÆ°á»£t quÃ¡ sá»‘ dÆ° hiá»‡n táº¡i (${formatMoney(currentBalance)})!`);
          document.getElementById('vipCashOutAmount').focus();
          return;
        }
      }

      const newBalance = currentBalance - amount;

      if (newBalance === 0) {
        if (!confirm(`RÃºt háº¿t ${formatMoney(amount)} vÃ  xÃ³a ${name} khá»i danh sÃ¡ch VIP?`)) {
          return;
        }
        vipMap.delete(name);
      } else {
        vipMap.set(name, newBalance);
      }

      const vipText = vipToText(vipMap);
      document.getElementById('vipArea').value = vipText;
      persistVipList(vipText);

      recordVipTransaction({ name: name, amount: amount, type: 'cashout' });

      // Close modal
      closeVipCashOutModal();

      // Show success
      if (newBalance === 0) {
        alert(`âœ… ÄÃ£ rÃºt ${formatMoney(amount)} vÃ  xÃ³a ${name} khá»i danh sÃ¡ch VIP`);
      } else {
        alert(`âœ… ÄÃ£ rÃºt ${formatMoney(amount)} cho ${name}\nSá»‘ dÆ° má»›i: ${formatMoney(newBalance)}`);
      }
    }
    function importHistory() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';

      input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            const data = JSON.parse(event.target.result);

            if (!Array.isArray(data)) {
              throw new Error('Invalid format');
            }

            if (confirm(`Báº¡n cÃ³ cháº¯c muá»‘n import ${data.length} Ä‘Æ¡n hÃ ng?\n\nLÆ°u Ã½: Dá»¯ liá»‡u hiá»‡n táº¡i sáº½ Bá»Š GHI ÄÃˆ!`)) {
              orderHistory = data;
              localStorage.setItem('orderHistory', JSON.stringify(orderHistory));
              hydrateVipAreaFromData({ forceHistory: true });
              refreshQuickOrderList();
              loadHistory();
              alert('âœ… Import thÃ nh cÃ´ng!');
            }
          } catch (err) {
            alert('âŒ File khÃ´ng há»£p lá»‡! Vui lÃ²ng chá»n file JSON Ä‘Ãºng Ä‘á»‹nh dáº¡ng.');
          }
        };

        reader.readAsText(file);
      };

      input.click();
    }

    // Close modal when clicking outside
    document.getElementById('orderModal').addEventListener('click', (e) => {
      if (e.target.id === 'orderModal') {
        closeModal();
      }
    });
  </script>

</body>


</body>

</html>